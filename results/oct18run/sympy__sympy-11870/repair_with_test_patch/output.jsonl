{"instance_id": "sympy__sympy-11870", "raw_output": ["To address the issue of simplifying exponential expressions to trigonometric identities, we need to modify the `trigsimp` function in `sympy/simplify/trigsimp.py` to handle such cases. Specifically, we need to ensure that expressions like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` are simplified to `sin(k)` and `1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))` are simplified to `sinc(k)`.\n\nHere are the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return trigsimpfunc(expr)\n=======\n    simplified_expr = trigsimpfunc(expr)\n    \n    # Additional simplification for exponential to trigonometric forms\n    if simplified_expr.has(exp):\n        simplified_expr = exptrigsimp(simplified_expr)\n    \n    return simplified_expr\n>>>>>>> REPLACE\n```\n\nThis change ensures that after applying the selected trigonometric simplification method, we further simplify any remaining exponential expressions to their trigonometric forms using `exptrigsimp`.\n\nNext, we need to ensure that the `exptrigsimp` function can handle the specific cases mentioned in the issue. We will add handling for the `sinc` function in `exptrigsimp`.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr\n=======\n    return expr.rewrite(sinc)\n>>>>>>> REPLACE\n```\n\nThis change ensures that after simplifying exponential/trigonometric/hyperbolic functions, we also attempt to rewrite the expression in terms of the `sinc` function if applicable.\n\nFinally, we need to add the corresponding unit tests to ensure our changes work as expected.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_issue_simplifying_exponential_to_trig():\n+    from sympy import exp, I, sinc\n+    k = symbols('k', real=True)\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    \n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes should address the issue and ensure that the expressions are simplified correctly.", "To address the issue of converting exponential expressions to trigonometric identities, we need to enhance the `trigsimp` and `exptrigsimp` functions to handle specific cases more effectively. Here are the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        return min(*choices, key=count_ops)\n=======\n        best_choice = min(*choices, key=count_ops)\n        if best_choice.has(exp):\n            # Attempt to apply additional simplification for specific cases\n            simplified = exptrigsimp(best_choice)\n            if count_ops(simplified) < count_ops(best_choice):\n                return simplified\n        return best_choice\n>>>>>>> REPLACE\n```\n\nNext, we need to ensure that `exptrigsimp` can handle the given transformations more effectively.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        newexpr = TR2i(newexpr)\n=======\n        newexpr = TR2i(newexpr)\n        # Additional transformation for specific exponential combinations\n        if newexpr.has(exp):\n            newexpr = newexpr.replace(exp(I * x) - exp(-I * x), 2 * I * sin(x))\n>>>>>>> REPLACE\n```\n\nFinally, let's add a unit test to ensure our new functionality works correctly.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\ndef test_issue_trig_exponential():\n    k = symbols('k')\n    f = 1 / 2 * (-I * exp(I * k) + I * exp(-I * k))\n    assert trigsimp(f) == sin(k)\n    f = 1 / 2 / k * (-I * exp(I * k) + I * exp(-I * k))\n    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes should enable the simplification of the given exponential expressions to their respective trigonometric identities.", "The issue described involves the `trigsimp` function not correctly simplifying certain exponential expressions to their trigonometric equivalents. We'll address this by modifying the `exptrigsimp` function in `sympy/simplify/trigsimp.py`, which is responsible for simplifying exponential expressions involving trigonometric functions.\n\nAdditionally, we'll add test cases to the test file to ensure this issue does not recur.\n\n### Required Edits\n\n1. **Update the `trigsimp` function to handle exponential to trigonometric conversions more effectively.**\n\nWe'll enhance the `exptrigsimp` function to recognize and handle these patterns.\n\n2. **Add corresponding test cases to verify the solution.**\n\nHere are the specific changes needed:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n=======\n        return min(*choices, key=count_ops)\n    \n    def _exponential_to_trig(e):\n        # Convert exponential forms to trigonometric forms\n        if isinstance(e, Mul):\n            coeff, exp_term = e.as_coeff_Mul()\n            if exp_term == (I*exp(I*e.args[0]) - I*exp(-I*e.args[0]))/2:\n                return coeff * sin(e.args[0])\n        return e\n    \n    newexpr = bottom_up(expr, lambda e: _exponential_to_trig(exp_trig(e)))\n>>>>>>> REPLACE\n```\n\nThis modification includes a helper function `_exponential_to_trig` which detects specific exponential forms and converts them to their trigonometric equivalents before further processing.\n\n3. **Add corresponding test cases to verify the solution.**\n\nWe're adding new test cases to `sympy/functions/elementary/tests/test_trigonometric.py` to ensure the correct behavior of `trigsimp`.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_issue_exponential_to_trig():\n+    from sympy.abc import k\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    \n+    f = 1 / (2 * k) * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThis ensures that the issues described in the original issue statement are covered by the test suite.\n\n### Summary of Changes\n\n1. Added logic to convert exponential forms to trigonometric forms in the `exptrigsimp` function.\n2. Added test cases to verify that `trigsimp` correctly simplifies these forms.\n\nThese changes should resolve the issue described and prevent regressions in the future.", "To address the issue stated, we need to simplify the expressions involving exponentials to trigonometric functions and their related forms such as `sinc`. The functionality for this involves looking into `trigsimp` and `simplify` functions. \n\nBased on the provided information, it seems that trigonometric simplifications are not effectively converting certain exponential expressions to trigonometric forms like `sin(k)` and `sinc(k)`. \n\nHere's how to localize and fix this in the existing source code to handle the specific cases mentioned in the issue:\n\n1. **File: `sympy/simplify/trigsimp.py`**\n    - Update `trigsimp` to handle exponential forms that can be simplified to trigonometric functions.\n\n2. **File: `sympy/functions/elementary/tests/test_trigonometric.py`**\n    - Add the relevant test cases to ensure the function works as expected.\n\nHere's how to proceed with the edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    trigsimpfunc = {\n=======\n    from sympy import exp, sin\n\n    def exp_to_trig(expr):\n        return expr.replace(exp, lambda x: sin(x.args[0] * I) / I if x.args[0].is_number else exp(x.args[0]))\n\n    expr = exp_to_trig(expr)\n\n    trigsimpfunc = {\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_trig_exponential_to_trig():\n+    from sympy import exp, sin, sinc, I\n+    k = symbols('k', real=True)\n+    assert trigsimp(1 / 2 * (-I*exp(I*k) + I*exp(-I*k))) == sin(k)\n+    assert trigsimp(1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))).rewrite(sinc) == sinc(k)\n\n>>>>>>> REPLACE\n```\n\nThe first edit ensures that `trigsimp` tries to convert exponential forms to trigonometric forms before applying other simplifications. The second edit adds unit tests for these specific simplifications to ensure they work correctly.\n\nWith these modifications, the issue of simplifying exponential forms to trigonometric identities should be resolved.", "To fix the issue related to simplifying exponential to trigonometric identities and ensuring that `trigsimp` yields the expected results for the given expressions, we need to modify the `trigsimp` function to ensure it can handle expressions involving exponentials better. Specifically, we need to ensure that it recognizes expressions that can be converted to trigonometric functions like `sin` and `sinc`.\n\nWe should also modify the test cases to verify the fix. Thus, we will be editing the `trigsimp` function in `sympy/simplify/trigsimp.py` and the test cases in `sympy/functions/elementary/tests/test_trigonometric.py`.\n\nHere are the necessary changes:\n\n### 1. Update the `trigsimp` function\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return trigsimpfunc(expr)\n=======\n    result = trigsimpfunc(expr)\n    \n    # Additional simplification for expressions involving exponentials \n    # that should simplify to trigonometric functions\n    if result.has(exp):\n        result = exptrigsimp(result)\n    \n    return result\n>>>>>>> REPLACE\n```\n\n### 2. Add test cases to verify the fix\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n+\n def test_issue_11864():\n=======\ndef test_issue_simplifying_exponential_trig():\n    k = symbols('k', real=True)\n    f1 = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f1) == sin(k)\n\n    f2 = 1 / (2 * k) * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f2) == sinc(k)\n   \n>>>>>>> REPLACE\n```\n\nThese changes should address the issue by ensuring that `trigsimp` can handle exponential expressions and convert them appropriately to trigonometric functions. We also added test cases to verify that the fix works correctly.", "To address the issue of simplifying exponential functions to trigonometric identities in SymPy, we need to modify the `trigsimp` function and ensure that it can handle the desired transformations. Specifically, we're going to enhance the `trigsimp` function to recognize and simplify expressions like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` to `sin(k)` and `1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))` to `sinc(k)`.\n\nHere are the `SEARCH/REPLACE` edits required to fix the issue:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr.func(*[fu(a, measure=measure) for a in expr.args])\n>>>>>>> REPLACE\n    # Handle specific exponential forms separately first\n    expr = expr.replace(lambda e: e.is_Mul and any(isinstance(arg, exp) for arg in e.args), exptrigsimp)\n    return expr.func(*[fu(a, measure=measure) for a in expr.args])\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+    from sympy import exp, I, sinc\n+    k = symbols('k', real=True)\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes will ensure that the `trigsimp` function is capable of handling the specific exponential to trigonometric simplifications discussed in the issue. The test modifications will validate these improvements.", "To address the issue of simplifying exponential expressions into their trigonometric identities and recognizing the sinc function, we need to ensure the trigsimp function and related simplification routines can handle these conversions correctly.\n\nWe will focus on the `trigsimp` function and the `exptrigsimp` function. The changes will involve adding more sophisticated rules to identify patterns like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` and converting them to their trigonometric forms.\n\nHere are the `SEARCH/REPLACE` edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n=======\n_trigs = (TrigonometricFunction, HyperbolicFunction, exp)\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr\n=======\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    return expr\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/fu.py\n<<<<<<< SEARCH\n    rv = TR1(rv)\n=======\n    rv = TR1(rv)\n    if rv.has(exp):\n        rv = exptrigsimp(rv)\n>>>>>>> REPLACE\n```\n\nThe tests provided in the patch file seem to focus on the Piecewise function and the sinc function; however, they didn't cover the initial problem stated in the issue. To address the initial problem directly, we should add specific test cases covering the simplification from exponential to trigonometric forms.\n\nHere is an additional patch to add those test cases:\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_exponential_to_trig():\n+    from sympy import exp, I, trigsimp, sin, Symbol\n+    k = Symbol('k')\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+\n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    from sympy import sinc\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes aim to extend the capabilities of `trigsimp` and `exptrigsimp` to handle the specific cases mentioned in the issue and ensure these patterns are recognized and simplified appropriately.", "Based on the issue statement and the provided details, it seems that the root cause of the problem lies within the `trigsimp` function, which fails to simplify the given exponential expressions to trigonometric identities. To resolve the issue, we should ensure that the exponential expressions are adequately handled and transformed into their corresponding trigonometric forms.\n\nHere are the steps to fix the issue:\n\n1. Update `trigsimp` function to better handle exponential forms and their simplifications.\n2. Apply special handling within `exptrigsimp` function to convert exponential forms directly into trigonometric forms when required.\n\nBelow are the necessary search/replace edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        'matching': (lambda x: futrig(x)),\n=======\n        'matching': (lambda x: exptrigsimp(futrig(x))),\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    if newexpr.has(TrigonometricFunction):\n=======\n    if newexpr.has(TrigonometricFunction, exp):\n>>>>>>> REPLACE\n```\n\nWith these changes, the `trigsimp` function will use `exptrigsimp` to handle exponential expressions, ensuring they are appropriately simplified into trigonometric forms. This should resolve the issue where the exponential expressions aren't being simplified as expected.", "To address the issue of simplifying exponential expressions to trigonometric identities, we need to update the `trigsimp` function. Specifically, we should ensure it can recognize and simplify expressions such as the given exponentials to their trigonometric counterparts.\n\nLet's make the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n=======\n_trigs = (TrigonometricFunction, HyperbolicFunction, exp)\n>>>>>>> REPLACE\n```\n\nNext, let's update the test cases to ensure they cover the new functionality:\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+\ndef test_issue_12345():\n    # Simplify exponential to sin\n    k = symbols('k')\n    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f) == sin(k)\n    # Simplify exponential to sinc\n    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThis change in `sympy/simplify/trigsimp.py` ensures that the `trigsimp` function can now handle exponential expressions by including `exp` in the `_trigs` tuple. The additional test cases in `sympy/functions/elementary/tests/test_trigonometric.py` will ensure that the new functionality is tested and verified. \n\nWith these changes, the `trigsimp` function should now be able to simplify the given exponential expressions to their corresponding trigonometric forms.", "The issue primarily revolves around the `trigsimp` function not simplifying certain exponential expressions into trigonometric identities as expected. The changes needed will involve ensuring that `trigsimp` recognizes and simplifies such expressions correctly.\n\nLet's create the necessary *SEARCH/REPLACE* edits to add the required functionality.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\ndef trigsimp(expr, **opts):\n=======\nfrom sympy import expand_trig\n\ndef trigsimp(expr, **opts):\n    expr = expand_trig(expr)\n>>>>>>> REPLACE\n```\n\nThe addition of `expand_trig` will help to expand the trigonometric expressions in the exponential form, allowing `trigsimp` to recognize and simplify them correctly.\n\n```python\n### sympy/simplify/fu.py\n<<<<<<< SEARCH\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n=======\nfrom sympy import expand_trig\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    rv = expand_trig(rv)\n>>>>>>> REPLACE\n```\n\nAdding `expand_trig` in the `fu` function will help in expanding and simplifying exponential forms within the function.\n\nThese changes should enable the simplification of the given expressions to their expected trigonometric forms. Make sure to run your test cases to verify that the issue is resolved."], "all_generations": [["To address the issue of simplifying exponential expressions to trigonometric identities, we need to modify the `trigsimp` function in `sympy/simplify/trigsimp.py` to handle such cases. Specifically, we need to ensure that expressions like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` are simplified to `sin(k)` and `1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))` are simplified to `sinc(k)`.\n\nHere are the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return trigsimpfunc(expr)\n=======\n    simplified_expr = trigsimpfunc(expr)\n    \n    # Additional simplification for exponential to trigonometric forms\n    if simplified_expr.has(exp):\n        simplified_expr = exptrigsimp(simplified_expr)\n    \n    return simplified_expr\n>>>>>>> REPLACE\n```\n\nThis change ensures that after applying the selected trigonometric simplification method, we further simplify any remaining exponential expressions to their trigonometric forms using `exptrigsimp`.\n\nNext, we need to ensure that the `exptrigsimp` function can handle the specific cases mentioned in the issue. We will add handling for the `sinc` function in `exptrigsimp`.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr\n=======\n    return expr.rewrite(sinc)\n>>>>>>> REPLACE\n```\n\nThis change ensures that after simplifying exponential/trigonometric/hyperbolic functions, we also attempt to rewrite the expression in terms of the `sinc` function if applicable.\n\nFinally, we need to add the corresponding unit tests to ensure our changes work as expected.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_issue_simplifying_exponential_to_trig():\n+    from sympy import exp, I, sinc\n+    k = symbols('k', real=True)\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    \n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes should address the issue and ensure that the expressions are simplified correctly.", "To address the issue of converting exponential expressions to trigonometric identities, we need to enhance the `trigsimp` and `exptrigsimp` functions to handle specific cases more effectively. Here are the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        return min(*choices, key=count_ops)\n=======\n        best_choice = min(*choices, key=count_ops)\n        if best_choice.has(exp):\n            # Attempt to apply additional simplification for specific cases\n            simplified = exptrigsimp(best_choice)\n            if count_ops(simplified) < count_ops(best_choice):\n                return simplified\n        return best_choice\n>>>>>>> REPLACE\n```\n\nNext, we need to ensure that `exptrigsimp` can handle the given transformations more effectively.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        newexpr = TR2i(newexpr)\n=======\n        newexpr = TR2i(newexpr)\n        # Additional transformation for specific exponential combinations\n        if newexpr.has(exp):\n            newexpr = newexpr.replace(exp(I * x) - exp(-I * x), 2 * I * sin(x))\n>>>>>>> REPLACE\n```\n\nFinally, let's add a unit test to ensure our new functionality works correctly.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\ndef test_issue_trig_exponential():\n    k = symbols('k')\n    f = 1 / 2 * (-I * exp(I * k) + I * exp(-I * k))\n    assert trigsimp(f) == sin(k)\n    f = 1 / 2 / k * (-I * exp(I * k) + I * exp(-I * k))\n    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes should enable the simplification of the given exponential expressions to their respective trigonometric identities.", "The issue described involves the `trigsimp` function not correctly simplifying certain exponential expressions to their trigonometric equivalents. We'll address this by modifying the `exptrigsimp` function in `sympy/simplify/trigsimp.py`, which is responsible for simplifying exponential expressions involving trigonometric functions.\n\nAdditionally, we'll add test cases to the test file to ensure this issue does not recur.\n\n### Required Edits\n\n1. **Update the `trigsimp` function to handle exponential to trigonometric conversions more effectively.**\n\nWe'll enhance the `exptrigsimp` function to recognize and handle these patterns.\n\n2. **Add corresponding test cases to verify the solution.**\n\nHere are the specific changes needed:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n=======\n        return min(*choices, key=count_ops)\n    \n    def _exponential_to_trig(e):\n        # Convert exponential forms to trigonometric forms\n        if isinstance(e, Mul):\n            coeff, exp_term = e.as_coeff_Mul()\n            if exp_term == (I*exp(I*e.args[0]) - I*exp(-I*e.args[0]))/2:\n                return coeff * sin(e.args[0])\n        return e\n    \n    newexpr = bottom_up(expr, lambda e: _exponential_to_trig(exp_trig(e)))\n>>>>>>> REPLACE\n```\n\nThis modification includes a helper function `_exponential_to_trig` which detects specific exponential forms and converts them to their trigonometric equivalents before further processing.\n\n3. **Add corresponding test cases to verify the solution.**\n\nWe're adding new test cases to `sympy/functions/elementary/tests/test_trigonometric.py` to ensure the correct behavior of `trigsimp`.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_issue_exponential_to_trig():\n+    from sympy.abc import k\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    \n+    f = 1 / (2 * k) * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThis ensures that the issues described in the original issue statement are covered by the test suite.\n\n### Summary of Changes\n\n1. Added logic to convert exponential forms to trigonometric forms in the `exptrigsimp` function.\n2. Added test cases to verify that `trigsimp` correctly simplifies these forms.\n\nThese changes should resolve the issue described and prevent regressions in the future.", "To address the issue stated, we need to simplify the expressions involving exponentials to trigonometric functions and their related forms such as `sinc`. The functionality for this involves looking into `trigsimp` and `simplify` functions. \n\nBased on the provided information, it seems that trigonometric simplifications are not effectively converting certain exponential expressions to trigonometric forms like `sin(k)` and `sinc(k)`. \n\nHere's how to localize and fix this in the existing source code to handle the specific cases mentioned in the issue:\n\n1. **File: `sympy/simplify/trigsimp.py`**\n    - Update `trigsimp` to handle exponential forms that can be simplified to trigonometric functions.\n\n2. **File: `sympy/functions/elementary/tests/test_trigonometric.py`**\n    - Add the relevant test cases to ensure the function works as expected.\n\nHere's how to proceed with the edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    trigsimpfunc = {\n=======\n    from sympy import exp, sin\n\n    def exp_to_trig(expr):\n        return expr.replace(exp, lambda x: sin(x.args[0] * I) / I if x.args[0].is_number else exp(x.args[0]))\n\n    expr = exp_to_trig(expr)\n\n    trigsimpfunc = {\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_trig_exponential_to_trig():\n+    from sympy import exp, sin, sinc, I\n+    k = symbols('k', real=True)\n+    assert trigsimp(1 / 2 * (-I*exp(I*k) + I*exp(-I*k))) == sin(k)\n+    assert trigsimp(1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))).rewrite(sinc) == sinc(k)\n\n>>>>>>> REPLACE\n```\n\nThe first edit ensures that `trigsimp` tries to convert exponential forms to trigonometric forms before applying other simplifications. The second edit adds unit tests for these specific simplifications to ensure they work correctly.\n\nWith these modifications, the issue of simplifying exponential forms to trigonometric identities should be resolved.", "To fix the issue related to simplifying exponential to trigonometric identities and ensuring that `trigsimp` yields the expected results for the given expressions, we need to modify the `trigsimp` function to ensure it can handle expressions involving exponentials better. Specifically, we need to ensure that it recognizes expressions that can be converted to trigonometric functions like `sin` and `sinc`.\n\nWe should also modify the test cases to verify the fix. Thus, we will be editing the `trigsimp` function in `sympy/simplify/trigsimp.py` and the test cases in `sympy/functions/elementary/tests/test_trigonometric.py`.\n\nHere are the necessary changes:\n\n### 1. Update the `trigsimp` function\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return trigsimpfunc(expr)\n=======\n    result = trigsimpfunc(expr)\n    \n    # Additional simplification for expressions involving exponentials \n    # that should simplify to trigonometric functions\n    if result.has(exp):\n        result = exptrigsimp(result)\n    \n    return result\n>>>>>>> REPLACE\n```\n\n### 2. Add test cases to verify the fix\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n+\n def test_issue_11864():\n=======\ndef test_issue_simplifying_exponential_trig():\n    k = symbols('k', real=True)\n    f1 = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f1) == sin(k)\n\n    f2 = 1 / (2 * k) * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f2) == sinc(k)\n   \n>>>>>>> REPLACE\n```\n\nThese changes should address the issue by ensuring that `trigsimp` can handle exponential expressions and convert them appropriately to trigonometric functions. We also added test cases to verify that the fix works correctly.", "To address the issue of simplifying exponential functions to trigonometric identities in SymPy, we need to modify the `trigsimp` function and ensure that it can handle the desired transformations. Specifically, we're going to enhance the `trigsimp` function to recognize and simplify expressions like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` to `sin(k)` and `1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))` to `sinc(k)`.\n\nHere are the `SEARCH/REPLACE` edits required to fix the issue:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr.func(*[fu(a, measure=measure) for a in expr.args])\n>>>>>>> REPLACE\n    # Handle specific exponential forms separately first\n    expr = expr.replace(lambda e: e.is_Mul and any(isinstance(arg, exp) for arg in e.args), exptrigsimp)\n    return expr.func(*[fu(a, measure=measure) for a in expr.args])\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+    from sympy import exp, I, sinc\n+    k = symbols('k', real=True)\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes will ensure that the `trigsimp` function is capable of handling the specific exponential to trigonometric simplifications discussed in the issue. The test modifications will validate these improvements.", "To address the issue of simplifying exponential expressions into their trigonometric identities and recognizing the sinc function, we need to ensure the trigsimp function and related simplification routines can handle these conversions correctly.\n\nWe will focus on the `trigsimp` function and the `exptrigsimp` function. The changes will involve adding more sophisticated rules to identify patterns like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` and converting them to their trigonometric forms.\n\nHere are the `SEARCH/REPLACE` edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n=======\n_trigs = (TrigonometricFunction, HyperbolicFunction, exp)\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr\n=======\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    return expr\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/fu.py\n<<<<<<< SEARCH\n    rv = TR1(rv)\n=======\n    rv = TR1(rv)\n    if rv.has(exp):\n        rv = exptrigsimp(rv)\n>>>>>>> REPLACE\n```\n\nThe tests provided in the patch file seem to focus on the Piecewise function and the sinc function; however, they didn't cover the initial problem stated in the issue. To address the initial problem directly, we should add specific test cases covering the simplification from exponential to trigonometric forms.\n\nHere is an additional patch to add those test cases:\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_exponential_to_trig():\n+    from sympy import exp, I, trigsimp, sin, Symbol\n+    k = Symbol('k')\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+\n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    from sympy import sinc\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes aim to extend the capabilities of `trigsimp` and `exptrigsimp` to handle the specific cases mentioned in the issue and ensure these patterns are recognized and simplified appropriately.", "Based on the issue statement and the provided details, it seems that the root cause of the problem lies within the `trigsimp` function, which fails to simplify the given exponential expressions to trigonometric identities. To resolve the issue, we should ensure that the exponential expressions are adequately handled and transformed into their corresponding trigonometric forms.\n\nHere are the steps to fix the issue:\n\n1. Update `trigsimp` function to better handle exponential forms and their simplifications.\n2. Apply special handling within `exptrigsimp` function to convert exponential forms directly into trigonometric forms when required.\n\nBelow are the necessary search/replace edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        'matching': (lambda x: futrig(x)),\n=======\n        'matching': (lambda x: exptrigsimp(futrig(x))),\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    if newexpr.has(TrigonometricFunction):\n=======\n    if newexpr.has(TrigonometricFunction, exp):\n>>>>>>> REPLACE\n```\n\nWith these changes, the `trigsimp` function will use `exptrigsimp` to handle exponential expressions, ensuring they are appropriately simplified into trigonometric forms. This should resolve the issue where the exponential expressions aren't being simplified as expected.", "To address the issue of simplifying exponential expressions to trigonometric identities, we need to update the `trigsimp` function. Specifically, we should ensure it can recognize and simplify expressions such as the given exponentials to their trigonometric counterparts.\n\nLet's make the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n=======\n_trigs = (TrigonometricFunction, HyperbolicFunction, exp)\n>>>>>>> REPLACE\n```\n\nNext, let's update the test cases to ensure they cover the new functionality:\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+\ndef test_issue_12345():\n    # Simplify exponential to sin\n    k = symbols('k')\n    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f) == sin(k)\n    # Simplify exponential to sinc\n    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThis change in `sympy/simplify/trigsimp.py` ensures that the `trigsimp` function can now handle exponential expressions by including `exp` in the `_trigs` tuple. The additional test cases in `sympy/functions/elementary/tests/test_trigonometric.py` will ensure that the new functionality is tested and verified. \n\nWith these changes, the `trigsimp` function should now be able to simplify the given exponential expressions to their corresponding trigonometric forms.", "The issue primarily revolves around the `trigsimp` function not simplifying certain exponential expressions into trigonometric identities as expected. The changes needed will involve ensuring that `trigsimp` recognizes and simplifies such expressions correctly.\n\nLet's create the necessary *SEARCH/REPLACE* edits to add the required functionality.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\ndef trigsimp(expr, **opts):\n=======\nfrom sympy import expand_trig\n\ndef trigsimp(expr, **opts):\n    expr = expand_trig(expr)\n>>>>>>> REPLACE\n```\n\nThe addition of `expand_trig` will help to expand the trigonometric expressions in the exponential form, allowing `trigsimp` to recognize and simplify them correctly.\n\n```python\n### sympy/simplify/fu.py\n<<<<<<< SEARCH\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n=======\nfrom sympy import expand_trig\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    rv = expand_trig(rv)\n>>>>>>> REPLACE\n```\n\nAdding `expand_trig` in the `fu` function will help in expanding and simplifying exponential forms within the function.\n\nThese changes should enable the simplification of the given expressions to their expected trigonometric forms. Make sure to run your test cases to verify that the issue is resolved."]], "try_count": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "traj": [{"response": "To address the issue of simplifying exponential expressions to trigonometric identities, we need to modify the `trigsimp` function in `sympy/simplify/trigsimp.py` to handle such cases. Specifically, we need to ensure that expressions like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` are simplified to `sin(k)` and `1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))` are simplified to `sinc(k)`.\n\nHere are the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return trigsimpfunc(expr)\n=======\n    simplified_expr = trigsimpfunc(expr)\n    \n    # Additional simplification for exponential to trigonometric forms\n    if simplified_expr.has(exp):\n        simplified_expr = exptrigsimp(simplified_expr)\n    \n    return simplified_expr\n>>>>>>> REPLACE\n```\n\nThis change ensures that after applying the selected trigonometric simplification method, we further simplify any remaining exponential expressions to their trigonometric forms using `exptrigsimp`.\n\nNext, we need to ensure that the `exptrigsimp` function can handle the specific cases mentioned in the issue. We will add handling for the `sinc` function in `exptrigsimp`.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr\n=======\n    return expr.rewrite(sinc)\n>>>>>>> REPLACE\n```\n\nThis change ensures that after simplifying exponential/trigonometric/hyperbolic functions, we also attempt to rewrite the expression in terms of the `sinc` function if applicable.\n\nFinally, we need to add the corresponding unit tests to ensure our changes work as expected.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_issue_simplifying_exponential_to_trig():\n+    from sympy import exp, I, sinc\n+    k = symbols('k', real=True)\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    \n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes should address the issue and ensure that the expressions are simplified correctly.", "usage": {"completion_tokens": 526, "prompt_tokens": 6071}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue of converting exponential expressions to trigonometric identities, we need to enhance the `trigsimp` and `exptrigsimp` functions to handle specific cases more effectively. Here are the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        return min(*choices, key=count_ops)\n=======\n        best_choice = min(*choices, key=count_ops)\n        if best_choice.has(exp):\n            # Attempt to apply additional simplification for specific cases\n            simplified = exptrigsimp(best_choice)\n            if count_ops(simplified) < count_ops(best_choice):\n                return simplified\n        return best_choice\n>>>>>>> REPLACE\n```\n\nNext, we need to ensure that `exptrigsimp` can handle the given transformations more effectively.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        newexpr = TR2i(newexpr)\n=======\n        newexpr = TR2i(newexpr)\n        # Additional transformation for specific exponential combinations\n        if newexpr.has(exp):\n            newexpr = newexpr.replace(exp(I * x) - exp(-I * x), 2 * I * sin(x))\n>>>>>>> REPLACE\n```\n\nFinally, let's add a unit test to ensure our new functionality works correctly.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\ndef test_issue_trig_exponential():\n    k = symbols('k')\n    f = 1 / 2 * (-I * exp(I * k) + I * exp(-I * k))\n    assert trigsimp(f) == sin(k)\n    f = 1 / 2 / k * (-I * exp(I * k) + I * exp(-I * k))\n    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes should enable the simplification of the given exponential expressions to their respective trigonometric identities.", "usage": {"completion_tokens": 3760, "prompt_tokens": 6071}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "The issue described involves the `trigsimp` function not correctly simplifying certain exponential expressions to their trigonometric equivalents. We'll address this by modifying the `exptrigsimp` function in `sympy/simplify/trigsimp.py`, which is responsible for simplifying exponential expressions involving trigonometric functions.\n\nAdditionally, we'll add test cases to the test file to ensure this issue does not recur.\n\n### Required Edits\n\n1. **Update the `trigsimp` function to handle exponential to trigonometric conversions more effectively.**\n\nWe'll enhance the `exptrigsimp` function to recognize and handle these patterns.\n\n2. **Add corresponding test cases to verify the solution.**\n\nHere are the specific changes needed:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n=======\n        return min(*choices, key=count_ops)\n    \n    def _exponential_to_trig(e):\n        # Convert exponential forms to trigonometric forms\n        if isinstance(e, Mul):\n            coeff, exp_term = e.as_coeff_Mul()\n            if exp_term == (I*exp(I*e.args[0]) - I*exp(-I*e.args[0]))/2:\n                return coeff * sin(e.args[0])\n        return e\n    \n    newexpr = bottom_up(expr, lambda e: _exponential_to_trig(exp_trig(e)))\n>>>>>>> REPLACE\n```\n\nThis modification includes a helper function `_exponential_to_trig` which detects specific exponential forms and converts them to their trigonometric equivalents before further processing.\n\n3. **Add corresponding test cases to verify the solution.**\n\nWe're adding new test cases to `sympy/functions/elementary/tests/test_trigonometric.py` to ensure the correct behavior of `trigsimp`.\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_issue_exponential_to_trig():\n+    from sympy.abc import k\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    \n+    f = 1 / (2 * k) * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThis ensures that the issues described in the original issue statement are covered by the test suite.\n\n### Summary of Changes\n\n1. Added logic to convert exponential forms to trigonometric forms in the `exptrigsimp` function.\n2. Added test cases to verify that `trigsimp` correctly simplifies these forms.\n\nThese changes should resolve the issue described and prevent regressions in the future.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue stated, we need to simplify the expressions involving exponentials to trigonometric functions and their related forms such as `sinc`. The functionality for this involves looking into `trigsimp` and `simplify` functions. \n\nBased on the provided information, it seems that trigonometric simplifications are not effectively converting certain exponential expressions to trigonometric forms like `sin(k)` and `sinc(k)`. \n\nHere's how to localize and fix this in the existing source code to handle the specific cases mentioned in the issue:\n\n1. **File: `sympy/simplify/trigsimp.py`**\n    - Update `trigsimp` to handle exponential forms that can be simplified to trigonometric functions.\n\n2. **File: `sympy/functions/elementary/tests/test_trigonometric.py`**\n    - Add the relevant test cases to ensure the function works as expected.\n\nHere's how to proceed with the edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    trigsimpfunc = {\n=======\n    from sympy import exp, sin\n\n    def exp_to_trig(expr):\n        return expr.replace(exp, lambda x: sin(x.args[0] * I) / I if x.args[0].is_number else exp(x.args[0]))\n\n    expr = exp_to_trig(expr)\n\n    trigsimpfunc = {\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_trig_exponential_to_trig():\n+    from sympy import exp, sin, sinc, I\n+    k = symbols('k', real=True)\n+    assert trigsimp(1 / 2 * (-I*exp(I*k) + I*exp(-I*k))) == sin(k)\n+    assert trigsimp(1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))).rewrite(sinc) == sinc(k)\n\n>>>>>>> REPLACE\n```\n\nThe first edit ensures that `trigsimp` tries to convert exponential forms to trigonometric forms before applying other simplifications. The second edit adds unit tests for these specific simplifications to ensure they work correctly.\n\nWith these modifications, the issue of simplifying exponential forms to trigonometric identities should be resolved.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To fix the issue related to simplifying exponential to trigonometric identities and ensuring that `trigsimp` yields the expected results for the given expressions, we need to modify the `trigsimp` function to ensure it can handle expressions involving exponentials better. Specifically, we need to ensure that it recognizes expressions that can be converted to trigonometric functions like `sin` and `sinc`.\n\nWe should also modify the test cases to verify the fix. Thus, we will be editing the `trigsimp` function in `sympy/simplify/trigsimp.py` and the test cases in `sympy/functions/elementary/tests/test_trigonometric.py`.\n\nHere are the necessary changes:\n\n### 1. Update the `trigsimp` function\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return trigsimpfunc(expr)\n=======\n    result = trigsimpfunc(expr)\n    \n    # Additional simplification for expressions involving exponentials \n    # that should simplify to trigonometric functions\n    if result.has(exp):\n        result = exptrigsimp(result)\n    \n    return result\n>>>>>>> REPLACE\n```\n\n### 2. Add test cases to verify the fix\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n+\n def test_issue_11864():\n=======\ndef test_issue_simplifying_exponential_trig():\n    k = symbols('k', real=True)\n    f1 = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f1) == sin(k)\n\n    f2 = 1 / (2 * k) * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f2) == sinc(k)\n   \n>>>>>>> REPLACE\n```\n\nThese changes should address the issue by ensuring that `trigsimp` can handle exponential expressions and convert them appropriately to trigonometric functions. We also added test cases to verify that the fix works correctly.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue of simplifying exponential functions to trigonometric identities in SymPy, we need to modify the `trigsimp` function and ensure that it can handle the desired transformations. Specifically, we're going to enhance the `trigsimp` function to recognize and simplify expressions like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` to `sin(k)` and `1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))` to `sinc(k)`.\n\nHere are the `SEARCH/REPLACE` edits required to fix the issue:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr.func(*[fu(a, measure=measure) for a in expr.args])\n>>>>>>> REPLACE\n    # Handle specific exponential forms separately first\n    expr = expr.replace(lambda e: e.is_Mul and any(isinstance(arg, exp) for arg in e.args), exptrigsimp)\n    return expr.func(*[fu(a, measure=measure) for a in expr.args])\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+    from sympy import exp, I, sinc\n+    k = symbols('k', real=True)\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes will ensure that the `trigsimp` function is capable of handling the specific exponential to trigonometric simplifications discussed in the issue. The test modifications will validate these improvements.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue of simplifying exponential expressions into their trigonometric identities and recognizing the sinc function, we need to ensure the trigsimp function and related simplification routines can handle these conversions correctly.\n\nWe will focus on the `trigsimp` function and the `exptrigsimp` function. The changes will involve adding more sophisticated rules to identify patterns like `1 / 2 * (-I*exp(I*k) + I*exp(-I*k))` and converting them to their trigonometric forms.\n\nHere are the `SEARCH/REPLACE` edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n=======\n_trigs = (TrigonometricFunction, HyperbolicFunction, exp)\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    return expr\n=======\n    if expr.has(exp):\n        expr = exptrigsimp(expr)\n    return expr\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/fu.py\n<<<<<<< SEARCH\n    rv = TR1(rv)\n=======\n    rv = TR1(rv)\n    if rv.has(exp):\n        rv = exptrigsimp(rv)\n>>>>>>> REPLACE\n```\n\nThe tests provided in the patch file seem to focus on the Piecewise function and the sinc function; however, they didn't cover the initial problem stated in the issue. To address the initial problem directly, we should add specific test cases covering the simplification from exponential to trigonometric forms.\n\nHere is an additional patch to add those test cases:\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+def test_exponential_to_trig():\n+    from sympy import exp, I, trigsimp, sin, Symbol\n+    k = Symbol('k')\n+    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n+    assert trigsimp(f) == sin(k)\n+\n+    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n+    from sympy import sinc\n+    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThese changes aim to extend the capabilities of `trigsimp` and `exptrigsimp` to handle the specific cases mentioned in the issue and ensure these patterns are recognized and simplified appropriately.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "Based on the issue statement and the provided details, it seems that the root cause of the problem lies within the `trigsimp` function, which fails to simplify the given exponential expressions to trigonometric identities. To resolve the issue, we should ensure that the exponential expressions are adequately handled and transformed into their corresponding trigonometric forms.\n\nHere are the steps to fix the issue:\n\n1. Update `trigsimp` function to better handle exponential forms and their simplifications.\n2. Apply special handling within `exptrigsimp` function to convert exponential forms directly into trigonometric forms when required.\n\nBelow are the necessary search/replace edits:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n        'matching': (lambda x: futrig(x)),\n=======\n        'matching': (lambda x: exptrigsimp(futrig(x))),\n>>>>>>> REPLACE\n```\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n    if newexpr.has(TrigonometricFunction):\n=======\n    if newexpr.has(TrigonometricFunction, exp):\n>>>>>>> REPLACE\n```\n\nWith these changes, the `trigsimp` function will use `exptrigsimp` to handle exponential expressions, ensuring they are appropriately simplified into trigonometric forms. This should resolve the issue where the exponential expressions aren't being simplified as expected.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue of simplifying exponential expressions to trigonometric identities, we need to update the `trigsimp` function. Specifically, we should ensure it can recognize and simplify expressions such as the given exponentials to their trigonometric counterparts.\n\nLet's make the necessary changes:\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n=======\n_trigs = (TrigonometricFunction, HyperbolicFunction, exp)\n>>>>>>> REPLACE\n```\n\nNext, let's update the test cases to ensure they cover the new functionality:\n\n```python\n### sympy/functions/elementary/tests/test_trigonometric.py\n<<<<<<< SEARCH\n+\n=======\n+\ndef test_issue_12345():\n    # Simplify exponential to sin\n    k = symbols('k')\n    f = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f) == sin(k)\n    # Simplify exponential to sinc\n    f = 1 / 2 / k * (-I*exp(I*k) + I*exp(-I*k))\n    assert trigsimp(f) == sinc(k)\n>>>>>>> REPLACE\n```\n\nThis change in `sympy/simplify/trigsimp.py` ensures that the `trigsimp` function can now handle exponential expressions by including `exp` in the `_trigs` tuple. The additional test cases in `sympy/functions/elementary/tests/test_trigonometric.py` will ensure that the new functionality is tested and verified. \n\nWith these changes, the `trigsimp` function should now be able to simplify the given exponential expressions to their corresponding trigonometric forms.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "The issue primarily revolves around the `trigsimp` function not simplifying certain exponential expressions into trigonometric identities as expected. The changes needed will involve ensuring that `trigsimp` recognizes and simplifies such expressions correctly.\n\nLet's create the necessary *SEARCH/REPLACE* edits to add the required functionality.\n\n```python\n### sympy/simplify/trigsimp.py\n<<<<<<< SEARCH\ndef trigsimp(expr, **opts):\n=======\nfrom sympy import expand_trig\n\ndef trigsimp(expr, **opts):\n    expr = expand_trig(expr)\n>>>>>>> REPLACE\n```\n\nThe addition of `expand_trig` will help to expand the trigonometric expressions in the exponential form, allowing `trigsimp` to recognize and simplify them correctly.\n\n```python\n### sympy/simplify/fu.py\n<<<<<<< SEARCH\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n=======\nfrom sympy import expand_trig\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    rv = expand_trig(rv)\n>>>>>>> REPLACE\n```\n\nAdding `expand_trig` in the `fu` function will help in expanding and simplifying exponential forms within the function.\n\nThese changes should enable the simplification of the given expressions to their expected trigonometric forms. Make sure to run your test cases to verify that the issue is resolved.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nsimplifying exponential -> trig identities\n```\r\nf = 1 / 2 * (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\nIdeally, this would yield `sin(k)`. Is there a way to do this?\r\n\r\nAs a corollary, it would be awesome if \r\n\r\n```\r\nf = 1 / 2 / k* (-I*exp(I*k) + I*exp(-I*k))\r\ntrigsimp(f)\r\n```\r\n\r\ncould yield `sinc(k)`. Thank you for your consideration!\n\n--- END ISSUE ---\n\n\nWe also have a fail to pass unit test for the given issue. We can use this to help identify and fix the issue. Here is the patch text:\n--- BEGIN PATCH ---\ndiff --git a/sympy/functions/elementary/tests/test_trigonometric.py b/sympy/functions/elementary/tests/test_trigonometric.py\n--- a/sympy/functions/elementary/tests/test_trigonometric.py\n+++ b/sympy/functions/elementary/tests/test_trigonometric.py\n@@ -6,6 +6,8 @@\n         AccumBounds)\n from sympy.core.compatibility import range\n from sympy.utilities.pytest import XFAIL, slow, raises\n+from sympy.core.relational import Ne, Eq\n+from sympy.functions.elementary.piecewise import Piecewise\n \n x, y, z = symbols('x y z')\n r = Symbol('r', real=True)\n@@ -704,7 +706,7 @@ def test_sinc():\n     assert sinc(x).series() == 1 - x**2/6 + x**4/120 + O(x**6)\n \n     assert sinc(x).rewrite(jn) == jn(0, x)\n-    assert sinc(x).rewrite(sin) == sin(x) / x\n+    assert sinc(x).rewrite(sin) == Piecewise((sin(x)/x, Ne(x, 0)), (1, True))\n \n \n def test_asin():\n@@ -1507,6 +1509,14 @@ def test_trig_period():\n     assert tan(3*x).period(y) == S.Zero\n     raises(NotImplementedError, lambda: sin(x**2).period(x))\n \n+\n def test_issue_7171():\n     assert sin(x).rewrite(sqrt) == sin(x)\n     assert sin(x).rewrite(pow) == sin(x)\n+\n+\n+def test_issue_11864():\n+    w, k = symbols('w, k', real=True)\n+    F = Piecewise((1, Eq(2*pi*k, 0)), (sin(pi*k)/(pi*k), True))\n+    soln = Piecewise((1, Eq(2*pi*k, 0)), (sinc(pi*k), True))\n+    assert F.rewrite(sinc) == soln\n\n--- END PATCH ---\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sympy/simplify/trigsimp.py\n...\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n...\n\n\n### sympy/simplify/simplify.py\n...\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n    return e\n\n\ndef simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n    # type: (object, object, object, object) -> object\n    \"\"\"\n    Simplifies the given expression.\n\n    Simplification is not a well defined term and the exact strategies\n    this function tries can change in the future versions of SymPy. If\n    your algorithm relies on \"simplification\" (whatever it is), try to\n    determine what you need exactly  -  is it powsimp()?, radsimp()?,\n    together()?, logcombine()?, or something else? And use this particular\n    function directly, because those are well defined and thus your algorithm\n    will be robust.\n\n    Nonetheless, especially for interactive use, or when you don't know\n    anything about the structure of the expression, simplify() tries to apply\n    intelligent heuristics to make the input expression \"simpler\".  For\n    example:\n\n    >>> from sympy import simplify, cos, sin\n    >>> from sympy.abc import x, y\n    >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> a\n    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n    >>> simplify(a)\n    x + 1\n\n    Note that we could have obtained the same result by using specific\n    simplification functions:\n\n    >>> from sympy import trigsimp, cancel\n    >>> trigsimp(a)\n    (x**2 + x)/x\n    >>> cancel(_)\n    x + 1\n\n    In some cases, applying :func:`simplify` may actually result in some more\n    complicated expression. The default ``ratio=1.7`` prevents more extreme\n    cases: if (result length)/(input length) > ratio, then input is returned\n    unmodified.  The ``measure`` parameter lets you specify the function used\n    to determine how complex an expression is.  The function should take a\n    single argument as an expression and return a number such that if\n    expression ``a`` is more complex than expression ``b``, then\n    ``measure(a) > measure(b)``.  The default measure function is\n    :func:`count_ops`, which returns the total number of operations in the\n    expression.\n\n    For example, if ``ratio=1``, ``simplify`` output can't be longer\n    than input.\n\n    ::\n\n        >>> from sympy import sqrt, simplify, count_ops, oo\n        >>> root = 1/(sqrt(2)+3)\n\n    Since ``simplify(root)`` would result in a slightly longer expression,\n    root is returned unchanged instead::\n\n       >>> simplify(root, ratio=1) == root\n       True\n\n    If ``ratio=oo``, simplify will be applied anyway::\n\n        >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n        True\n\n    Note that the shortest expression is not necessary the simplest, so\n    setting ``ratio`` to 1 may not be a good idea.\n    Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n    choice.\n\n    You can easily define your own measure function based on what you feel\n    should represent the \"size\" or \"complexity\" of the input expression.  Note\n    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n    good metrics, but have other problems (in this case, the measure function\n    may slow down simplify too much for very large expressions).  If you don't\n    know what a good metric would be, the default, ``count_ops``, is a good\n    one.\n\n    For example:\n\n    >>> from sympy import symbols, log\n    >>> a, b = symbols('a b', positive=True)\n    >>> g = log(a) + log(b) + log(a)*log(1/b)\n    >>> h = simplify(g)\n    >>> h\n    log(a*b**(-log(a) + 1))\n    >>> count_ops(g)\n    8\n    >>> count_ops(h)\n    5\n\n    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n    However, we may not like how ``simplify`` (in this case, using\n    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n    to reduce this would be to give more weight to powers as operations in\n    ``count_ops``.  We can do this by using the ``visual=True`` option:\n\n    >>> print(count_ops(g, visual=True))\n    2*ADD + DIV + 4*LOG + MUL\n    >>> print(count_ops(h, visual=True))\n    2*LOG + MUL + POW + SUB\n\n    >>> from sympy import Symbol, S\n    >>> def my_measure(expr):\n    ...     POW = Symbol('POW')\n    ...     # Discourage powers by giving POW a weight of 10\n    ...     count = count_ops(expr, visual=True).subs(POW, 10)\n    ...     # Every other operation gets a weight of 1 (the default)\n    ...     count = count.replace(Symbol, type(S.One))\n    ...     return count\n    >>> my_measure(g)\n    8\n    >>> my_measure(h)\n    14\n    >>> 15./8 > 1.7 # 1.7 is the default ratio\n    True\n    >>> simplify(g, measure=my_measure)\n    -log(a)*log(b) + log(a) + log(b)\n\n    Note that because ``simplify()`` internally tries many different\n    simplification strategies and then compares them using the measure\n    function, we get a completely different result that is still different\n    from the input expression by doing this.\n\n    If rational=True, Floats will be recast as Rationals before simplification.\n    If rational=None, Floats will be recast as Rationals but the result will\n    be recast as Floats. If rational=False(default) then nothing will be done\n    to the Floats.\n    \"\"\"\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n\n    original_expr = expr = signsimp(expr)\n\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n\n    if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n        return expr\n\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n               isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio,\n                                measure=measure, rational=rational)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n                         for x in expr.args])\n\n    # TODO: Apply different strategies, considering expression pattern:\n    # is it a purely rational function? Is there any trigonometric function?...\n    # See also https://github.com/sympy/sympy/pull/185.\n\n    def shorter(*choices):\n        '''Return the choice that has the fewest ops. In case of a tie,\n        the expression listed first is selected.'''\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    # rationalize Floats\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):  # XXX: temporary hack\n        return expr\n\n    expr = factor_terms(expr, sign=False)\n\n    # hyperexpand automatically only works on hypergeometric terms\n    expr = hyperexpand(expr)\n\n    expr = piecewise_fold(expr)\n\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n\n    if expr.has(CombinatorialFunction, gamma):\n        # expression with gamma functions or non-integer arguments is\n        # automatically passed to gammasimp\n        expr = combsimp(expr)\n\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n\n    if expr.has(Product):\n        expr = product_simplify(expr)\n\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n\n    # get rid of hollow 2-arg Mul factorization\n    hollow_mul = Transform(\n        lambda x: Mul(*x.args),\n        lambda x:\n        x.is_Mul and\n        len(x.args) == 2 and\n        x.args[0].is_Number and\n        x.args[1].is_Add and\n        x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer*n).expand()/d\n\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n/(-d))\n\n    if measure(expr) > ratio*measure(original_expr):\n        expr = original_expr\n\n    # restore floats\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n\n    return expr\n\n\ndef sum_simplify(s):\n    \"\"\"Main function for Sum simplification\"\"\"\n    from sympy.concrete.summations import Sum\n    from sympy.core.function import expand\n\n    terms = Add.make_args(expand(s))\n    s_t = [] # Sum Terms\n    o_t = [] # Other Terms\n...\n\n\n### sympy/simplify/fu.py\n...\n        args = {cos: [], sin: [], None: []}\n        for a in ordered(Mul.make_args(rv)):\n            if a.func in (cos, sin):\n                args[a.func].append(a.args[0])\n            elif (a.is_Pow and a.exp.is_Integer and a.exp > 0 and \\\n                    a.base.func in (cos, sin)):\n                # XXX this is ok but pathological expression could be handled\n                # more efficiently as in TRmorrie\n                args[a.base.func].extend([a.base.args[0]]*a.exp)\n            else:\n                args[None].append(a)\n        c = args[cos]\n        s = args[sin]\n        if not (c and s or len(c) > 1 or len(s) > 1):\n            return rv\n\n        args = args[None]\n        n = min(len(c), len(s))\n        for i in range(n):\n            a1 = s.pop()\n            a2 = c.pop()\n...\n# text refers to them being applied independently. Also, a break\n# if L starts to increase has not been implemented.\nRL2 = [\n    (TR4, TR3, TR10, TR4, TR3, TR11),\n    (TR5, TR7, TR11, TR4),\n    (CTR3, CTR1, TR9, CTR2, TR4, TR9, TR9, CTR4),\n    identity,\n    ]\n\n\ndef fu(rv, measure=lambda x: (L(x), x.count_ops())):\n    \"\"\"Attempt to simplify expression by using transformation rules given\n    in the algorithm by Fu et al.\n\n    :func:`fu` will try to minimize the objective function ``measure``.\n    By default this first minimizes the number of trig terms and then minimizes\n    the number of total operations.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.fu import fu\n    >>> from sympy import cos, sin, tan, pi, S, sqrt\n    >>> from sympy.abc import x, y, a, b\n\n    >>> fu(sin(50)**2 + cos(50)**2 + sin(pi/6))\n    3/2\n    >>> fu(sqrt(6)*cos(x) + sqrt(2)*sin(x))\n    2*sqrt(2)*sin(x + pi/3)\n\n    CTR1 example\n\n    >>> eq = sin(x)**4 - cos(y)**2 + sin(y)**2 + 2*cos(x)**2\n    >>> fu(eq)\n    cos(x)**4 - 2*cos(y)**2 + 2\n\n    CTR2 example\n\n    >>> fu(S.Half - cos(2*x)/2)\n    sin(x)**2\n\n    CTR3 example\n\n    >>> fu(sin(a)*(cos(b) - sin(b)) + cos(a)*(sin(b) + cos(b)))\n    sqrt(2)*sin(a + b + pi/4)\n\n    CTR4 example\n\n    >>> fu(sqrt(3)*cos(x)/2 + sin(x)/2)\n    sin(x + pi/3)\n\n    Example 1\n\n    >>> fu(1-sin(2*x)**2/4-sin(y)**2-cos(x)**4)\n    -cos(x)**2 + cos(y)**2\n\n    Example 2\n\n    >>> fu(cos(4*pi/9))\n    sin(pi/18)\n    >>> fu(cos(pi/9)*cos(2*pi/9)*cos(3*pi/9)*cos(4*pi/9))\n    1/16\n\n    Example 3\n\n    >>> fu(tan(7*pi/18)+tan(5*pi/18)-sqrt(3)*tan(5*pi/18)*tan(7*pi/18))\n    -sqrt(3)\n\n    Objective function example\n\n    >>> fu(sin(x)/cos(x))  # default objective function\n    tan(x)\n    >>> fu(sin(x)/cos(x), measure=lambda x: -x.count_ops()) # maximize op count\n    sin(x)/cos(x)\n\n    References\n    ==========\n    http://rfdz.ph-noe.ac.at/fileadmin/Mathematik_Uploads/ACDCA/\n    DESTIME2006/DES_contribs/Fu/simplification.pdf\n    \"\"\"\n    fRL1 = greedy(RL1, measure)\n    fRL2 = greedy(RL2, measure)\n\n    was = rv\n    rv = sympify(rv)\n    if not isinstance(rv, Expr):\n        return rv.func(*[fu(a, measure=measure) for a in rv.args])\n    rv = TR1(rv)\n    if rv.has(tan, cot):\n        rv1 = fRL1(rv)\n        if (measure(rv1) < measure(rv)):\n            rv = rv1\n        if rv.has(tan, cot):\n            rv = TR2(rv)\n    if rv.has(sin, cos):\n        rv1 = fRL2(rv)\n        rv2 = TR8(TRmorrie(rv1))\n        rv = min([was, rv, rv1, rv2], key=measure)\n    return min(TR2i(rv), rv, key=measure)\n\n\ndef process_common_addends(rv, do, key2=None, key1=True):\n    \"\"\"Apply ``do`` to addends of ``rv`` that (if key1=True) share at least\n    a common absolute value of their coefficient and the value of ``key2`` when\n    applied to the argument. If ``key1`` is False ``key2`` must be supplied and\n    will be the only key applied.\n    \"\"\"\n\n    # collect by absolute value of coefficient and key2\n...\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}], "prev_content": [["from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])", "from __future__ import print_function, division\n\nfrom collections import defaultdict\n\nfrom sympy.core.cache import cacheit\nfrom sympy.core import (sympify, Basic, S, Expr, expand_mul, factor_terms,\n    Mul, Dummy, igcd, FunctionClass, Add, symbols, Wild, expand)\nfrom sympy.core.compatibility import reduce, iterable\nfrom sympy.core.numbers import I, Integer\nfrom sympy.core.function import count_ops, _mexpand\nfrom sympy.functions.elementary.trigonometric import TrigonometricFunction\nfrom sympy.functions.elementary.hyperbolic import HyperbolicFunction\nfrom sympy.functions import sin, cos, exp, cosh, tanh, sinh, tan, cot, coth\n\nfrom sympy.strategies.core import identity\nfrom sympy.strategies.tree import greedy\n\nfrom sympy.polys import Poly\nfrom sympy.polys.polyerrors import PolificationFailed\nfrom sympy.polys.polytools import groebner\nfrom sympy.polys.domains import ZZ\nfrom sympy.polys import factor, cancel, parallel_poly_from_expr\n\nfrom sympy.utilities.misc import debug\n\n\n\ndef trigsimp_groebner(expr, hints=[], quick=False, order=\"grlex\",\n                      polynomial=False):\n    \"\"\"\n    Simplify trigonometric expressions using a groebner basis algorithm.\n\n    This routine takes a fraction involving trigonometric or hyperbolic\n    expressions, and tries to simplify it. The primary metric is the\n    total degree. Some attempts are made to choose the simplest possible\n    expression of the minimal degree, but this is non-rigorous, and also\n    very slow (see the ``quick=True`` option).\n\n    If ``polynomial`` is set to True, instead of simplifying numerator and\n    denominator together, this function just brings numerator and denominator\n    into a canonical form. This is much faster, but has potentially worse\n    results. However, if the input is a polynomial, then the result is\n    guaranteed to be an equivalent polynomial of minimal degree.\n\n    The most important option is hints. Its entries can be any of the\n    following:\n\n    - a natural number\n    - a function\n    - an iterable of the form (func, var1, var2, ...)\n    - anything else, interpreted as a generator\n\n    A number is used to indicate that the search space should be increased.\n    A function is used to indicate that said function is likely to occur in a\n    simplified expression.\n    An iterable is used indicate that func(var1 + var2 + ...) is likely to\n    occur in a simplified .\n    An additional generator also indicates that it is likely to occur.\n    (See examples below).\n\n    This routine carries out various computationally intensive algorithms.\n    The option ``quick=True`` can be used to suppress one particularly slow\n    step (at the expense of potentially more complicated results, but never at\n    the expense of increased total degree).\n\n    Examples\n    ========\n\n    >>> from sympy.abc import x, y\n    >>> from sympy import sin, tan, cos, sinh, cosh, tanh\n    >>> from sympy.simplify.trigsimp import trigsimp_groebner\n\n    Suppose you want to simplify ``sin(x)*cos(x)``. Naively, nothing happens:\n\n    >>> ex = sin(x)*cos(x)\n    >>> trigsimp_groebner(ex)\n    sin(x)*cos(x)\n\n    This is because ``trigsimp_groebner`` only looks for a simplification\n    involving just ``sin(x)`` and ``cos(x)``. You can tell it to also try\n    ``2*x`` by passing ``hints=[2]``:\n\n    >>> trigsimp_groebner(ex, hints=[2])\n    sin(2*x)/2\n    >>> trigsimp_groebner(sin(x)**2 - cos(x)**2, hints=[2])\n    -cos(2*x)\n\n    Increasing the search space this way can quickly become expensive. A much\n    faster way is to give a specific expression that is likely to occur:\n\n    >>> trigsimp_groebner(ex, hints=[sin(2*x)])\n    sin(2*x)/2\n\n    Hyperbolic expressions are similarly supported:\n\n    >>> trigsimp_groebner(sinh(2*x)/sinh(x))\n    2*cosh(x)\n\n    Note how no hints had to be passed, since the expression already involved\n    ``2*x``.\n\n    The tangent function is also supported. You can either pass ``tan`` in the\n    hints, to indicate that than should be tried whenever cosine or sine are,\n    or you can pass a specific generator:\n\n    >>> trigsimp_groebner(sin(x)/cos(x), hints=[tan])\n    tan(x)\n    >>> trigsimp_groebner(sinh(x)/cosh(x), hints=[tanh(x)])\n    tanh(x)\n\n    Finally, you can use the iterable form to suggest that angle sum formulae\n    should be tried:\n\n    >>> ex = (tan(x) + tan(y))/(1 - tan(x)*tan(y))\n    >>> trigsimp_groebner(ex, hints=[(tan, x, y)])\n    tan(x + y)\n    \"\"\"\n    # TODO\n    #  - preprocess by replacing everything by funcs we can handle\n    # - optionally use cot instead of tan\n    # - more intelligent hinting.\n    #     For example, if the ideal is small, and we have sin(x), sin(y),\n    #     add sin(x + y) automatically... ?\n    # - algebraic numbers ...\n    # - expressions of lowest degree are not distinguished properly\n    #   e.g. 1 - sin(x)**2\n    # - we could try to order the generators intelligently, so as to influence\n    #   which monomials appear in the quotient basis\n\n    # THEORY\n    # ------\n    # Ratsimpmodprime above can be used to \"simplify\" a rational function\n    # modulo a prime ideal. \"Simplify\" mainly means finding an equivalent\n    # expression of lower total degree.\n    #\n    # We intend to use this to simplify trigonometric functions. To do that,\n    # we need to decide (a) which ring to use, and (b) modulo which ideal to\n    # simplify. In practice, (a) means settling on a list of \"generators\"\n    # a, b, c, ..., such that the fraction we want to simplify is a rational\n    # function in a, b, c, ..., with coefficients in ZZ (integers).\n    # (2) means that we have to decide what relations to impose on the\n    # generators. There are two practical problems:\n    #   (1) The ideal has to be *prime* (a technical term).\n    #   (2) The relations have to be polynomials in the generators.\n    #\n    # We typically have two kinds of generators:\n    # - trigonometric expressions, like sin(x), cos(5*x), etc\n    # - \"everything else\", like gamma(x), pi, etc.\n    #\n    # Since this function is trigsimp, we will concentrate on what to do with\n    # trigonometric expressions. We can also simplify hyperbolic expressions,\n    # but the extensions should be clear.\n    #\n    # One crucial point is that all *other* generators really should behave\n    # like indeterminates. In particular if (say) \"I\" is one of them, then\n    # in fact I**2 + 1 = 0 and we may and will compute non-sensical\n    # expressions. However, we can work with a dummy and add the relation\n    # I**2 + 1 = 0 to our ideal, then substitute back in the end.\n    #\n    # Now regarding trigonometric generators. We split them into groups,\n    # according to the argument of the trigonometric functions. We want to\n    # organise this in such a way that most trigonometric identities apply in\n    # the same group. For example, given sin(x), cos(2*x) and cos(y), we would\n    # group as [sin(x), cos(2*x)] and [cos(y)].\n    #\n    # Our prime ideal will be built in three steps:\n    # (1) For each group, compute a \"geometrically prime\" ideal of relations.\n    #     Geometrically prime means that it generates a prime ideal in\n    #     CC[gens], not just ZZ[gens].\n    # (2) Take the union of all the generators of the ideals for all groups.\n    #     By the geometric primality condition, this is still prime.\n    # (3) Add further inter-group relations which preserve primality.\n    #\n    # Step (1) works as follows. We will isolate common factors in the\n    # argument, so that all our generators are of the form sin(n*x), cos(n*x)\n    # or tan(n*x), with n an integer. Suppose first there are no tan terms.\n    # The ideal [sin(x)**2 + cos(x)**2 - 1] is geometrically prime, since\n    # X**2 + Y**2 - 1 is irreducible over CC.\n    # Now, if we have a generator sin(n*x), than we can, using trig identities,\n    # express sin(n*x) as a polynomial in sin(x) and cos(x). We can add this\n    # relation to the ideal, preserving geometric primality, since the quotient\n    # ring is unchanged.\n    # Thus we have treated all sin and cos terms.\n    # For tan(n*x), we add a relation tan(n*x)*cos(n*x) - sin(n*x) = 0.\n    # (This requires of course that we already have relations for cos(n*x) and\n    # sin(n*x).) It is not obvious, but it seems that this preserves geometric\n    # primality.\n    # XXX A real proof would be nice. HELP!\n    #     Sketch that <S**2 + C**2 - 1, C*T - S> is a prime ideal of\n    #     CC[S, C, T]:\n    #     - it suffices to show that the projective closure in CP**3 is\n    #       irreducible\n    #     - using the half-angle substitutions, we can express sin(x), tan(x),\n    #       cos(x) as rational functions in tan(x/2)\n    #     - from this, we get a rational map from CP**1 to our curve\n    #     - this is a morphism, hence the curve is prime\n    #\n    # Step (2) is trivial.\n    #\n    # Step (3) works by adding selected relations of the form\n    # sin(x + y) - sin(x)*cos(y) - sin(y)*cos(x), etc. Geometric primality is\n    # preserved by the same argument as before.\n\n    def parse_hints(hints):\n        \"\"\"Split hints into (n, funcs, iterables, gens).\"\"\"\n        n = 1\n        funcs, iterables, gens = [], [], []\n        for e in hints:\n            if isinstance(e, (int, Integer)):\n                n = e\n            elif isinstance(e, FunctionClass):\n                funcs.append(e)\n            elif iterable(e):\n                iterables.append((e[0], e[1:]))\n                # XXX sin(x+2y)?\n                # Note: we go through polys so e.g.\n                # sin(-x) -> -sin(x) -> sin(x)\n                gens.extend(parallel_poly_from_expr(\n                    [e[0](x) for x in e[1:]] + [e[0](Add(*e[1:]))])[1].gens)\n            else:\n                gens.append(e)\n        return n, funcs, iterables, gens\n\n    def build_ideal(x, terms):\n        \"\"\"\n        Build generators for our ideal. Terms is an iterable with elements of\n        the form (fn, coeff), indicating that we have a generator fn(coeff*x).\n\n        If any of the terms is trigonometric, sin(x) and cos(x) are guaranteed\n        to appear in terms. Similarly for hyperbolic functions. For tan(n*x),\n        sin(n*x) and cos(n*x) are guaranteed.\n        \"\"\"\n        gens = []\n        I = []\n        y = Dummy('y')\n        for fn, coeff in terms:\n            for c, s, t, rel in (\n                    [cos, sin, tan, cos(x)**2 + sin(x)**2 - 1],\n                    [cosh, sinh, tanh, cosh(x)**2 - sinh(x)**2 - 1]):\n                if coeff == 1 and fn in [c, s]:\n                    I.append(rel)\n                elif fn == t:\n                    I.append(t(coeff*x)*c(coeff*x) - s(coeff*x))\n                elif fn in [c, s]:\n                    cn = fn(coeff*y).expand(trig=True).subs(y, x)\n                    I.append(fn(coeff*x) - cn)\n        return list(set(I))\n\n    def analyse_gens(gens, hints):\n        \"\"\"\n        Analyse the generators ``gens``, using the hints ``hints``.\n\n        The meaning of ``hints`` is described in the main docstring.\n        Return a new list of generators, and also the ideal we should\n        work with.\n        \"\"\"\n        # First parse the hints\n        n, funcs, iterables, extragens = parse_hints(hints)\n        debug('n=%s' % n, 'funcs:', funcs, 'iterables:',\n              iterables, 'extragens:', extragens)\n\n        # We just add the extragens to gens and analyse them as before\n        gens = list(gens)\n        gens.extend(extragens)\n\n        # remove duplicates\n        funcs = list(set(funcs))\n        iterables = list(set(iterables))\n        gens = list(set(gens))\n\n        # all the functions we can do anything with\n        allfuncs = {sin, cos, tan, sinh, cosh, tanh}\n        # sin(3*x) -> ((3, x), sin)\n        trigterms = [(g.args[0].as_coeff_mul(), g.func) for g in gens\n                     if g.func in allfuncs]\n        # Our list of new generators - start with anything that we cannot\n        # work with (i.e. is not a trigonometric term)\n        freegens = [g for g in gens if g.func not in allfuncs]\n        newgens = []\n        trigdict = {}\n        for (coeff, var), fn in trigterms:\n            trigdict.setdefault(var, []).append((coeff, fn))\n        res = [] # the ideal\n\n        for key, val in trigdict.items():\n            # We have now assembeled a dictionary. Its keys are common\n            # arguments in trigonometric expressions, and values are lists of\n            # pairs (fn, coeff). x0, (fn, coeff) in trigdict means that we\n            # need to deal with fn(coeff*x0). We take the rational gcd of the\n            # coeffs, call it ``gcd``. We then use x = x0/gcd as \"base symbol\",\n            # all other arguments are integral multiples thereof.\n            # We will build an ideal which works with sin(x), cos(x).\n            # If hint tan is provided, also work with tan(x). Moreover, if\n            # n > 1, also work with sin(k*x) for k <= n, and similarly for cos\n            # (and tan if the hint is provided). Finally, any generators which\n            # the ideal does not work with but we need to accomodate (either\n            # because it was in expr or because it was provided as a hint)\n            # we also build into the ideal.\n            # This selection process is expressed in the list ``terms``.\n            # build_ideal then generates the actual relations in our ideal,\n            # from this list.\n            fns = [x[1] for x in val]\n            val = [x[0] for x in val]\n            gcd = reduce(igcd, val)\n            terms = [(fn, v/gcd) for (fn, v) in zip(fns, val)]\n            fs = set(funcs + fns)\n            for c, s, t in ([cos, sin, tan], [cosh, sinh, tanh]):\n                if any(x in fs for x in (c, s, t)):\n                    fs.add(c)\n                    fs.add(s)\n            for fn in fs:\n                for k in range(1, n + 1):\n                    terms.append((fn, k))\n            extra = []\n            for fn, v in terms:\n                if fn == tan:\n                    extra.append((sin, v))\n                    extra.append((cos, v))\n                if fn in [sin, cos] and tan in fs:\n                    extra.append((tan, v))\n                if fn == tanh:\n                    extra.append((sinh, v))\n                    extra.append((cosh, v))\n                if fn in [sinh, cosh] and tanh in fs:\n                    extra.append((tanh, v))\n            terms.extend(extra)\n            x = gcd*Mul(*key)\n            r = build_ideal(x, terms)\n            res.extend(r)\n            newgens.extend(set(fn(v*x) for fn, v in terms))\n\n        # Add generators for compound expressions from iterables\n        for fn, args in iterables:\n            if fn == tan:\n                # Tan expressions are recovered from sin and cos.\n                iterables.extend([(sin, args), (cos, args)])\n            elif fn == tanh:\n                # Tanh expressions are recovered from sihn and cosh.\n                iterables.extend([(sinh, args), (cosh, args)])\n            else:\n                dummys = symbols('d:%i' % len(args), cls=Dummy)\n                expr = fn( Add(*dummys)).expand(trig=True).subs(list(zip(dummys, args)))\n                res.append(fn(Add(*args)) - expr)\n\n        if myI in gens:\n            res.append(myI**2 + 1)\n            freegens.remove(myI)\n            newgens.append(myI)\n\n        return res, freegens, newgens\n\n    myI = Dummy('I')\n    expr = expr.subs(S.ImaginaryUnit, myI)\n    subs = [(myI, S.ImaginaryUnit)]\n\n    num, denom = cancel(expr).as_numer_denom()\n    try:\n        (pnum, pdenom), opt = parallel_poly_from_expr([num, denom])\n    except PolificationFailed:\n        return expr\n    debug('initial gens:', opt.gens)\n    ideal, freegens, gens = analyse_gens(opt.gens, hints)\n    debug('ideal:', ideal)\n    debug('new gens:', gens, \" -- len\", len(gens))\n    debug('free gens:', freegens, \" -- len\", len(gens))\n    # NOTE we force the domain to be ZZ to stop polys from injecting generators\n    #      (which is usually a sign of a bug in the way we build the ideal)\n    if not gens:\n        return expr\n    G = groebner(ideal, order=order, gens=gens, domain=ZZ)\n    debug('groebner basis:', list(G), \" -- len\", len(G))\n\n    # If our fraction is a polynomial in the free generators, simplify all\n    # coefficients separately:\n\n    from sympy.simplify.ratsimp import ratsimpmodprime\n\n    if freegens and pdenom.has_only_gens(*set(gens).intersection(pdenom.gens)):\n        num = Poly(num, gens=gens+freegens).eject(*gens)\n        res = []\n        for monom, coeff in num.terms():\n            ourgens = set(parallel_poly_from_expr([coeff, denom])[1].gens)\n            # We compute the transitive closure of all generators that can\n            # be reached from our generators through relations in the ideal.\n            changed = True\n            while changed:\n                changed = False\n                for p in ideal:\n                    p = Poly(p)\n                    if not ourgens.issuperset(p.gens) and \\\n                       not p.has_only_gens(*set(p.gens).difference(ourgens)):\n                        changed = True\n                        ourgens.update(p.exclude().gens)\n            # NOTE preserve order!\n            realgens = [x for x in gens if x in ourgens]\n            # The generators of the ideal have now been (implicitely) split\n            # into two groups: those involving ourgens and those that don't.\n            # Since we took the transitive closure above, these two groups\n            # live in subgrings generated by a *disjoint* set of variables.\n            # Any sensible groebner basis algorithm will preserve this disjoint\n            # structure (i.e. the elements of the groebner basis can be split\n            # similarly), and and the two subsets of the groebner basis then\n            # form groebner bases by themselves. (For the smaller generating\n            # sets, of course.)\n            ourG = [g.as_expr() for g in G.polys if\n                    g.has_only_gens(*ourgens.intersection(g.gens))]\n            res.append(Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                       ratsimpmodprime(coeff/denom, ourG, order=order,\n                                       gens=realgens, quick=quick, domain=ZZ,\n                                       polynomial=polynomial).subs(subs))\n        return Add(*res)\n        # NOTE The following is simpler and has less assumptions on the\n        #      groebner basis algorithm. If the above turns out to be broken,\n        #      use this.\n        return Add(*[Mul(*[a**b for a, b in zip(freegens, monom)]) * \\\n                     ratsimpmodprime(coeff/denom, list(G), order=order,\n                                     gens=gens, quick=quick, domain=ZZ)\n                     for monom, coeff in num.terms()])\n    else:\n        return ratsimpmodprime(\n            expr, list(G), order=order, gens=freegens+gens,\n            quick=quick, domain=ZZ, polynomial=polynomial).subs(subs)\n\n\n_trigs = (TrigonometricFunction, HyperbolicFunction)\n\n\ndef trigsimp(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', and 'fu'. If 'matching', simplify the\n    expression recursively by targeting common patterns. If 'groebner', apply\n    an experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring).\n\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e)\n    2\n\n    Simplification occurs wherever trigonometric functions are located.\n\n    >>> trigsimp(log(e))\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) might lead to greater\n    simplification.\n\n    The old trigsimp routine can be accessed as with method 'old'.\n\n    >>> from sympy import coth, tanh\n    >>> t = 3*tanh(x)**7 - 2/coth(x)**7\n    >>> trigsimp(t, method='old') == t\n    True\n    >>> trigsimp(t)\n    tanh(x)**7\n\n    \"\"\"\n    from sympy.simplify.fu import fu\n\n    expr = sympify(expr)\n\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n\n    trigsimpfunc = {\n        'fu': (lambda x: fu(x, **opts)),\n        'matching': (lambda x: futrig(x)),\n        'groebner': (lambda x: groebnersimp(x, **opts)),\n        'combined': (lambda x: futrig(groebnersimp(x,\n                               polynomial=True, hints=[2, tan]))),\n        'old': lambda x: trigsimp_old(x, **opts),\n                   }[method]\n\n    return trigsimpfunc(expr)\n\n\ndef exptrigsimp(expr):\n    \"\"\"\n    Simplifies exponential / trigonometric / hyperbolic functions.\n\n    Examples\n    ========\n\n    >>> from sympy import exptrigsimp, exp, cosh, sinh\n    >>> from sympy.abc import z\n\n    >>> exptrigsimp(exp(z) + exp(-z))\n    2*cosh(z)\n    >>> exptrigsimp(cosh(z) - sinh(z))\n    exp(-z)\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig, TR2i\n    from sympy.simplify.simplify import bottom_up\n\n    def exp_trig(e):\n        # select the better of e, and e rewritten in terms of exp or trig\n        # functions\n        choices = [e]\n        if e.has(*_trigs):\n            choices.append(e.rewrite(exp))\n        choices.append(e.rewrite(cos))\n        return min(*choices, key=count_ops)\n    newexpr = bottom_up(expr, exp_trig)\n\n    def f(rv):\n        if not rv.is_Mul:\n            return rv\n        rvd = rv.as_powers_dict()\n        newd = rvd.copy()\n\n        def signlog(expr, sign=1):\n            if expr is S.Exp1:\n                return sign, 1\n            elif isinstance(expr, exp):\n                return sign, expr.args[0]\n            elif sign == 1:\n                return signlog(-expr, sign=-1)\n            else:\n                return None, None\n\n        ee = rvd[S.Exp1]\n        for k in rvd:\n            if k.is_Add and len(k.args) == 2:\n                # k == c*(1 + sign*E**x)\n                c = k.args[0]\n                sign, x = signlog(k.args[1]/c)\n                if not x:\n                    continue\n                m = rvd[k]\n                newd[k] -= m\n                if ee == -x*m/2:\n                    # sinh and cosh\n                    newd[S.Exp1] -= ee\n                    ee = 0\n                    if sign == 1:\n                        newd[2*c*cosh(x/2)] += m\n                    else:\n                        newd[-2*c*sinh(x/2)] += m\n                elif newd[1 - sign*S.Exp1**x] == -m:\n                    # tanh\n                    del newd[1 - sign*S.Exp1**x]\n                    if sign == 1:\n                        newd[-c/tanh(x/2)] += m\n                    else:\n                        newd[-c*tanh(x/2)] += m\n                else:\n                    newd[1 + sign*S.Exp1**x] += m\n                    newd[c] += m\n\n        return Mul(*[k**newd[k] for k in newd])\n    newexpr = bottom_up(newexpr, f)\n\n    # sin/cos and sinh/cosh ratios to tan and tanh, respectively\n    if newexpr.has(HyperbolicFunction):\n        e, f = hyper_as_trig(newexpr)\n        newexpr = f(TR2i(e))\n    if newexpr.has(TrigonometricFunction):\n        newexpr = TR2i(newexpr)\n\n    # can we ever generate an I where there was none previously?\n    if not (newexpr.has(I) and not expr.has(I)):\n        expr = newexpr\n    return expr\n\n#-------------------- the old trigsimp routines ---------------------\n\ndef trigsimp_old(expr, **opts):\n    \"\"\"\n    reduces expression by using known trig identities\n\n    Notes\n    =====\n\n    deep:\n    - Apply trigsimp inside all objects with arguments\n\n    recursive:\n    - Use common subexpression elimination (cse()) and apply\n    trigsimp recursively (this is quite expensive if the\n    expression is large)\n\n    method:\n    - Determine the method to use. Valid choices are 'matching' (default),\n    'groebner', 'combined', 'fu' and 'futrig'. If 'matching', simplify the\n    expression recursively by pattern matching. If 'groebner', apply an\n    experimental groebner basis algorithm. In this case further options\n    are forwarded to ``trigsimp_groebner``, please refer to its docstring.\n    If 'combined', first run the groebner basis algorithm with small\n    default parameters, then run the 'matching' algorithm. 'fu' runs the\n    collection of trigonometric transformations described by Fu, et al.\n    (see the `fu` docstring) while `futrig` runs a subset of Fu-transforms\n    that mimic the behavior of `trigsimp`.\n\n    compare:\n    - show input and output from `trigsimp` and `futrig` when different,\n    but returns the `trigsimp` value.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, sin, cos, log, cosh, sinh, tan, cot\n    >>> from sympy.abc import x, y\n    >>> e = 2*sin(x)**2 + 2*cos(x)**2\n    >>> trigsimp(e, old=True)\n    2\n    >>> trigsimp(log(e), old=True)\n    log(2*sin(x)**2 + 2*cos(x)**2)\n    >>> trigsimp(log(e), deep=True, old=True)\n    log(2)\n\n    Using `method=\"groebner\"` (or `\"combined\"`) can sometimes lead to a lot\n    more simplification:\n\n    >>> e = (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, old=True)\n    (-sin(x) + 1)/cos(x) + cos(x)/(-sin(x) + 1)\n    >>> trigsimp(e, method=\"groebner\", old=True)\n    2/cos(x)\n\n    >>> trigsimp(1/cot(x)**2, compare=True, old=True)\n          futrig: tan(x)**2\n    cot(x)**(-2)\n\n    \"\"\"\n    old = expr\n    first = opts.pop('first', True)\n    if first:\n        if not expr.has(*_trigs):\n            return expr\n\n        trigsyms = set().union(*[t.free_symbols for t in expr.atoms(*_trigs)])\n        if len(trigsyms) > 1:\n            d = separatevars(expr)\n            if d.is_Mul:\n                d = separatevars(d, dict=True) or d\n            if isinstance(d, dict):\n                expr = 1\n                for k, v in d.items():\n                    # remove hollow factoring\n                    was = v\n                    v = expand_mul(v)\n                    opts['first'] = False\n                    vnew = trigsimp(v, **opts)\n                    if vnew == v:\n                        vnew = was\n                    expr *= vnew\n                old = expr\n            else:\n                if d.is_Add:\n                    for s in trigsyms:\n                        r, e = expr.as_independent(s)\n                        if r:\n                            opts['first'] = False\n                            expr = r + trigsimp(e, **opts)\n                            if not expr.is_Add:\n                                break\n                    old = expr\n\n    recursive = opts.pop('recursive', False)\n    deep = opts.pop('deep', False)\n    method = opts.pop('method', 'matching')\n\n    def groebnersimp(ex, deep, **opts):\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        if deep:\n            ex = traverse(ex)\n        return trigsimp_groebner(ex, **opts)\n\n    trigsimpfunc = {\n        'matching': (lambda x, d: _trigsimp(x, d)),\n        'groebner': (lambda x, d: groebnersimp(x, d, **opts)),\n        'combined': (lambda x, d: _trigsimp(groebnersimp(x,\n                                       d, polynomial=True, hints=[2, tan]),\n                                   d))\n                   }[method]\n\n    if recursive:\n        w, g = cse(expr)\n        g = trigsimpfunc(g[0], deep)\n\n        for sub in reversed(w):\n            g = g.subs(sub[0], sub[1])\n            g = trigsimpfunc(g, deep)\n        result = g\n    else:\n        result = trigsimpfunc(expr, deep)\n\n    if opts.get('compare', False):\n        f = futrig(old)\n        if f != result:\n            print('\\tfutrig:', f)\n\n    return result\n\n\ndef _dotrig(a, b):\n    \"\"\"Helper to tell whether ``a`` and ``b`` have the same sorts\n    of symbols in them -- no need to test hyperbolic patterns against\n    expressions that have no hyperbolics in them.\"\"\"\n    return a.func == b.func and (\n        a.has(TrigonometricFunction) and b.has(TrigonometricFunction) or\n        a.has(HyperbolicFunction) and b.has(HyperbolicFunction))\n\n\n_trigpat = None\ndef _trigpats():\n    global _trigpat\n    a, b, c = symbols('a b c', cls=Wild)\n    d = Wild('d', commutative=False)\n\n    # for the simplifications like sinh/cosh -> tanh:\n    # DO NOT REORDER THE FIRST 14 since these are assumed to be in this\n    # order in _match_div_rewrite.\n    matchers_division = (\n        (a*sin(b)**c/cos(b)**c, a*tan(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c*cos(b)**c, a*sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*sin(b)**c, a*cos(b)**c, sin(b), cos(b)),\n        (a*tan(b)**c/sin(b)**c, a/cos(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c/cos(b)**c, a/sin(b)**c, sin(b), cos(b)),\n        (a*cot(b)**c*tan(b)**c, a, sin(b), cos(b)),\n        (a*(cos(b) + 1)**c*(cos(b) - 1)**c,\n            a*(-sin(b)**2)**c, cos(b) + 1, cos(b) - 1),\n        (a*(sin(b) + 1)**c*(sin(b) - 1)**c,\n            a*(-cos(b)**2)**c, sin(b) + 1, sin(b) - 1),\n\n        (a*sinh(b)**c/cosh(b)**c, a*tanh(b)**c, S.One, S.One),\n        (a*tanh(b)**c*cosh(b)**c, a*sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*sinh(b)**c, a*cosh(b)**c, S.One, S.One),\n        (a*tanh(b)**c/sinh(b)**c, a/cosh(b)**c, S.One, S.One),\n        (a*coth(b)**c/cosh(b)**c, a/sinh(b)**c, S.One, S.One),\n        (a*coth(b)**c*tanh(b)**c, a, S.One, S.One),\n\n        (c*(tanh(a) + tanh(b))/(1 + tanh(a)*tanh(b)),\n            tanh(a + b)*c, S.One, S.One),\n    )\n\n    matchers_add = (\n        (c*sin(a)*cos(b) + c*cos(a)*sin(b) + d, sin(a + b)*c + d),\n        (c*cos(a)*cos(b) - c*sin(a)*sin(b) + d, cos(a + b)*c + d),\n        (c*sin(a)*cos(b) - c*cos(a)*sin(b) + d, sin(a - b)*c + d),\n        (c*cos(a)*cos(b) + c*sin(a)*sin(b) + d, cos(a - b)*c + d),\n        (c*sinh(a)*cosh(b) + c*sinh(b)*cosh(a) + d, sinh(a + b)*c + d),\n        (c*cosh(a)*cosh(b) + c*sinh(a)*sinh(b) + d, cosh(a + b)*c + d),\n    )\n\n    # for cos(x)**2 + sin(x)**2 -> 1\n    matchers_identity = (\n        (a*sin(b)**2, a - a*cos(b)**2),\n        (a*tan(b)**2, a*(1/cos(b))**2 - a),\n        (a*cot(b)**2, a*(1/sin(b))**2 - a),\n        (a*sin(b + c), a*(sin(b)*cos(c) + sin(c)*cos(b))),\n        (a*cos(b + c), a*(cos(b)*cos(c) - sin(b)*sin(c))),\n        (a*tan(b + c), a*((tan(b) + tan(c))/(1 - tan(b)*tan(c)))),\n\n        (a*sinh(b)**2, a*cosh(b)**2 - a),\n        (a*tanh(b)**2, a - a*(1/cosh(b))**2),\n        (a*coth(b)**2, a + a*(1/sinh(b))**2),\n        (a*sinh(b + c), a*(sinh(b)*cosh(c) + sinh(c)*cosh(b))),\n        (a*cosh(b + c), a*(cosh(b)*cosh(c) + sinh(b)*sinh(c))),\n        (a*tanh(b + c), a*((tanh(b) + tanh(c))/(1 + tanh(b)*tanh(c)))),\n\n    )\n\n    # Reduce any lingering artifacts, such as sin(x)**2 changing\n    # to 1-cos(x)**2 when sin(x)**2 was \"simpler\"\n    artifacts = (\n        (a - a*cos(b)**2 + c, a*sin(b)**2 + c, cos),\n        (a - a*(1/cos(b))**2 + c, -a*tan(b)**2 + c, cos),\n        (a - a*(1/sin(b))**2 + c, -a*cot(b)**2 + c, sin),\n\n        (a - a*cosh(b)**2 + c, -a*sinh(b)**2 + c, cosh),\n        (a - a*(1/cosh(b))**2 + c, a*tanh(b)**2 + c, cosh),\n        (a + a*(1/sinh(b))**2 + c, a*coth(b)**2 + c, sinh),\n\n        # same as above but with noncommutative prefactor\n        (a*d - a*d*cos(b)**2 + c, a*d*sin(b)**2 + c, cos),\n        (a*d - a*d*(1/cos(b))**2 + c, -a*d*tan(b)**2 + c, cos),\n        (a*d - a*d*(1/sin(b))**2 + c, -a*d*cot(b)**2 + c, sin),\n\n        (a*d - a*d*cosh(b)**2 + c, -a*d*sinh(b)**2 + c, cosh),\n        (a*d - a*d*(1/cosh(b))**2 + c, a*d*tanh(b)**2 + c, cosh),\n        (a*d + a*d*(1/sinh(b))**2 + c, a*d*coth(b)**2 + c, sinh),\n    )\n\n    _trigpat = (a, b, c, d, matchers_division, matchers_add,\n        matchers_identity, artifacts)\n    return _trigpat\n\n\ndef _replace_mul_fpowxgpow(expr, f, g, rexp, h, rexph):\n    \"\"\"Helper for _match_div_rewrite.\n\n    Replace f(b_)**c_*g(b_)**(rexp(c_)) with h(b)**rexph(c) if f(b_)\n    and g(b_) are both positive or if c_ is an integer.\n    \"\"\"\n    # assert expr.is_Mul and expr.is_commutative and f != g\n    fargs = defaultdict(int)\n    gargs = defaultdict(int)\n    args = []\n    for x in expr.args:\n        if x.is_Pow or x.func in (f, g):\n            b, e = x.as_base_exp()\n            if b.is_positive or e.is_integer:\n                if b.func == f:\n                    fargs[b.args[0]] += e\n                    continue\n                elif b.func == g:\n                    gargs[b.args[0]] += e\n                    continue\n        args.append(x)\n    common = set(fargs) & set(gargs)\n    hit = False\n    while common:\n        key = common.pop()\n        fe = fargs.pop(key)\n        ge = gargs.pop(key)\n        if fe == rexp(ge):\n            args.append(h(key)**rexph(fe))\n            hit = True\n        else:\n            fargs[key] = fe\n            gargs[key] = ge\n    if not hit:\n        return expr\n    while fargs:\n        key, e = fargs.popitem()\n        args.append(f(key)**e)\n    while gargs:\n        key, e = gargs.popitem()\n        args.append(g(key)**e)\n    return Mul(*args)\n\n\n_idn = lambda x: x\n_midn = lambda x: -x\n_one = lambda x: S.One\n\ndef _match_div_rewrite(expr, i):\n    \"\"\"helper for __trigsimp\"\"\"\n    if i == 0:\n        expr = _replace_mul_fpowxgpow(expr, sin, cos,\n            _midn, tan, _idn)\n    elif i == 1:\n        expr = _replace_mul_fpowxgpow(expr, tan, cos,\n            _idn, sin, _idn)\n    elif i == 2:\n        expr = _replace_mul_fpowxgpow(expr, cot, sin,\n            _idn, cos, _idn)\n    elif i == 3:\n        expr = _replace_mul_fpowxgpow(expr, tan, sin,\n            _midn, cos, _midn)\n    elif i == 4:\n        expr = _replace_mul_fpowxgpow(expr, cot, cos,\n            _midn, sin, _midn)\n    elif i == 5:\n        expr = _replace_mul_fpowxgpow(expr, cot, tan,\n            _idn, _one, _idn)\n    # i in (6, 7) is skipped\n    elif i == 8:\n        expr = _replace_mul_fpowxgpow(expr, sinh, cosh,\n            _midn, tanh, _idn)\n    elif i == 9:\n        expr = _replace_mul_fpowxgpow(expr, tanh, cosh,\n            _idn, sinh, _idn)\n    elif i == 10:\n        expr = _replace_mul_fpowxgpow(expr, coth, sinh,\n            _idn, cosh, _idn)\n    elif i == 11:\n        expr = _replace_mul_fpowxgpow(expr, tanh, sinh,\n            _midn, cosh, _midn)\n    elif i == 12:\n        expr = _replace_mul_fpowxgpow(expr, coth, cosh,\n            _midn, sinh, _midn)\n    elif i == 13:\n        expr = _replace_mul_fpowxgpow(expr, coth, tanh,\n            _idn, _one, _idn)\n    else:\n        return None\n    return expr\n\n\ndef _trigsimp(expr, deep=False):\n    # protect the cache from non-trig patterns; we only allow\n    # trig patterns to enter the cache\n    if expr.has(*_trigs):\n        return __trigsimp(expr, deep)\n    return expr\n\n\n@cacheit\ndef __trigsimp(expr, deep=False):\n    \"\"\"recursive helper for trigsimp\"\"\"\n    from sympy.simplify.fu import TR10i\n\n    if _trigpat is None:\n        _trigpats()\n    a, b, c, d, matchers_division, matchers_add, \\\n    matchers_identity, artifacts = _trigpat\n\n    if expr.is_Mul:\n        # do some simplifications like sin/cos -> tan:\n        if not expr.is_commutative:\n            com, nc = expr.args_cnc()\n            expr = _trigsimp(Mul._from_args(com), deep)*Mul._from_args(nc)\n        else:\n            for i, (pattern, simp, ok1, ok2) in enumerate(matchers_division):\n                if not _dotrig(expr, pattern):\n                    continue\n\n                newexpr = _match_div_rewrite(expr, i)\n                if newexpr is not None:\n                    if newexpr != expr:\n                        expr = newexpr\n                        break\n                    else:\n                        continue\n\n                # use SymPy matching instead\n                res = expr.match(pattern)\n                if res and res.get(c, 0):\n                    if not res[c].is_integer:\n                        ok = ok1.subs(res)\n                        if not ok.is_positive:\n                            continue\n                        ok = ok2.subs(res)\n                        if not ok.is_positive:\n                            continue\n                    # if \"a\" contains any of trig or hyperbolic funcs with\n                    # argument \"b\" then skip the simplification\n                    if any(w.args[0] == res[b] for w in res[a].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    # simplify and finish:\n                    expr = simp.subs(res)\n                    break  # process below\n\n    if expr.is_Add:\n        args = []\n        for term in expr.args:\n            if not term.is_commutative:\n                com, nc = term.args_cnc()\n                nc = Mul._from_args(nc)\n                term = Mul._from_args(com)\n            else:\n                nc = S.One\n            term = _trigsimp(term, deep)\n            for pattern, result in matchers_identity:\n                res = term.match(pattern)\n                if res is not None:\n                    term = result.subs(res)\n                    break\n            args.append(term*nc)\n        if args != expr.args:\n            expr = Add(*args)\n            expr = min(expr, expand(expr), key=count_ops)\n        if expr.is_Add:\n            for pattern, result in matchers_add:\n                if not _dotrig(expr, pattern):\n                    continue\n                expr = TR10i(expr)\n                if expr.has(HyperbolicFunction):\n                    res = expr.match(pattern)\n                    # if \"d\" contains any trig or hyperbolic funcs with\n                    # argument \"a\" or \"b\" then skip the simplification;\n                    # this isn't perfect -- see tests\n                    if res is None or not (a in res and b in res) or any(\n                        w.args[0] in (res[a], res[b]) for w in res[d].atoms(\n                            TrigonometricFunction, HyperbolicFunction)):\n                        continue\n                    expr = result.subs(res)\n                    break\n\n        # Reduce any lingering artifacts, such as sin(x)**2 changing\n        # to 1 - cos(x)**2 when sin(x)**2 was \"simpler\"\n        for pattern, result, ex in artifacts:\n            if not _dotrig(expr, pattern):\n                continue\n            # Substitute a new wild that excludes some function(s)\n            # to help influence a better match. This is because\n            # sometimes, for example, 'a' would match sec(x)**2\n            a_t = Wild('a', exclude=[ex])\n            pattern = pattern.subs(a, a_t)\n            result = result.subs(a, a_t)\n\n            m = expr.match(pattern)\n            was = None\n            while m and was != expr:\n                was = expr\n                if m[a_t] == 0 or \\\n                        -m[a_t] in m[c].args or m[a_t] + m[c] == 0:\n                    break\n                if d in m and m[a_t]*m[d] + m[c] == 0:\n                    break\n                expr = result.subs(m)\n                m = expr.match(pattern)\n                m.setdefault(c, S.Zero)\n\n    elif expr.is_Mul or expr.is_Pow or deep and expr.args:\n        expr = expr.func(*[_trigsimp(a, deep) for a in expr.args])\n\n    try:\n        if not expr.has(*_trigs):\n            raise TypeError\n        e = expr.atoms(exp)\n        new = expr.rewrite(exp, deep=deep)\n        if new == e:\n            raise TypeError\n        fnew = factor(new)\n        if fnew != new:\n            new = sorted([new, factor(new)], key=count_ops)[0]\n        # if all exp that were introduced disappeared then accept it\n        if not (new.atoms(exp) - e):\n            expr = new\n    except TypeError:\n        pass\n\n    return expr\n#------------------- end of old trigsimp routines --------------------\n\n\ndef futrig(e, **kwargs):\n    \"\"\"Return simplified ``e`` using Fu-like transformations.\n    This is not the \"Fu\" algorithm. This is called by default\n    from ``trigsimp``. By default, hyperbolics subexpressions\n    will be simplified, but this can be disabled by setting\n    ``hyper=False``.\n\n    Examples\n    ========\n\n    >>> from sympy import trigsimp, tan, sinh, tanh\n    >>> from sympy.simplify.trigsimp import futrig\n    >>> from sympy.abc import x\n    >>> trigsimp(1/tan(x)**2)\n    tan(x)**(-2)\n\n    >>> futrig(sinh(x)/tanh(x))\n    cosh(x)\n\n    \"\"\"\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n\n    e = sympify(e)\n\n    if not isinstance(e, Basic):\n        return e\n\n    if not e.args:\n        return e\n\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        # redistribute leading coeff on 2-arg Add\n        e = Mul(*e.as_coeff_Mul())\n    return e\n\n\ndef _futrig(e, **kwargs):\n    \"\"\"Helper for futrig.\"\"\"\n    from sympy.simplify.fu import (\n        TR1, TR2, TR3, TR2i, TR10, L, TR10i,\n        TR8, TR6, TR15, TR16, TR111, TR5, TRmorrie, TR11, TR14, TR22,\n        TR12)\n    from sympy.core.compatibility import _nodes\n\n    if not e.has(TrigonometricFunction):\n        return e\n\n    if e.is_Mul:\n        coeff, e = e.as_independent(TrigonometricFunction)\n    else:\n        coeff = S.One\n\n    Lops = lambda x: (L(x), x.count_ops(), _nodes(x), len(x.args), x.is_Add)\n    trigs = lambda x: x.has(TrigonometricFunction)\n\n    tree = [identity,\n        (\n        TR3,  # canonical angles\n        TR1,  # sec-csc -> cos-sin\n        TR12,  # expand tan of sum\n        lambda x: _eapply(factor, x, trigs),\n        TR2,  # tan-cot -> sin-cos\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TR2i,  # sin-cos ratio -> tan\n        lambda x: _eapply(lambda i: factor(i.normal()), x, trigs),\n        TR14,  # factored identities\n        TR5,  # sin-pow -> cos_pow\n        TR10,  # sin-cos of sums -> sin-cos prod\n        TR11, TR6, # reduce double angles and rewrite cos pows\n        lambda x: _eapply(factor, x, trigs),\n        TR14,  # factored powers of identities\n        [identity, lambda x: _eapply(_mexpand, x, trigs)],\n        TRmorrie,\n        TR10i,  # sin-cos products > sin-cos of sums\n        [identity, TR8],  # sin-cos products -> sin-cos of sums\n        [identity, lambda x: TR2i(TR2(x))],  # tan -> sin-cos -> tan\n        [\n            lambda x: _eapply(expand_mul, TR5(x), trigs),\n            lambda x: _eapply(\n                expand_mul, TR15(x), trigs)], # pos/neg powers of sin\n        [\n            lambda x:  _eapply(expand_mul, TR6(x), trigs),\n            lambda x:  _eapply(\n                expand_mul, TR16(x), trigs)], # pos/neg powers of cos\n        TR111,  # tan, sin, cos to neg power -> cot, csc, sec\n        [identity, TR2i],  # sin-cos ratio to tan\n        [identity, lambda x: _eapply(\n            expand_mul, TR22(x), trigs)],  # tan-cot to sec-csc\n        TR1, TR2, TR2i,\n        [identity, lambda x: _eapply(\n            factor_terms, TR12(x), trigs)],  # expand tan of sum\n        )]\n    e = greedy(tree, objective=Lops)(e)\n\n    return coeff*e\n\n\ndef _is_Expr(e):\n    \"\"\"_eapply helper to tell whether ``e`` and all its args\n    are Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return False\n    return all(_is_Expr(i) for i in e.args)\n\n\ndef _eapply(func, e, cond=None):\n    \"\"\"Apply ``func`` to ``e`` if all args are Exprs else only\n    apply it to those args that *are* Exprs.\"\"\"\n    if not isinstance(e, Expr):\n        return e\n    if _is_Expr(e) or not e.args:\n        return func(e)\n    return e.func(*[\n        _eapply(func, ei) if (cond is None or cond(ei)) else ei\n        for ei in e.args])"]], "file_names": [["sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py", "sympy/simplify/trigsimp.py"]]}
