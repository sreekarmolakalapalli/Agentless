{"instance_id": "pytest-dev__pytest-5227", "found_files": ["src/_pytest/logging.py", "src/_pytest/terminal.py", "src/_pytest/config/__init__.py", "src/_pytest/main.py"], "additional_artifact_loc_file": {"raw_output_files": "```\nsrc/_pytest/logging.py\nsrc/_pytest/terminal.py\nsrc/_pytest/config/__init__.py\nsrc/_pytest/main.py\ntesting/test_logging.py\n```"}, "file_traj": {"response": "```\nsrc/_pytest/logging.py\nsrc/_pytest/terminal.py\nsrc/_pytest/config/__init__.py\nsrc/_pytest/main.py\ntesting/test_logging.py\n```", "usage": {"completion_tokens": 37, "prompt_tokens": 1763}, "prompt": "Please look through the following GitHub problem description, and Repository structure and provide a list of files that one would need to edit to fix the problem.\n\n### GitHub Problem Description ###\nImprove default logging format\nCurrently it is:\r\n\r\n> DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n\r\nI think `name` (module name) would be very useful here, instead of just the base filename.\r\n\r\n(It might also be good to have the relative path there (maybe at the end), but it is usually still very long (but e.g. `$VIRTUAL_ENV` could be substituted therein))\r\n\r\nCurrently it would look like this:\r\n```\r\nutils.py                   114 DEBUG    (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nmultipart.py               604 DEBUG    Calling on_field_start with no data\r\n```\r\n\r\n\r\nUsing `DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"` instead:\r\n\r\n```\r\nDEBUG    django.db.backends:utils.py:114 (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nDEBUG    multipart.multipart:multipart.py:604 Calling on_field_start with no data\r\n```\n\n\n###\n\n\n\n### Repository Structure ###\npytest/\n    setup.py\nsrc/\n    pytest.py\n    _pytest/\n        outcomes.py\n        monkeypatch.py\n        _argcomplete.py\n        python.py\n        junitxml.py\n        tmpdir.py\n        pytester.py\n        capture.py\n        cacheprovider.py\n        hookspec.py\n        terminal.py\n        freeze_support.py\n        stepwise.py\n        compat.py\n        warning_types.py\n        helpconfig.py\n        nose.py\n        python_api.py\n        unittest.py\n        deprecated.py\n        fixtures.py\n        skipping.py\n        nodes.py\n        main.py\n        setupplan.py\n        recwarn.py\n        debugging.py\n        setuponly.py\n        pastebin.py\n        logging.py\n        resultlog.py\n        warnings.py\n        runner.py\n        reports.py\n        __init__.py\n        doctest.py\n        pathlib.py\n        config/\n            exceptions.py\n            findpaths.py\n            argparsing.py\n            __init__.py\n        mark/\n            evaluate.py\n            legacy.py\n            structures.py\n            __init__.py\n        _io/\n            saferepr.py\n            __init__.py\n        assertion/\n            rewrite.py\n            truncate.py\n            util.py\n            __init__.py\n        _code/\n            code.py\n            source.py\n            _py2traceback.py\n            __init__.py\nbench/\n    manyparam.py\n    bench.py\n    skip.py\n    bench_argcomplete.py\n    empty.py\nextra/\n    get_issues.py\ndoc/\n    en/\n        conf.py\n        conftest.py\n        _themes/\n            flask_theme_support.py\n        example/\n            xfail_demo.py\n            conftest.py\n            pythoncollection.py\n            multipython.py\n            assertion/\n                test_failures.py\n                test_setup_flow_example.py\n                failure_demo.py\n                global_testmodule_config/\n                    conftest.py\n                    test_hello_world.py\n            costlysetup/\n                conftest.py\n                sub_a/\n                    test_quick.py\n                    __init__.py\n                sub_b/\n                    test_two.py\n                    __init__.py\n            nonpython/\n                conftest.py\n                __init__.py\n            py2py3/\n                conftest.py\n                test_py2.py\n                test_py3.py\ntesting/\n    test_warnings.py\n    test_reports.py\n    test_skipping.py\n    test_cacheprovider.py\n    deprecated_test.py\n    test_helpconfig.py\n    test_argcomplete.py\n    test_capture.py\n    acceptance_test.py\n    test_runner_xunit.py\n    test_modimport.py\n    test_config.py\n    test_runner.py\n    conftest.py\n    test_assertrewrite.py\n    test_collection.py\n    test_monkeypatch.py\n    test_pytester.py\n    test_pastebin.py\n    test_tmpdir.py\n    test_nose.py\n    test_pdb.py\n    test_session.py\n    test_assertion.py\n    test_stepwise.py\n    test_resultlog.py\n    test_entry_points.py\n    test_pluginmanager.py\n    test_parseopt.py\n    test_pathlib.py\n    test_terminal.py\n    test_mark.py\n    test_conftest.py\n    test_recwarn.py\n    test_compat.py\n    test_unittest.py\n    test_nodes.py\n    test_doctest.py\n    test_junitxml.py\n    code/\n        test_code.py\n        test_excinfo.py\n        test_source.py\n    io/\n        test_saferepr.py\n    freeze/\n        runtests_script.py\n        tox_run.py\n        create_executable.py\n        tests/\n            test_trivial.py\n    example_scripts/\n        issue_519.py\n        config/\n            collect_pytest_prefix/\n                conftest.py\n                test_foo.py\n        marks/\n            marks_considered_keywords/\n                conftest.py\n                test_marks_as_keywords.py\n        collect/\n            package_infinite_recursion/\n                conftest.py\n                tests/\n                    test_basic.py\n                    __init__.py\n            package_init_given_as_arg/\n                pkg/\n                    test_foo.py\n                    __init__.py\n            collect_init_tests/\n                tests/\n                    test_foo.py\n                    __init__.py\n        warnings/\n            test_group_warnings_by_message.py\n        deprecated/\n            test_fixture_named_request.py\n        conftest_usageerror/\n            conftest.py\n        unittest/\n            test_setup_skip_module.py\n            test_setup_skip.py\n            test_parametrized_fixture_error_message.py\n            test_setup_skip_class.py\n        tmpdir/\n            tmpdir_fixture.py\n        perf_examples/\n            collect_stats/\n                generate_folders.py\n                template_test.py\n        acceptance/\n            fixture_mock_integration.py\n        dataclasses/\n            test_compare_dataclasses.py\n            test_compare_dataclasses_verbose.py\n            test_compare_two_different_dataclasses.py\n            test_compare_dataclasses_field_comparison_off.py\n        issue88_initial_file_multinodes/\n            conftest.py\n            test_hello.py\n        fixtures/\n            test_getfixturevalue_dynamic.py\n            custom_item/\n                conftest.py\n                foo/\n                    test_foo.py\n                    __init__.py\n            fill_fixtures/\n                test_detect_recursive_dependency_error.py\n                test_funcarg_lookupfails.py\n                test_funcarg_lookup_modulelevel.py\n                test_funcarg_lookup_classlevel.py\n                test_extend_fixture_module_class.py\n                test_funcarg_basic.py\n                test_conftest_funcargs_only_available_in_subdir/\n                    sub2/\n                        conftest.py\n                        test_in_sub2.py\n                        __init__.py\n                    sub1/\n                        conftest.py\n                        test_in_sub1.py\n                        __init__.py\n                test_extend_fixture_conftest_module/\n                    conftest.py\n                    test_extend_fixture_conftest_module.py\n                test_extend_fixture_conftest_conftest/\n                    conftest.py\n                    pkg/\n                        test_spam.py\n                        conftest.py\n                        __init__.py\n    python/\n        integration.py\n        setup_plan.py\n        metafunc.py\n        collect.py\n        fixtures.py\n        setup_only.py\n        raises.py\n        approx.py\n        show_fixtures_per_test.py\n    examples/\n        test_issue519.py\n    logging/\n        test_formatter.py\n        test_reporting.py\n        test_fixture.py\nscripts/\n    release.py\n\n###\n\nPlease only provide the full path and return at most 5 files.\nThe returned files should be separated by new lines ordered by most to least important and wrapped with ```\nFor example:\n```\nfile1.py\nfile2.py\n```"}, "found_related_locs": [["variable: DEFAULT_LOG_FORMAT\nclass: ColoredLevelFormatter\nclass: LogCaptureHandler\nclass: LogCaptureFixture\nclass: LoggingPlugin\nclass: _LiveLoggingStreamHandler"], ["class: TerminalReporter"], ["class: Config"]], "additional_artifact_loc_related": [{"raw_output_loc": "```\nsrc/_pytest/logging.py\nvariable: DEFAULT_LOG_FORMAT\nclass: ColoredLevelFormatter\nclass: LogCaptureHandler\nclass: LogCaptureFixture\nclass: LoggingPlugin\nclass: _LiveLoggingStreamHandler\n\nsrc/_pytest/terminal.py\nclass: TerminalReporter\n\nsrc/_pytest/config/__init__.py\nclass: Config\n```"}], "related_loc_traj": {"response": "```\nsrc/_pytest/logging.py\nvariable: DEFAULT_LOG_FORMAT\nclass: ColoredLevelFormatter\nclass: LogCaptureHandler\nclass: LogCaptureFixture\nclass: LoggingPlugin\nclass: _LiveLoggingStreamHandler\n\nsrc/_pytest/terminal.py\nclass: TerminalReporter\n\nsrc/_pytest/config/__init__.py\nclass: Config\n```", "usage": {"completion_tokens": 72, "prompt_tokens": 3147}, "prompt": "\nPlease look through the following GitHub Problem Description, and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nImprove default logging format\nCurrently it is:\r\n\r\n> DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n\r\nI think `name` (module name) would be very useful here, instead of just the base filename.\r\n\r\n(It might also be good to have the relative path there (maybe at the end), but it is usually still very long (but e.g. `$VIRTUAL_ENV` could be substituted therein))\r\n\r\nCurrently it would look like this:\r\n```\r\nutils.py                   114 DEBUG    (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nmultipart.py               604 DEBUG    Calling on_field_start with no data\r\n```\r\n\r\n\r\nUsing `DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"` instead:\r\n\r\n```\r\nDEBUG    django.db.backends:utils.py:114 (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nDEBUG    multipart.multipart:multipart.py:604 Calling on_field_start with no data\r\n```\n\n\n###\n\n\n\n### Skeleton of Relevant Files ###\n\n### File: src/_pytest/logging.py ###\n```python\n\nDEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\nDEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n\n\nclass ColoredLevelFormatter(logging.Formatter):\n\n    LOGLEVEL_COLOROPTS = {\n        logging.CRITICAL: {\"red\"},\n        logging.ERROR: {\"red\", \"bold\"},\n        logging.WARNING: {\"yellow\"},\n        logging.WARN: {\"yellow\"},\n        logging.INFO: {\"green\"},\n        logging.DEBUG: {\"purple\"},\n        logging.NOTSET: set(),\n    }\n    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n\n    def __init__(self, terminalwriter, *args, **kwargs):\n...\n    def format(self, record):\n...\n\ndef get_option_ini(config, *names):\n...\n\ndef pytest_addoption(parser):\n...\n\n@contextmanager\ndef catching_logs(handler, formatter=None, level=None):\n...\n\nclass LogCaptureHandler(logging.StreamHandler):\n\n    def __init__(self):\n...\n    def emit(self, record):\n...\n    def reset(self):\n...\n\nclass LogCaptureFixture(object):\n\n    def __init__(self, item):\n...\n    def _finalize(self):\n...\n    @property\n    def handler(self):\n...\n    def get_records(self, when):\n...\n    @property\n    def text(self):\n...\n    @property\n    def records(self):\n...\n    @property\n    def record_tuples(self):\n...\n    @property\n    def messages(self):\n...\n    def clear(self):\n...\n    def set_level(self, level, logger=None):\n...\n    @contextmanager\n    def at_level(self, level, logger=None):\n...\n\n@pytest.fixture\ndef caplog(request):\n...\n\ndef get_actual_log_level(config, *setting_names):\n...\n\n# run after terminalreporter/capturemanager are configured\n@pytest.hookimpl(trylast=True)\ndef pytest_configure(config):\n...\n\nclass LoggingPlugin(object):\n\n    def __init__(self, config):\n...\n    def _setup_cli_logging(self):\n...\n    def set_log_path(self, fname):\n...\n    def _log_cli_enabled(self):\n...\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_collection(self):\n...\n    @contextmanager\n    def _runtest_for(self, item, when):\n...\n    @contextmanager\n    def _runtest_for_main(self, item, when):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_setup(self, item):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_call(self, item):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_teardown(self, item):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logstart(self):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logfinish(self):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtest_logreport(self):\n...\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionfinish(self):\n...\n    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n    def pytest_sessionstart(self):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_runtestloop(self, session):\n...\n\nclass _LiveLoggingStreamHandler(logging.StreamHandler):\n\n    def __init__(self, terminal_reporter, capture_manager):\n...\n    def reset(self):\n...\n    def set_when(self, when):\n...\n    def emit(self, record):\n\n```\n\n### File: src/_pytest/terminal.py ###\n```python\n\nREPORT_COLLECTING_RESOLUTION = 0.5\n\n\nclass MoreQuietAction(argparse.Action):\n\n    def __init__(self, option_strings, dest, default=None, required=False, help=None):\n...\n    def __call__(self, parser, namespace, values, option_string=None):\n...\n\ndef pytest_addoption(parser):\n...\n\ndef pytest_configure(config):\n...\n\ndef getreportopt(config):\n...\n\n@pytest.hookimpl(trylast=True)  # after _pytest.runner\ndef pytest_report_teststatus(report):\n...\n\n@attr.s\nclass WarningReport(object):\n\n    message = attr.ib()\n    nodeid = attr.ib(default=None)\n    fslocation = attr.ib(default=None)\n    count_towards_summary = True\n\n    def get_location(self, config):\n...\n\nclass TerminalReporter(object):\n    def __init__(self, config, file=None):\n...\n    def _determine_show_progress_info(self):\n...\n    @property\n    def verbosity(self):\n...\n    @property\n    def showheader(self):\n...\n    @property\n    def showfspath(self):\n...\n    @showfspath.setter\n    def showfspath(self, value):\n...\n    @property\n    def showlongtestinfo(self):\n...\n    def hasopt(self, char):\n...\n    def write_fspath_result(self, nodeid, res, **markup):\n...\n    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n...\n    def ensure_newline(self):\n...\n    def write(self, content, **markup):\n...\n    def write_line(self, line, **markup):\n...\n    def rewrite(self, line, **markup):\n...\n    def write_sep(self, sep, title=None, **markup):\n...\n    def section(self, title, sep=\"=\", **kw):\n...\n    def line(self, msg, **kw):\n...\n    def pytest_internalerror(self, excrepr):\n...\n    def pytest_warning_captured(self, warning_message, item):\n...\n    def pytest_plugin_registered(self, plugin):\n...\n    def pytest_deselected(self, items):\n...\n    def pytest_runtest_logstart(self, nodeid, location):\n...\n    def pytest_runtest_logreport(self, report):\n...\n    def pytest_runtest_logfinish(self, nodeid):\n...\n    def _get_progress_information_message(self):\n...\n    def _write_progress_information_filling_space(self):\n...\n    @property\n    def _width_of_current_line(self):\n...\n    def pytest_collection(self):\n...\n    def pytest_collectreport(self, report):\n...\n    def report_collect(self, final=False):\n...\n    @pytest.hookimpl(trylast=True)\n    def pytest_sessionstart(self, session):\n...\n    def _write_report_lines_from_hooks(self, lines):\n...\n    def pytest_report_header(self, config):\n...\n    def pytest_collection_finish(self, session):\n...\n    def _printcollecteditems(self, items):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_sessionfinish(self, exitstatus):\n...\n    @pytest.hookimpl(hookwrapper=True)\n    def pytest_terminal_summary(self):\n...\n    def pytest_keyboard_interrupt(self, excinfo):\n...\n    def pytest_unconfigure(self):\n...\n    def _report_keyboardinterrupt(self):\n...\n    def _locationline(self, nodeid, fspath, lineno, domain):\n...\n    def _getfailureheadline(self, rep):\n...\n    def _getcrashline(self, rep):\n...\n    #\n    # summaries for sessionfinish\n    #\n    def getreports(self, name):\n...\n    def summary_warnings(self):\n...\n    def summary_passes(self):\n...\n    def print_teardown_sections(self, rep):\n...\n    def summary_failures(self):\n...\n    def summary_errors(self):\n...\n    def _outrep_summary(self, rep):\n...\n    def summary_stats(self):\n...\n    def short_test_summary(self):\n...\n\ndef _folded_skips(skipped):\n...\n\ndef build_summary_stats_line(stats):\n...\n\ndef _plugin_nameversions(plugininfo):\n\n```\n\n### File: src/_pytest/config/__init__.py ###\n```python\n\nhookimpl = HookimplMarker(\"pytest\")\nhookspec = HookspecMarker(\"pytest\")\n\n\nclass ConftestImportFailure(Exception):\n    def __init__(self, path, excinfo):\n...\n\ndef main(args=None, plugins=None):\n...\n\nclass cmdline(object):\n    main = staticmethod(main)\n\n\ndef filename_arg(path, optname):\n...\n\ndef directory_arg(path, optname):\n...\n\n# Plugins that cannot be disabled via \"-p no:X\" currently.\nessential_plugins = (\n    \"mark\",\n    \"main\",\n    \"runner\",\n    \"python\",\n    \"fixtures\",\n    \"helpconfig\",  # Provides -p.\n)\n\ndefault_plugins = essential_plugins + (\n    \"terminal\",\n    \"debugging\",\n    \"unittest\",\n    \"capture\",\n    \"skipping\",\n    \"tmpdir\",\n    \"monkeypatch\",\n    \"recwarn\",\n    \"pastebin\",\n    \"nose\",\n    \"assertion\",\n    \"junitxml\",\n    \"resultlog\",\n    \"doctest\",\n    \"cacheprovider\",\n    \"freeze_support\",\n    \"setuponly\",\n    \"setupplan\",\n    \"stepwise\",\n    \"warnings\",\n    \"logging\",\n    \"reports\",\n)\n\nbuiltin_plugins = set(default_plugins)\n\n\ndef get_config(args=None):\n...\n\ndef get_plugin_manager():\n...\n\ndef _prepareconfig(args=None, plugins=None):\n...\n\nclass PytestPluginManager(PluginManager):\n\n    def __init__(self):\n...\n    def addhooks(self, module_or_class):\n...\n    def parse_hookimpl_opts(self, plugin, name):\n...\n    def parse_hookspec_opts(self, module_or_class, name):\n...\n    def register(self, plugin, name=None):\n...\n    def getplugin(self, name):\n...\n    def hasplugin(self, name):\n...\n    def pytest_configure(self, config):\n...\n    #\n    # internal API for local conftest plugin handling\n    #\n    def _set_initial_conftests(self, namespace):\n...\n    def _try_load_conftest(self, anchor):\n...\n    @lru_cache(maxsize=128)\n    def _getconftestmodules(self, path):\n...\n    def _rget_with_confmod(self, name, path):\n...\n    def _importconftest(self, conftestpath):\n...\n    #\n    # API for bootstrapping plugin loading\n    #\n    #\n\n    def consider_preparse(self, args):\n...\n    def consider_pluginarg(self, arg):\n...\n    def consider_conftest(self, conftestmodule):\n...\n    def consider_env(self):\n...\n    def consider_module(self, mod):\n...\n    def _import_plugin_specs(self, spec):\n...\n    def import_plugin(self, modname, consider_entry_points=False):\n...\n\ndef _get_plugin_specs_as_list(specs):\n...\n\ndef _ensure_removed_sysmodule(modname):\n...\n\nclass Notset(object):\n    def __repr__(self):\n...\n\nnotset = Notset()\n\n\ndef _iter_rewritable_modules(package_files):\n...\n\nclass Config(object):\n\n    def __init__(self, pluginmanager):\n...\n    def add_cleanup(self, func):\n...\n    def _do_configure(self):\n...\n    def _ensure_unconfigure(self):\n...\n    def get_terminal_writer(self):\n...\n    def pytest_cmdline_parse(self, pluginmanager, args):\n...\n    def notify_exception(self, excinfo, option=None):\n...\n    def cwd_relative_nodeid(self, nodeid):\n...\n    @classmethod\n    def fromdictargs(cls, option_dict, args):\n...\n    def _processopt(self, opt):\n...\n    @hookimpl(trylast=True)\n    def pytest_load_initial_conftests(self, early_config):\n...\n    def _initini(self, args):\n...\n    def _consider_importhook(self, args):\n...\n    def _mark_plugins_for_rewrite(self, hook):\n...\n    def _validate_args(self, args, via):\n...\n    def _preparse(self, args, addopts=True):\n...\n    def _checkversion(self):\n...\n    def parse(self, args, addopts=True):\n...\n    def addinivalue_line(self, name, line):\n...\n    def getini(self, name):\n...\n    def _getini(self, name):\n...\n    def _getconftest_pathlist(self, name, path):\n...\n    def _get_override_ini_value(self, name):\n...\n    def getoption(self, name, default=notset, skip=False):\n...\n    def getvalue(self, name, path=None):\n...\n    def getvalueorskip(self, name, path=None):\n...\n\ndef _assertion_supported():\n...\n\ndef _warn_about_missing_assertion(mode):\n...\n\ndef setns(obj, dic):\n...\n\ndef create_terminal_writer(config, *args, **kwargs):\n...\n\ndef _strtobool(val):\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations.\n"}, "found_edit_locs": [[["line: 18\nfunction: LoggingPlugin.__init__\nline: 395\nfunction: LoggingPlugin._setup_cli_logging\nline: 440"], [""], [""]], [["line: 18"], ["function: TerminalReporter._locationline\nline: 711"], [""]], [["line: 18\nfunction: LoggingPlugin.__init__\nline: 395\nfunction: LoggingPlugin._setup_cli_logging\nline: 440"], [""], [""]], [["line: 18"], [""], [""]]], "additional_artifact_loc_edit_location": [{"raw_output_loc": ["```\nsrc/_pytest/logging.py\nline: 18\n\nsrc/_pytest/logging.py\nfunction: LoggingPlugin.__init__\nline: 395\n\nsrc/_pytest/logging.py\nfunction: LoggingPlugin._setup_cli_logging\nline: 440\n```", "```\nsrc/_pytest/logging.py\nline: 18\n\nsrc/_pytest/terminal.py\nfunction: TerminalReporter._locationline\nline: 711\n```", "```\nsrc/_pytest/logging.py\nline: 18\n\nsrc/_pytest/logging.py\nfunction: LoggingPlugin.__init__\nline: 395\n\nsrc/_pytest/logging.py\nfunction: LoggingPlugin._setup_cli_logging\nline: 440\n```", "```\nsrc/_pytest/logging.py\nline: 18\n```"]}], "edit_loc_traj": {"prompt": "\nPlease review the following GitHub problem description, and relevant files, and provide a set of locations that need to be edited to fix the issue.\nThe locations can be specified as class names, function or method names, or exact line numbers that require modification.\n\n### GitHub Problem Description ###\nImprove default logging format\nCurrently it is:\r\n\r\n> DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\r\n\r\nI think `name` (module name) would be very useful here, instead of just the base filename.\r\n\r\n(It might also be good to have the relative path there (maybe at the end), but it is usually still very long (but e.g. `$VIRTUAL_ENV` could be substituted therein))\r\n\r\nCurrently it would look like this:\r\n```\r\nutils.py                   114 DEBUG    (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nmultipart.py               604 DEBUG    Calling on_field_start with no data\r\n```\r\n\r\n\r\nUsing `DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"` instead:\r\n\r\n```\r\nDEBUG    django.db.backends:utils.py:114 (0.000) SELECT \"app_url\".\"id\", \"app_url\".\"created\", \"app_url\".\"url\" FROM \"app_url\" WHERE \"app_url\".\"id\" = 2; args=(2,)\r\nDEBUG    multipart.multipart:multipart.py:604 Calling on_field_start with no data\r\n```\n\n\n###\n\n\n\n### src/_pytest/logging.py\n...\n8|from contextlib import contextmanager\n9|\n10|import py\n11|import six\n12|\n13|import pytest\n14|from _pytest.compat import dummy_context_manager\n15|from _pytest.config import create_terminal_writer\n16|from _pytest.pathlib import Path\n17|\n18|DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n19|DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n20|\n21|\n22|class ColoredLevelFormatter(logging.Formatter):\n23|    \"\"\"\n24|    Colorize the %(levelname)..s part of the log format passed to __init__.\n25|    \"\"\"\n26|\n27|    LOGLEVEL_COLOROPTS = {\n28|        logging.CRITICAL: {\"red\"},\n29|        logging.ERROR: {\"red\", \"bold\"},\n30|        logging.WARNING: {\"yellow\"},\n31|        logging.WARN: {\"yellow\"},\n32|        logging.INFO: {\"green\"},\n33|        logging.DEBUG: {\"purple\"},\n34|        logging.NOTSET: set(),\n35|    }\n36|    LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-]?\\d*s)\")\n37|\n38|    def __init__(self, terminalwriter, *args, **kwargs):\n39|        super(ColoredLevelFormatter, self).__init__(*args, **kwargs)\n40|        if six.PY2:\n41|            self._original_fmt = self._fmt\n42|        else:\n43|            self._original_fmt = self._style._fmt\n44|        self._level_to_fmt_mapping = {}\n45|\n46|        levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n47|        if not levelname_fmt_match:\n48|            return\n49|        levelname_fmt = levelname_fmt_match.group()\n50|\n51|        for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n52|            formatted_levelname = levelname_fmt % {\n53|                \"levelname\": logging.getLevelName(level)\n54|            }\n55|\n56|            # add ANSI escape sequences around the formatted levelname\n57|            color_kwargs = {name: True for name in color_opts}\n58|            colorized_formatted_levelname = terminalwriter.markup(\n59|                formatted_levelname, **color_kwargs\n60|            )\n61|            self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n62|                colorized_formatted_levelname, self._fmt\n63|            )\n64|\n65|    def format(self, record):\n66|        fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n67|        if six.PY2:\n68|            self._fmt = fmt\n69|        else:\n70|            self._style._fmt = fmt\n71|        return super(ColoredLevelFormatter, self).format(record)\n72|\n73|\n74|def get_option_ini(config, *names):\n75|    for name in names:\n76|        ret = config.getoption(name)  # 'default' arg won't work as expected\n77|        if ret is None:\n78|            ret = config.getini(name)\n79|        if ret:\n80|            return ret\n81|\n...\n185|        root_logger.setLevel(min(orig_level, level))\n186|    try:\n187|        yield handler\n188|    finally:\n189|        if level is not None:\n190|            root_logger.setLevel(orig_level)\n191|        if add_new_handler:\n192|            root_logger.removeHandler(handler)\n193|\n194|\n195|class LogCaptureHandler(logging.StreamHandler):\n196|    \"\"\"A logging handler that stores log records and the log text.\"\"\"\n197|\n198|    def __init__(self):\n199|        \"\"\"Creates a new log handler.\"\"\"\n200|        logging.StreamHandler.__init__(self, py.io.TextIO())\n201|        self.records = []\n202|\n203|    def emit(self, record):\n204|        \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\n205|        self.records.append(record)\n206|        logging.StreamHandler.emit(self, record)\n207|\n208|    def reset(self):\n209|        self.records = []\n210|        self.stream = py.io.TextIO()\n211|\n212|\n213|class LogCaptureFixture(object):\n214|    \"\"\"Provides access and control of log capturing.\"\"\"\n215|\n216|    def __init__(self, item):\n217|        \"\"\"Creates a new funcarg.\"\"\"\n218|        self._item = item\n219|        # dict of log name -> log level\n220|        self._initial_log_levels = {}  # Dict[str, int]\n221|\n222|    def _finalize(self):\n223|        \"\"\"Finalizes the fixture.\n224|\n225|        This restores the log levels changed by :meth:`set_level`.\n226|        \"\"\"\n227|        # restore log levels\n228|        for logger_name, level in self._initial_log_levels.items():\n229|            logger = logging.getLogger(logger_name)\n230|            logger.setLevel(level)\n231|\n232|    @property\n233|    def handler(self):\n234|        \"\"\"\n235|        :rtype: LogCaptureHandler\n236|        \"\"\"\n237|        return self._item.catch_log_handler\n238|\n239|    def get_records(self, when):\n240|        \"\"\"\n241|        Get the logging records for one of the possible test phases.\n242|\n243|        :param str when:\n244|            Which test phase to obtain the records from. Valid values are: \"setup\", \"call\" and \"teardown\".\n245|\n246|        :rtype: List[logging.LogRecord]\n247|        :return: the list of captured records at the given stage\n248|\n249|        .. versionadded:: 3.4\n250|        \"\"\"\n251|        handler = self._item.catch_log_handlers.get(when)\n252|        if handler:\n253|            return handler.records\n254|        else:\n255|            return []\n256|\n257|    @property\n258|    def text(self):\n259|        \"\"\"Returns the log text.\"\"\"\n260|        return self.handler.stream.getvalue()\n261|\n262|    @property\n263|    def records(self):\n264|        \"\"\"Returns the list of log records.\"\"\"\n265|        return self.handler.records\n266|\n267|    @property\n268|    def record_tuples(self):\n269|        \"\"\"Returns a list of a stripped down version of log records intended\n270|        for use in assertion comparison.\n271|\n272|        The format of the tuple is:\n273|\n274|            (logger_name, log_level, message)\n275|        \"\"\"\n276|        return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n277|\n278|    @property\n279|    def messages(self):\n280|        \"\"\"Returns a list of format-interpolated log messages.\n281|\n282|        Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list\n283|        are all interpolated.\n284|        Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with\n285|        levels, timestamps, etc, making exact comparisons more reliable.\n286|\n287|        Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments\n288|        to the logging functions) is not included, as this is added by the formatter in the handler.\n289|\n290|        .. versionadded:: 3.7\n291|        \"\"\"\n292|        return [r.getMessage() for r in self.records]\n293|\n294|    def clear(self):\n295|        \"\"\"Reset the list of log records and the captured log text.\"\"\"\n296|        self.handler.reset()\n297|\n298|    def set_level(self, level, logger=None):\n299|        \"\"\"Sets the level for capturing of logs. The level will be restored to its previous value at the end of\n300|        the test.\n301|\n302|        :param int level: the logger to level.\n303|        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n304|\n305|        .. versionchanged:: 3.4\n306|            The levels of the loggers changed by this function will be restored to their initial values at the\n307|            end of the test.\n308|        \"\"\"\n309|        logger_name = logger\n310|        logger = logging.getLogger(logger_name)\n311|        # save the original log-level to restore it during teardown\n312|        self._initial_log_levels.setdefault(logger_name, logger.level)\n313|        logger.setLevel(level)\n314|\n315|    @contextmanager\n316|    def at_level(self, level, logger=None):\n317|        \"\"\"Context manager that sets the level for capturing of logs. After the end of the 'with' statement the\n318|        level is restored to its original value.\n319|\n320|        :param int level: the logger to level.\n321|        :param str logger: the logger to update the level. If not given, the root logger level is updated.\n322|        \"\"\"\n323|        logger = logging.getLogger(logger)\n324|        orig_level = logger.level\n325|        logger.setLevel(level)\n326|        try:\n327|            yield\n328|        finally:\n329|            logger.setLevel(orig_level)\n330|\n331|\n332|@pytest.fixture\n333|def caplog(request):\n334|    \"\"\"Access and control log capturing.\n335|\n336|    Captured logs are available through the following properties/methods::\n337|\n338|    * caplog.text            -> string containing formatted log output\n339|    * caplog.records         -> list of logging.LogRecord instances\n...\n369|            \"logging level num instead.\".format(log_level, setting_name)\n370|        )\n371|\n372|\n373|# run after terminalreporter/capturemanager are configured\n374|@pytest.hookimpl(trylast=True)\n375|def pytest_configure(config):\n376|    config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n377|\n378|\n379|class LoggingPlugin(object):\n380|    \"\"\"Attaches to the logging module and captures log messages for each test.\n381|    \"\"\"\n382|\n383|    def __init__(self, config):\n384|        \"\"\"Creates a new plugin to capture log messages.\n385|\n386|        The formatter can be safely shared across all handlers so\n387|        create a single one for the entire test session here.\n388|        \"\"\"\n389|        self._config = config\n390|\n391|        # enable verbose output automatically if live logging is enabled\n392|        if self._log_cli_enabled() and config.getoption(\"verbose\") < 1:\n393|            config.option.verbose = 1\n394|\n395|        self.print_logs = get_option_ini(config, \"log_print\")\n396|        self.formatter = logging.Formatter(\n397|            get_option_ini(config, \"log_format\"),\n398|            get_option_ini(config, \"log_date_format\"),\n399|        )\n400|        self.log_level = get_actual_log_level(config, \"log_level\")\n401|\n402|        self.log_file_level = get_actual_log_level(config, \"log_file_level\")\n403|        self.log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n404|        self.log_file_date_format = get_option_ini(\n405|            config, \"log_file_date_format\", \"log_date_format\"\n406|        )\n407|        self.log_file_formatter = logging.Formatter(\n408|            self.log_file_format, datefmt=self.log_file_date_format\n409|        )\n410|\n411|        log_file = get_option_ini(config, \"log_file\")\n412|        if log_file:\n413|            self.log_file_handler = logging.FileHandler(\n414|                log_file, mode=\"w\", encoding=\"UTF-8\"\n415|            )\n416|            self.log_file_handler.setFormatter(self.log_file_formatter)\n417|        else:\n418|            self.log_file_handler = None\n419|\n420|        self.log_cli_handler = None\n421|\n422|        self.live_logs_context = lambda: dummy_context_manager()\n423|        # Note that the lambda for the live_logs_context is needed because\n424|        # live_logs_context can otherwise not be entered multiple times due\n425|        # to limitations of contextlib.contextmanager.\n426|\n427|        if self._log_cli_enabled():\n428|            self._setup_cli_logging()\n429|\n430|    def _setup_cli_logging(self):\n431|        config = self._config\n432|        terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n433|        if terminal_reporter is None:\n434|            # terminal reporter is disabled e.g. by pytest-xdist.\n435|            return\n436|\n437|        capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n438|        # if capturemanager plugin is disabled, live logging still works.\n439|        log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n440|        log_cli_format = get_option_ini(config, \"log_cli_format\", \"log_format\")\n441|        log_cli_date_format = get_option_ini(\n442|            config, \"log_cli_date_format\", \"log_date_format\"\n443|        )\n444|        if (\n445|            config.option.color != \"no\"\n446|            and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)\n447|        ):\n448|            log_cli_formatter = ColoredLevelFormatter(\n449|                create_terminal_writer(config),\n450|                log_cli_format,\n451|                datefmt=log_cli_date_format,\n452|            )\n453|        else:\n454|            log_cli_formatter = logging.Formatter(\n455|                log_cli_format, datefmt=log_cli_date_format\n456|            )\n457|        log_cli_level = get_actual_log_level(config, \"log_cli_level\", \"log_level\")\n458|        self.log_cli_handler = log_cli_handler\n459|        self.live_logs_context = lambda: catching_logs(\n460|            log_cli_handler, formatter=log_cli_formatter, level=log_cli_level\n461|        )\n462|\n463|    def set_log_path(self, fname):\n464|        \"\"\"Public method, which can set filename parameter for\n465|        Logging.FileHandler(). Also creates parent directory if\n466|        it does not exist.\n467|\n468|        .. warning::\n469|            Please considered as an experimental API.\n470|        \"\"\"\n471|        fname = Path(fname)\n472|\n473|        if not fname.is_absolute():\n474|            fname = Path(self._config.rootdir, fname)\n475|\n476|        if not fname.parent.exists():\n477|            fname.parent.mkdir(exist_ok=True, parents=True)\n478|\n479|        self.log_file_handler = logging.FileHandler(\n480|            str(fname), mode=\"w\", encoding=\"UTF-8\"\n481|        )\n482|        self.log_file_handler.setFormatter(self.log_file_formatter)\n483|\n484|    def _log_cli_enabled(self):\n485|        \"\"\"Return True if log_cli should be considered enabled, either explicitly\n486|        or because --log-cli-level was given in the command-line.\n487|        \"\"\"\n488|        return self._config.getoption(\n489|            \"--log-cli-level\"\n490|        ) is not None or self._config.getini(\"log_cli\")\n491|\n492|    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n493|    def pytest_collection(self):\n494|        with self.live_logs_context():\n495|            if self.log_cli_handler:\n496|                self.log_cli_handler.set_when(\"collection\")\n497|\n498|            if self.log_file_handler is not None:\n499|                with catching_logs(self.log_file_handler, level=self.log_file_level):\n500|                    yield\n501|            else:\n502|                yield\n503|\n504|    @contextmanager\n505|    def _runtest_for(self, item, when):\n506|        with self._runtest_for_main(item, when):\n507|            if self.log_file_handler is not None:\n508|                with catching_logs(self.log_file_handler, level=self.log_file_level):\n509|                    yield\n510|            else:\n511|                yield\n512|\n513|    @contextmanager\n514|    def _runtest_for_main(self, item, when):\n515|        \"\"\"Implements the internals of pytest_runtest_xxx() hook.\"\"\"\n516|        with catching_logs(\n517|            LogCaptureHandler(), formatter=self.formatter, level=self.log_level\n518|        ) as log_handler:\n519|            if self.log_cli_handler:\n520|                self.log_cli_handler.set_when(when)\n521|\n522|            if item is None:\n523|                yield  # run the test\n524|                return\n525|\n526|            if not hasattr(item, \"catch_log_handlers\"):\n527|                item.catch_log_handlers = {}\n528|            item.catch_log_handlers[when] = log_handler\n529|            item.catch_log_handler = log_handler\n530|            try:\n531|                yield  # run test\n532|            finally:\n533|                if when == \"teardown\":\n534|                    del item.catch_log_handler\n535|                    del item.catch_log_handlers\n536|\n537|            if self.print_logs:\n538|                # Add a captured log section to the report.\n539|                log = log_handler.stream.getvalue().strip()\n540|                item.add_report_section(when, \"log\", log)\n541|\n542|    @pytest.hookimpl(hookwrapper=True)\n543|    def pytest_runtest_setup(self, item):\n544|        with self._runtest_for(item, \"setup\"):\n545|            yield\n546|\n547|    @pytest.hookimpl(hookwrapper=True)\n548|    def pytest_runtest_call(self, item):\n549|        with self._runtest_for(item, \"call\"):\n550|            yield\n551|\n552|    @pytest.hookimpl(hookwrapper=True)\n553|    def pytest_runtest_teardown(self, item):\n554|        with self._runtest_for(item, \"teardown\"):\n555|            yield\n556|\n557|    @pytest.hookimpl(hookwrapper=True)\n558|    def pytest_runtest_logstart(self):\n559|        if self.log_cli_handler:\n560|            self.log_cli_handler.reset()\n561|        with self._runtest_for(None, \"start\"):\n562|            yield\n563|\n564|    @pytest.hookimpl(hookwrapper=True)\n565|    def pytest_runtest_logfinish(self):\n566|        with self._runtest_for(None, \"finish\"):\n567|            yield\n568|\n569|    @pytest.hookimpl(hookwrapper=True)\n570|    def pytest_runtest_logreport(self):\n571|        with self._runtest_for(None, \"logreport\"):\n572|            yield\n573|\n574|    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n575|    def pytest_sessionfinish(self):\n576|        with self.live_logs_context():\n577|            if self.log_cli_handler:\n578|                self.log_cli_handler.set_when(\"sessionfinish\")\n579|            if self.log_file_handler is not None:\n580|                try:\n581|                    with catching_logs(\n582|                        self.log_file_handler, level=self.log_file_level\n583|                    ):\n584|                        yield\n585|                finally:\n586|                    # Close the FileHandler explicitly.\n587|                    # (logging.shutdown might have lost the weakref?!)\n588|                    self.log_file_handler.close()\n589|            else:\n590|                yield\n591|\n592|    @pytest.hookimpl(hookwrapper=True, tryfirst=True)\n593|    def pytest_sessionstart(self):\n594|        with self.live_logs_context():\n595|            if self.log_cli_handler:\n596|                self.log_cli_handler.set_when(\"sessionstart\")\n597|            if self.log_file_handler is not None:\n598|                with catching_logs(self.log_file_handler, level=self.log_file_level):\n599|                    yield\n600|            else:\n601|                yield\n602|\n603|    @pytest.hookimpl(hookwrapper=True)\n604|    def pytest_runtestloop(self, session):\n605|        \"\"\"Runs all collected test items.\"\"\"\n606|        with self.live_logs_context():\n607|            if self.log_file_handler is not None:\n608|                with catching_logs(self.log_file_handler, level=self.log_file_level):\n609|                    yield  # run all the tests\n610|            else:\n611|                yield  # run all the tests\n612|\n613|\n614|class _LiveLoggingStreamHandler(logging.StreamHandler):\n615|    \"\"\"\n616|    Custom StreamHandler used by the live logging feature: it will write a newline before the first log message\n617|    in each test.\n618|\n619|    During live logging we must also explicitly disable stdout/stderr capturing otherwise it will get captured\n620|    and won't appear in the terminal.\n621|    \"\"\"\n622|\n623|    def __init__(self, terminal_reporter, capture_manager):\n624|        \"\"\"\n625|        :param _pytest.terminal.TerminalReporter terminal_reporter:\n626|        :param _pytest.capture.CaptureManager capture_manager:\n627|        \"\"\"\n628|        logging.StreamHandler.__init__(self, stream=terminal_reporter)\n629|        self.capture_manager = capture_manager\n630|        self.reset()\n631|        self.set_when(None)\n632|        self._test_outcome_written = False\n633|\n634|    def reset(self):\n635|        \"\"\"Reset the handler; should be called before the start of each test\"\"\"\n636|        self._first_record_emitted = False\n637|\n638|    def set_when(self, when):\n639|        \"\"\"Prepares for the given test phase (setup/call/teardown)\"\"\"\n640|        self._when = when\n641|        self._section_name_shown = False\n642|        if when == \"start\":\n643|            self._test_outcome_written = False\n644|\n645|    def emit(self, record):\n646|        ctx_manager = (\n647|            self.capture_manager.global_and_fixture_disabled()\n648|            if self.capture_manager\n649|            else dummy_context_manager()\n650|        )\n651|        with ctx_manager:\n652|            if not self._first_record_emitted:\n653|                self.stream.write(\"\\n\")\n654|                self._first_record_emitted = True\n655|            elif self._when in (\"teardown\", \"finish\"):\n656|                if not self._test_outcome_written:\n657|                    self._test_outcome_written = True\n658|                    self.stream.write(\"\\n\")\n659|            if not self._section_name_shown and self._when:\n660|                self.stream.section(\"live log \" + self._when, sep=\"-\", bold=True)\n661|                self._section_name_shown = True\n662|            logging.StreamHandler.emit(self, record)\n\n\n### src/_pytest/terminal.py\n...\n217|                filename, linenum = self.fslocation[:2]\n218|                relpath = py.path.local(filename).relto(config.invocation_dir)\n219|                if not relpath:\n220|                    relpath = str(filename)\n221|                return \"%s:%s\" % (relpath, linenum)\n222|            else:\n223|                return str(self.fslocation)\n224|        return None\n225|\n226|\n227|class TerminalReporter(object):\n228|    def __init__(self, config, file=None):\n229|        import _pytest.config\n230|\n231|        self.config = config\n232|        self._numcollected = 0\n233|        self._session = None\n234|        self._showfspath = None\n235|\n236|        self.stats = {}\n237|        self.startdir = config.invocation_dir\n238|        if file is None:\n239|            file = sys.stdout\n240|        self._tw = _pytest.config.create_terminal_writer(config, file)\n241|        # self.writer will be deprecated in pytest-3.4\n242|        self.writer = self._tw\n243|        self._screen_width = self._tw.fullwidth\n244|        self.currentfspath = None\n245|        self.reportchars = getreportopt(config)\n246|        self.hasmarkup = self._tw.hasmarkup\n247|        self.isatty = file.isatty()\n248|        self._progress_nodeids_reported = set()\n249|        self._show_progress_info = self._determine_show_progress_info()\n250|        self._collect_report_last_write = None\n251|\n252|    def _determine_show_progress_info(self):\n253|        \"\"\"Return True if we should display progress information based on the current config\"\"\"\n254|        # do not show progress if we are not capturing output (#3038)\n255|        if self.config.getoption(\"capture\", \"no\") == \"no\":\n256|            return False\n257|        # do not show progress if we are showing fixture setup/teardown\n258|        if self.config.getoption(\"setupshow\", False):\n259|            return False\n260|        cfg = self.config.getini(\"console_output_style\")\n261|        if cfg in (\"progress\", \"count\"):\n262|            return cfg\n263|        return False\n264|\n265|    @property\n266|    def verbosity(self):\n267|        return self.config.option.verbose\n268|\n269|    @property\n270|    def showheader(self):\n271|        return self.verbosity >= 0\n272|\n273|    @property\n274|    def showfspath(self):\n275|        if self._showfspath is None:\n276|            return self.verbosity >= 0\n277|        return self._showfspath\n278|\n279|    @showfspath.setter\n280|    def showfspath(self, value):\n281|        self._showfspath = value\n282|\n283|    @property\n284|    def showlongtestinfo(self):\n285|        return self.verbosity > 0\n286|\n287|    def hasopt(self, char):\n288|        char = {\"xfailed\": \"x\", \"skipped\": \"s\"}.get(char, char)\n289|        return char in self.reportchars\n290|\n291|    def write_fspath_result(self, nodeid, res, **markup):\n292|        fspath = self.config.rootdir.join(nodeid.split(\"::\")[0])\n293|        # NOTE: explicitly check for None to work around py bug, and for less\n294|        # overhead in general (https://github.com/pytest-dev/py/pull/207).\n295|        if self.currentfspath is None or fspath != self.currentfspath:\n296|            if self.currentfspath is not None and self._show_progress_info:\n297|                self._write_progress_information_filling_space()\n298|            self.currentfspath = fspath\n299|            fspath = self.startdir.bestrelpath(fspath)\n300|            self._tw.line()\n301|            self._tw.write(fspath + \" \")\n302|        self._tw.write(res, **markup)\n303|\n304|    def write_ensure_prefix(self, prefix, extra=\"\", **kwargs):\n305|        if self.currentfspath != prefix:\n306|            self._tw.line()\n307|            self.currentfspath = prefix\n308|            self._tw.write(prefix)\n309|        if extra:\n310|            self._tw.write(extra, **kwargs)\n311|            self.currentfspath = -2\n312|\n313|    def ensure_newline(self):\n314|        if self.currentfspath:\n315|            self._tw.line()\n316|            self.currentfspath = None\n317|\n318|    def write(self, content, **markup):\n319|        self._tw.write(content, **markup)\n320|\n321|    def write_line(self, line, **markup):\n322|        if not isinstance(line, six.text_type):\n323|            line = six.text_type(line, errors=\"replace\")\n324|        self.ensure_newline()\n325|        self._tw.line(line, **markup)\n326|\n327|    def rewrite(self, line, **markup):\n328|        \"\"\"\n329|        Rewinds the terminal cursor to the beginning and writes the given line.\n330|\n331|        :kwarg erase: if True, will also add spaces until the full terminal width to ensure\n332|            previous lines are properly erased.\n333|\n334|        The rest of the keyword arguments are markup instructions.\n335|        \"\"\"\n336|        erase = markup.pop(\"erase\", False)\n337|        if erase:\n338|            fill_count = self._tw.fullwidth - len(line) - 1\n339|            fill = \" \" * fill_count\n340|        else:\n341|            fill = \"\"\n342|        line = str(line)\n343|        self._tw.write(\"\\r\" + line + fill, **markup)\n344|\n345|    def write_sep(self, sep, title=None, **markup):\n346|        self.ensure_newline()\n347|        self._tw.sep(sep, title, **markup)\n348|\n349|    def section(self, title, sep=\"=\", **kw):\n350|        self._tw.sep(sep, title, **kw)\n351|\n352|    def line(self, msg, **kw):\n353|        self._tw.line(msg, **kw)\n354|\n355|    def pytest_internalerror(self, excrepr):\n356|        for line in six.text_type(excrepr).split(\"\\n\"):\n357|            self.write_line(\"INTERNALERROR> \" + line)\n358|        return 1\n359|\n360|    def pytest_warning_captured(self, warning_message, item):\n361|        # from _pytest.nodes import get_fslocation_from_item\n362|        from _pytest.warnings import warning_record_to_str\n363|\n364|        warnings = self.stats.setdefault(\"warnings\", [])\n365|        fslocation = warning_message.filename, warning_message.lineno\n366|        message = warning_record_to_str(warning_message)\n367|\n368|        nodeid = item.nodeid if item is not None else \"\"\n369|        warning_report = WarningReport(\n370|            fslocation=fslocation, message=message, nodeid=nodeid\n371|        )\n372|        warnings.append(warning_report)\n373|\n374|    def pytest_plugin_registered(self, plugin):\n375|        if self.config.option.traceconfig:\n376|            msg = \"PLUGIN registered: %s\" % (plugin,)\n377|            # XXX this event may happen during setup/teardown time\n378|            #     which unfortunately captures our output here\n379|            #     which garbles our output if we use self.write_line\n380|            self.write_line(msg)\n381|\n382|    def pytest_deselected(self, items):\n383|        self.stats.setdefault(\"deselected\", []).extend(items)\n384|\n385|    def pytest_runtest_logstart(self, nodeid, location):\n386|        # ensure that the path is printed before the\n387|        # 1st test of a module starts running\n388|        if self.showlongtestinfo:\n389|            line = self._locationline(nodeid, *location)\n390|            self.write_ensure_prefix(line, \"\")\n391|        elif self.showfspath:\n392|            fsid = nodeid.split(\"::\")[0]\n393|            self.write_fspath_result(fsid, \"\")\n394|\n395|    def pytest_runtest_logreport(self, report):\n396|        self._tests_ran = True\n397|        rep = report\n398|        res = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)\n399|        category, letter, word = res\n400|        if isinstance(word, tuple):\n401|            word, markup = word\n402|        else:\n403|            markup = None\n404|        self.stats.setdefault(category, []).append(rep)\n405|        if not letter and not word:\n406|            # probably passed setup/teardown\n407|            return\n408|        running_xdist = hasattr(rep, \"node\")\n409|        if markup is None:\n410|            was_xfail = hasattr(report, \"wasxfail\")\n411|            if rep.passed and not was_xfail:\n412|                markup = {\"green\": True}\n413|            elif rep.passed and was_xfail:\n414|                markup = {\"yellow\": True}\n415|            elif rep.failed:\n416|                markup = {\"red\": True}\n417|            elif rep.skipped:\n418|                markup = {\"yellow\": True}\n419|            else:\n420|                markup = {}\n421|        if self.verbosity <= 0:\n422|            if not running_xdist and self.showfspath:\n423|                self.write_fspath_result(rep.nodeid, letter, **markup)\n424|            else:\n425|                self._tw.write(letter, **markup)\n426|        else:\n427|            self._progress_nodeids_reported.add(rep.nodeid)\n428|            line = self._locationline(rep.nodeid, *rep.location)\n429|            if not running_xdist:\n430|                self.write_ensure_prefix(line, word, **markup)\n431|                if self._show_progress_info:\n432|                    self._write_progress_information_filling_space()\n433|            else:\n434|                self.ensure_newline()\n435|                self._tw.write(\"[%s]\" % rep.node.gateway.id)\n436|                if self._show_progress_info:\n437|                    self._tw.write(\n438|                        self._get_progress_information_message() + \" \", cyan=True\n439|                    )\n440|                else:\n441|                    self._tw.write(\" \")\n442|                self._tw.write(word, **markup)\n443|                self._tw.write(\" \" + line)\n444|                self.currentfspath = -2\n445|\n446|    def pytest_runtest_logfinish(self, nodeid):\n447|        if self.verbosity <= 0 and self._show_progress_info:\n448|            if self._show_progress_info == \"count\":\n449|                num_tests = self._session.testscollected\n450|                progress_length = len(\" [{}/{}]\".format(str(num_tests), str(num_tests)))\n451|            else:\n452|                progress_length = len(\" [100%]\")\n453|\n454|            self._progress_nodeids_reported.add(nodeid)\n455|            is_last_item = (\n456|                len(self._progress_nodeids_reported) == self._session.testscollected\n457|            )\n458|            if is_last_item:\n459|                self._write_progress_information_filling_space()\n460|            else:\n461|                w = self._width_of_current_line\n462|                past_edge = w + progress_length + 1 >= self._screen_width\n463|                if past_edge:\n464|                    msg = self._get_progress_information_message()\n465|                    self._tw.write(msg + \"\\n\", cyan=True)\n466|\n467|    def _get_progress_information_message(self):\n468|        collected = self._session.testscollected\n469|        if self._show_progress_info == \"count\":\n470|            if collected:\n471|                progress = self._progress_nodeids_reported\n472|                counter_format = \"{{:{}d}}\".format(len(str(collected)))\n473|                format_string = \" [{}/{{}}]\".format(counter_format)\n474|                return format_string.format(len(progress), collected)\n475|            return \" [ {} / {} ]\".format(collected, collected)\n476|        else:\n477|            if collected:\n478|                progress = len(self._progress_nodeids_reported) * 100 // collected\n479|                return \" [{:3d}%]\".format(progress)\n480|            return \" [100%]\"\n481|\n482|    def _write_progress_information_filling_space(self):\n483|        msg = self._get_progress_information_message()\n484|        w = self._width_of_current_line\n485|        fill = self._tw.fullwidth - w - 1\n486|        self.write(msg.rjust(fill), cyan=True)\n487|\n488|    @property\n489|    def _width_of_current_line(self):\n490|        \"\"\"Return the width of current line, using the superior implementation of py-1.6 when available\"\"\"\n491|        try:\n492|            return self._tw.width_of_current_line\n493|        except AttributeError:\n494|            # py < 1.6.0\n495|            return self._tw.chars_on_current_line\n496|\n497|    def pytest_collection(self):\n498|        if self.isatty:\n499|            if self.config.option.verbose >= 0:\n500|                self.write(\"collecting ... \", bold=True)\n501|                self._collect_report_last_write = time.time()\n502|        elif self.config.option.verbose >= 1:\n503|            self.write(\"collecting ... \", bold=True)\n504|\n505|    def pytest_collectreport(self, report):\n506|        if report.failed:\n507|            self.stats.setdefault(\"error\", []).append(report)\n508|        elif report.skipped:\n509|            self.stats.setdefault(\"skipped\", []).append(report)\n510|        items = [x for x in report.result if isinstance(x, pytest.Item)]\n511|        self._numcollected += len(items)\n512|        if self.isatty:\n513|            self.report_collect()\n514|\n515|    def report_collect(self, final=False):\n516|        if self.config.option.verbose < 0:\n517|            return\n518|\n519|        if not final:\n520|            # Only write \"collecting\" report every 0.5s.\n521|            t = time.time()\n522|            if (\n523|                self._collect_report_last_write is not None\n524|                and self._collect_report_last_write > t - REPORT_COLLECTING_RESOLUTION\n525|            ):\n526|                return\n527|            self._collect_report_last_write = t\n528|\n529|        errors = len(self.stats.get(\"error\", []))\n530|        skipped = len(self.stats.get(\"skipped\", []))\n531|        deselected = len(self.stats.get(\"deselected\", []))\n532|        selected = self._numcollected - errors - skipped - deselected\n533|        if final:\n534|            line = \"collected \"\n535|        else:\n536|            line = \"collecting \"\n537|        line += (\n538|            str(self._numcollected) + \" item\" + (\"\" if self._numcollected == 1 else \"s\")\n539|        )\n540|        if errors:\n541|            line += \" / %d errors\" % errors\n542|        if deselected:\n543|            line += \" / %d deselected\" % deselected\n544|        if skipped:\n545|            line += \" / %d skipped\" % skipped\n546|        if self._numcollected > selected > 0:\n547|            line += \" / %d selected\" % selected\n548|        if self.isatty:\n549|            self.rewrite(line, bold=True, erase=True)\n550|            if final:\n551|                self.write(\"\\n\")\n552|        else:\n553|            self.write_line(line)\n554|\n555|    @pytest.hookimpl(trylast=True)\n556|    def pytest_sessionstart(self, session):\n557|        self._session = session\n558|        self._sessionstarttime = time.time()\n559|        if not self.showheader:\n560|            return\n561|        self.write_sep(\"=\", \"test session starts\", bold=True)\n562|        verinfo = platform.python_version()\n563|        msg = \"platform %s -- Python %s\" % (sys.platform, verinfo)\n564|        if hasattr(sys, \"pypy_version_info\"):\n565|            verinfo = \".\".join(map(str, sys.pypy_version_info[:3]))\n566|            msg += \"[pypy-%s-%s]\" % (verinfo, sys.pypy_version_info[3])\n567|        msg += \", pytest-%s, py-%s, pluggy-%s\" % (\n568|            pytest.__version__,\n569|            py.__version__,\n570|            pluggy.__version__,\n571|        )\n572|        if (\n573|            self.verbosity > 0\n574|            or self.config.option.debug\n575|            or getattr(self.config.option, \"pastebin\", None)\n576|        ):\n577|            msg += \" -- \" + str(sys.executable)\n578|        self.write_line(msg)\n579|        lines = self.config.hook.pytest_report_header(\n580|            config=self.config, startdir=self.startdir\n581|        )\n582|        self._write_report_lines_from_hooks(lines)\n583|\n584|    def _write_report_lines_from_hooks(self, lines):\n585|        lines.reverse()\n586|        for line in collapse(lines):\n587|            self.write_line(line)\n588|\n589|    def pytest_report_header(self, config):\n590|        line = \"rootdir: %s\" % config.rootdir\n591|\n592|        if config.inifile:\n593|            line += \", inifile: \" + config.rootdir.bestrelpath(config.inifile)\n594|\n595|        testpaths = config.getini(\"testpaths\")\n596|        if testpaths and config.args == testpaths:\n597|            rel_paths = [config.rootdir.bestrelpath(x) for x in testpaths]\n598|            line += \", testpaths: {}\".format(\", \".join(rel_paths))\n599|        result = [line]\n600|\n601|        plugininfo = config.pluginmanager.list_plugin_distinfo()\n602|        if plugininfo:\n603|            result.append(\"plugins: %s\" % \", \".join(_plugin_nameversions(plugininfo)))\n604|        return result\n605|\n606|    def pytest_collection_finish(self, session):\n607|        self.report_collect(True)\n608|\n609|        if self.config.getoption(\"collectonly\"):\n610|            self._printcollecteditems(session.items)\n611|\n612|        lines = self.config.hook.pytest_report_collectionfinish(\n613|            config=self.config, startdir=self.startdir, items=session.items\n614|        )\n615|        self._write_report_lines_from_hooks(lines)\n616|\n617|        if self.config.getoption(\"collectonly\"):\n618|            if self.stats.get(\"failed\"):\n619|                self._tw.sep(\"!\", \"collection failures\")\n620|                for rep in self.stats.get(\"failed\"):\n621|                    rep.toterminal(self._tw)\n622|\n623|    def _printcollecteditems(self, items):\n624|        # to print out items and their parent collectors\n625|        # we take care to leave out Instances aka ()\n626|        # because later versions are going to get rid of them anyway\n627|        if self.config.option.verbose < 0:\n628|            if self.config.option.verbose < -1:\n629|                counts = {}\n630|                for item in items:\n631|                    name = item.nodeid.split(\"::\", 1)[0]\n632|                    counts[name] = counts.get(name, 0) + 1\n633|                for name, count in sorted(counts.items()):\n634|                    self._tw.line(\"%s: %d\" % (name, count))\n635|            else:\n636|                for item in items:\n637|                    self._tw.line(item.nodeid)\n638|            return\n639|        stack = []\n640|        indent = \"\"\n641|        for item in items:\n642|            needed_collectors = item.listchain()[1:]  # strip root node\n643|            while stack:\n644|                if stack == needed_collectors[: len(stack)]:\n645|                    break\n646|                stack.pop()\n647|            for col in needed_collectors[len(stack) :]:\n648|                stack.append(col)\n649|                if col.name == \"()\":  # Skip Instances.\n650|                    continue\n651|                indent = (len(stack) - 1) * \"  \"\n652|                self._tw.line(\"%s%s\" % (indent, col))\n653|                if self.config.option.verbose >= 1:\n654|                    if hasattr(col, \"_obj\") and col._obj.__doc__:\n655|                        for line in col._obj.__doc__.strip().splitlines():\n656|                            self._tw.line(\"%s%s\" % (indent + \"  \", line.strip()))\n657|\n658|    @pytest.hookimpl(hookwrapper=True)\n659|    def pytest_sessionfinish(self, exitstatus):\n660|        outcome = yield\n661|        outcome.get_result()\n662|        self._tw.line(\"\")\n663|        summary_exit_codes = (\n664|            EXIT_OK,\n665|            EXIT_TESTSFAILED,\n666|            EXIT_INTERRUPTED,\n667|            EXIT_USAGEERROR,\n668|            EXIT_NOTESTSCOLLECTED,\n669|        )\n670|        if exitstatus in summary_exit_codes:\n671|            self.config.hook.pytest_terminal_summary(\n672|                terminalreporter=self, exitstatus=exitstatus, config=self.config\n673|            )\n674|        if exitstatus == EXIT_INTERRUPTED:\n675|            self._report_keyboardinterrupt()\n676|            del self._keyboardinterrupt_memo\n677|        self.summary_stats()\n678|\n679|    @pytest.hookimpl(hookwrapper=True)\n680|    def pytest_terminal_summary(self):\n681|        self.summary_errors()\n682|        self.summary_failures()\n683|        self.summary_warnings()\n684|        self.summary_passes()\n685|        yield\n686|        self.short_test_summary()\n687|        # Display any extra warnings from teardown here (if any).\n688|        self.summary_warnings()\n689|\n690|    def pytest_keyboard_interrupt(self, excinfo):\n691|        self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=True)\n692|\n693|    def pytest_unconfigure(self):\n694|        if hasattr(self, \"_keyboardinterrupt_memo\"):\n695|            self._report_keyboardinterrupt()\n696|\n697|    def _report_keyboardinterrupt(self):\n698|        excrepr = self._keyboardinterrupt_memo\n699|        msg = excrepr.reprcrash.message\n700|        self.write_sep(\"!\", msg)\n701|        if \"KeyboardInterrupt\" in msg:\n702|            if self.config.option.fulltrace:\n703|                excrepr.toterminal(self._tw)\n704|            else:\n705|                excrepr.reprcrash.toterminal(self._tw)\n706|                self._tw.line(\n707|                    \"(to show a full traceback on KeyboardInterrupt use --fulltrace)\",\n708|                    yellow=True,\n709|                )\n710|\n711|    def _locationline(self, nodeid, fspath, lineno, domain):\n712|        def mkrel(nodeid):\n713|            line = self.config.cwd_relative_nodeid(nodeid)\n714|            if domain and line.endswith(domain):\n715|                line = line[: -len(domain)]\n716|                values = domain.split(\"[\")\n717|                values[0] = values[0].replace(\".\", \"::\")  # don't replace '.' in params\n718|                line += \"[\".join(values)\n719|            return line\n720|\n721|        # collect_fspath comes from testid which has a \"/\"-normalized path\n722|\n723|        if fspath:\n724|            res = mkrel(nodeid)\n725|            if self.verbosity >= 2 and nodeid.split(\"::\")[0] != fspath.replace(\n726|                \"\\\\\", nodes.SEP\n727|            ):\n728|                res += \" <- \" + self.startdir.bestrelpath(fspath)\n729|        else:\n730|            res = \"[location]\"\n731|        return res + \" \"\n732|\n733|    def _getfailureheadline(self, rep):\n734|        head_line = rep.head_line\n735|        if head_line:\n736|            return head_line\n737|        return \"test session\"  # XXX?\n738|\n739|    def _getcrashline(self, rep):\n740|        try:\n741|            return str(rep.longrepr.reprcrash)\n742|        except AttributeError:\n743|            try:\n744|                return str(rep.longrepr)[:50]\n745|            except AttributeError:\n746|                return \"\"\n747|\n748|    #\n749|    # summaries for sessionfinish\n750|    #\n751|    def getreports(self, name):\n752|        values = []\n753|        for x in self.stats.get(name, []):\n754|            if not hasattr(x, \"_pdbshown\"):\n755|                values.append(x)\n756|        return values\n757|\n758|    def summary_warnings(self):\n759|        if self.hasopt(\"w\"):\n760|            all_warnings = self.stats.get(\"warnings\")\n761|            if not all_warnings:\n762|                return\n763|\n764|            final = hasattr(self, \"_already_displayed_warnings\")\n765|            if final:\n766|                warning_reports = all_warnings[self._already_displayed_warnings :]\n767|            else:\n768|                warning_reports = all_warnings\n769|            self._already_displayed_warnings = len(warning_reports)\n770|            if not warning_reports:\n771|                return\n772|\n773|            reports_grouped_by_message = collections.OrderedDict()\n774|            for wr in warning_reports:\n775|                reports_grouped_by_message.setdefault(wr.message, []).append(wr)\n776|\n777|            title = \"warnings summary (final)\" if final else \"warnings summary\"\n778|            self.write_sep(\"=\", title, yellow=True, bold=False)\n779|            for message, warning_reports in reports_grouped_by_message.items():\n780|                has_any_location = False\n781|                for w in warning_reports:\n782|                    location = w.get_location(self.config)\n783|                    if location:\n784|                        self._tw.line(str(location))\n785|                        has_any_location = True\n786|                if has_any_location:\n787|                    lines = message.splitlines()\n788|                    indented = \"\\n\".join(\"  \" + x for x in lines)\n789|                    message = indented.rstrip()\n790|                else:\n791|                    message = message.rstrip()\n792|                self._tw.line(message)\n793|                self._tw.line()\n794|            self._tw.line(\"-- Docs: https://docs.pytest.org/en/latest/warnings.html\")\n795|\n796|    def summary_passes(self):\n797|        if self.config.option.tbstyle != \"no\":\n798|            if self.hasopt(\"P\"):\n799|                reports = self.getreports(\"passed\")\n800|                if not reports:\n801|                    return\n802|                self.write_sep(\"=\", \"PASSES\")\n803|                for rep in reports:\n804|                    if rep.sections:\n805|                        msg = self._getfailureheadline(rep)\n806|                        self.write_sep(\"_\", msg, green=True, bold=True)\n807|                        self._outrep_summary(rep)\n808|\n809|    def print_teardown_sections(self, rep):\n810|        showcapture = self.config.option.showcapture\n811|        if showcapture == \"no\":\n812|            return\n813|        for secname, content in rep.sections:\n814|            if showcapture != \"all\" and showcapture not in secname:\n815|                continue\n816|            if \"teardown\" in secname:\n817|                self._tw.sep(\"-\", secname)\n818|                if content[-1:] == \"\\n\":\n819|                    content = content[:-1]\n820|                self._tw.line(content)\n821|\n822|    def summary_failures(self):\n823|        if self.config.option.tbstyle != \"no\":\n824|            reports = self.getreports(\"failed\")\n825|            if not reports:\n826|                return\n827|            self.write_sep(\"=\", \"FAILURES\")\n828|            if self.config.option.tbstyle == \"line\":\n829|                for rep in reports:\n830|                    line = self._getcrashline(rep)\n831|                    self.write_line(line)\n832|            else:\n833|                teardown_sections = {}\n834|                for report in self.getreports(\"\"):\n835|                    if report.when == \"teardown\":\n836|                        teardown_sections.setdefault(report.nodeid, []).append(report)\n837|\n838|                for rep in reports:\n839|                    msg = self._getfailureheadline(rep)\n840|                    self.write_sep(\"_\", msg, red=True, bold=True)\n841|                    self._outrep_summary(rep)\n842|                    for report in teardown_sections.get(rep.nodeid, []):\n843|                        self.print_teardown_sections(report)\n844|\n845|    def summary_errors(self):\n846|        if self.config.option.tbstyle != \"no\":\n847|            reports = self.getreports(\"error\")\n848|            if not reports:\n849|                return\n850|            self.write_sep(\"=\", \"ERRORS\")\n851|            for rep in self.stats[\"error\"]:\n852|                msg = self._getfailureheadline(rep)\n853|                if rep.when == \"collect\":\n854|                    msg = \"ERROR collecting \" + msg\n855|                else:\n856|                    msg = \"ERROR at %s of %s\" % (rep.when, msg)\n857|                self.write_sep(\"_\", msg, red=True, bold=True)\n858|                self._outrep_summary(rep)\n859|\n860|    def _outrep_summary(self, rep):\n861|        rep.toterminal(self._tw)\n862|        showcapture = self.config.option.showcapture\n863|        if showcapture == \"no\":\n864|            return\n865|        for secname, content in rep.sections:\n866|            if showcapture != \"all\" and showcapture not in secname:\n867|                continue\n868|            self._tw.sep(\"-\", secname)\n869|            if content[-1:] == \"\\n\":\n870|                content = content[:-1]\n871|            self._tw.line(content)\n872|\n873|    def summary_stats(self):\n874|        session_duration = time.time() - self._sessionstarttime\n875|        (line, color) = build_summary_stats_line(self.stats)\n876|        msg = \"%s in %.2f seconds\" % (line, session_duration)\n877|        markup = {color: True, \"bold\": True}\n878|\n879|        if self.verbosity >= 0:\n880|            self.write_sep(\"=\", msg, **markup)\n881|        if self.verbosity == -1:\n882|            self.write_line(msg, **markup)\n883|\n884|    def short_test_summary(self):\n885|        if not self.reportchars:\n886|            return\n887|\n888|        def show_simple(stat, lines):\n889|            failed = self.stats.get(stat, [])\n890|            for rep in failed:\n891|                verbose_word = rep._get_verbose_word(self.config)\n892|                pos = _get_pos(self.config, rep)\n893|                lines.append(\"%s %s\" % (verbose_word, pos))\n894|\n895|        def show_xfailed(lines):\n896|            xfailed = self.stats.get(\"xfailed\", [])\n897|            for rep in xfailed:\n898|                verbose_word = rep._get_verbose_word(self.config)\n899|                pos = _get_pos(self.config, rep)\n900|                lines.append(\"%s %s\" % (verbose_word, pos))\n901|                reason = rep.wasxfail\n902|                if reason:\n903|                    lines.append(\"  \" + str(reason))\n904|\n905|        def show_xpassed(lines):\n906|            xpassed = self.stats.get(\"xpassed\", [])\n907|            for rep in xpassed:\n908|                verbose_word = rep._get_verbose_word(self.config)\n909|                pos = _get_pos(self.config, rep)\n910|                reason = rep.wasxfail\n911|                lines.append(\"%s %s %s\" % (verbose_word, pos, reason))\n912|\n913|        def show_skipped(lines):\n914|            skipped = self.stats.get(\"skipped\", [])\n915|            fskips = _folded_skips(skipped) if skipped else []\n916|            if not fskips:\n917|                return\n918|            verbose_word = skipped[0]._get_verbose_word(self.config)\n919|            for num, fspath, lineno, reason in fskips:\n920|                if reason.startswith(\"Skipped: \"):\n921|                    reason = reason[9:]\n922|                if lineno is not None:\n923|                    lines.append(\n924|                        \"%s [%d] %s:%d: %s\"\n925|                        % (verbose_word, num, fspath, lineno + 1, reason)\n926|                    )\n927|                else:\n928|                    lines.append(\"%s [%d] %s: %s\" % (verbose_word, num, fspath, reason))\n929|\n930|        def _get_pos(config, rep):\n931|            nodeid = config.cwd_relative_nodeid(rep.nodeid)\n932|            return nodeid\n933|\n934|        REPORTCHAR_ACTIONS = {\n935|            \"x\": show_xfailed,\n936|            \"X\": show_xpassed,\n937|            \"f\": partial(show_simple, \"failed\"),\n938|            \"F\": partial(show_simple, \"failed\"),\n939|            \"s\": show_skipped,\n940|            \"S\": show_skipped,\n941|            \"p\": partial(show_simple, \"passed\"),\n942|            \"E\": partial(show_simple, \"error\"),\n943|        }\n944|\n945|        lines = []\n946|        for char in self.reportchars:\n947|            action = REPORTCHAR_ACTIONS.get(char)\n948|            if action:  # skipping e.g. \"P\" (passed with output) here.\n949|                action(lines)\n950|\n951|        if lines:\n952|            self.write_sep(\"=\", \"short test summary info\")\n953|            for line in lines:\n954|                self.write_line(line)\n955|\n956|\n957|def _folded_skips(skipped):\n958|    d = {}\n959|    for event in skipped:\n960|        key = event.longrepr\n961|        assert len(key) == 3, (event, key)\n962|        keywords = getattr(event, \"keywords\", {})\n963|        # folding reports with global pytestmark variable\n964|        # this is workaround, because for now we cannot identify the scope of a skip marker\n...\n\n\n### src/_pytest/config/__init__.py\n...\n623|        is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n624|        is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n625|        if is_simple_module:\n626|            module_name, _ = os.path.splitext(fn)\n627|            yield module_name\n628|        elif is_package:\n629|            package_name = os.path.dirname(fn)\n630|            yield package_name\n631|\n632|\n633|class Config(object):\n634|    \"\"\" access to configuration values, pluginmanager and plugin hooks.  \"\"\"\n635|\n636|    def __init__(self, pluginmanager):\n637|        #: access to command line option as attributes.\n638|        #: (deprecated), use :py:func:`getoption() <_pytest.config.Config.getoption>` instead\n639|        self.option = argparse.Namespace()\n640|        from .argparsing import Parser, FILE_OR_DIR\n641|\n642|        _a = FILE_OR_DIR\n643|        self._parser = Parser(\n644|            usage=\"%%(prog)s [options] [%s] [%s] [...]\" % (_a, _a),\n645|            processopt=self._processopt,\n646|        )\n647|        #: a pluginmanager instance\n648|        self.pluginmanager = pluginmanager\n649|        self.trace = self.pluginmanager.trace.root.get(\"config\")\n650|        self.hook = self.pluginmanager.hook\n651|        self._inicache = {}\n652|        self._override_ini = ()\n653|        self._opt2dest = {}\n654|        self._cleanup = []\n655|        self.pluginmanager.register(self, \"pytestconfig\")\n656|        self._configured = False\n657|        self.invocation_dir = py.path.local()\n658|        self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))\n659|\n660|    def add_cleanup(self, func):\n661|        \"\"\" Add a function to be called when the config object gets out of\n662|        use (usually coninciding with pytest_unconfigure).\"\"\"\n663|        self._cleanup.append(func)\n664|\n665|    def _do_configure(self):\n666|        assert not self._configured\n667|        self._configured = True\n668|        self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n669|\n670|    def _ensure_unconfigure(self):\n671|        if self._configured:\n672|            self._configured = False\n673|            self.hook.pytest_unconfigure(config=self)\n674|            self.hook.pytest_configure._call_history = []\n675|        while self._cleanup:\n676|            fin = self._cleanup.pop()\n677|            fin()\n678|\n679|    def get_terminal_writer(self):\n680|        return self.pluginmanager.get_plugin(\"terminalreporter\")._tw\n681|\n682|    def pytest_cmdline_parse(self, pluginmanager, args):\n683|        try:\n684|            self.parse(args)\n685|        except UsageError:\n686|\n687|            # Handle --version and --help here in a minimal fashion.\n688|            # This gets done via helpconfig normally, but its\n689|            # pytest_cmdline_main is not called in case of errors.\n690|            if getattr(self.option, \"version\", False) or \"--version\" in args:\n691|                from _pytest.helpconfig import showversion\n692|\n693|                showversion(self)\n694|            elif (\n695|                getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n696|            ):\n697|                self._parser._getparser().print_help()\n698|                sys.stdout.write(\n699|                    \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n700|                )\n701|\n702|            raise\n703|\n704|        return self\n705|\n706|    def notify_exception(self, excinfo, option=None):\n707|        if option and getattr(option, \"fulltrace\", False):\n708|            style = \"long\"\n709|        else:\n710|            style = \"native\"\n711|        excrepr = excinfo.getrepr(\n712|            funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n713|        )\n714|        res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n715|        if not any(res):\n716|            for line in str(excrepr).split(\"\\n\"):\n717|                sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n718|                sys.stderr.flush()\n719|\n720|    def cwd_relative_nodeid(self, nodeid):\n721|        # nodeid's are relative to the rootpath, compute relative to cwd\n722|        if self.invocation_dir != self.rootdir:\n723|            fullpath = self.rootdir.join(nodeid)\n724|            nodeid = self.invocation_dir.bestrelpath(fullpath)\n725|        return nodeid\n726|\n727|    @classmethod\n728|    def fromdictargs(cls, option_dict, args):\n729|        \"\"\" constructor useable for subprocesses. \"\"\"\n730|        config = get_config(args)\n731|        config.option.__dict__.update(option_dict)\n732|        config.parse(args, addopts=False)\n733|        for x in config.option.plugins:\n734|            config.pluginmanager.consider_pluginarg(x)\n735|        return config\n736|\n737|    def _processopt(self, opt):\n738|        for name in opt._short_opts + opt._long_opts:\n739|            self._opt2dest[name] = opt.dest\n740|\n741|        if hasattr(opt, \"default\") and opt.dest:\n742|            if not hasattr(self.option, opt.dest):\n743|                setattr(self.option, opt.dest, opt.default)\n744|\n745|    @hookimpl(trylast=True)\n746|    def pytest_load_initial_conftests(self, early_config):\n747|        self.pluginmanager._set_initial_conftests(early_config.known_args_namespace)\n748|\n749|    def _initini(self, args):\n750|        ns, unknown_args = self._parser.parse_known_and_unknown_args(\n751|            args, namespace=copy.copy(self.option)\n752|        )\n753|        r = determine_setup(\n754|            ns.inifilename,\n755|            ns.file_or_dir + unknown_args,\n756|            rootdir_cmd_arg=ns.rootdir or None,\n757|            config=self,\n758|        )\n759|        self.rootdir, self.inifile, self.inicfg = r\n760|        self._parser.extra_info[\"rootdir\"] = self.rootdir\n761|        self._parser.extra_info[\"inifile\"] = self.inifile\n762|        self._parser.addini(\"addopts\", \"extra command line options\", \"args\")\n763|        self._parser.addini(\"minversion\", \"minimally required pytest version\")\n764|        self._override_ini = ns.override_ini or ()\n765|\n766|    def _consider_importhook(self, args):\n767|        \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n768|\n769|        Needs to parse the --assert=<mode> option from the commandline\n770|        and find all the installed plugins to mark them for rewriting\n771|        by the importhook.\n772|        \"\"\"\n773|        ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n774|        mode = getattr(ns, \"assertmode\", \"plain\")\n775|        if mode == \"rewrite\":\n776|            try:\n777|                hook = _pytest.assertion.install_importhook(self)\n778|            except SystemError:\n779|                mode = \"plain\"\n780|            else:\n781|                self._mark_plugins_for_rewrite(hook)\n782|        _warn_about_missing_assertion(mode)\n783|\n784|    def _mark_plugins_for_rewrite(self, hook):\n785|        \"\"\"\n786|        Given an importhook, mark for rewrite any top-level\n787|        modules or packages in the distribution package for\n788|        all pytest plugins.\n789|        \"\"\"\n790|        import pkg_resources\n791|\n792|        self.pluginmanager.rewrite_hook = hook\n793|\n794|        if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n795|            # We don't autoload from setuptools entry points, no need to continue.\n796|            return\n797|\n798|        # 'RECORD' available for plugins installed normally (pip install)\n799|        # 'SOURCES.txt' available for plugins installed in dev mode (pip install -e)\n800|        # for installed plugins 'SOURCES.txt' returns an empty list, and vice-versa\n801|        # so it shouldn't be an issue\n802|        metadata_files = \"RECORD\", \"SOURCES.txt\"\n803|\n804|        package_files = (\n805|            entry.split(\",\")[0]\n806|            for entrypoint in pkg_resources.iter_entry_points(\"pytest11\")\n807|            for metadata in metadata_files\n808|            for entry in entrypoint.dist._get_metadata(metadata)\n809|        )\n810|\n811|        for name in _iter_rewritable_modules(package_files):\n812|            hook.mark_rewrite(name)\n813|\n814|    def _validate_args(self, args, via):\n815|        \"\"\"Validate known args.\"\"\"\n816|        self._parser._config_source_hint = via\n817|        try:\n818|            self._parser.parse_known_and_unknown_args(\n819|                args, namespace=copy.copy(self.option)\n820|            )\n821|        finally:\n822|            del self._parser._config_source_hint\n823|\n824|        return args\n825|\n826|    def _preparse(self, args, addopts=True):\n827|        if addopts:\n828|            env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n829|            if len(env_addopts):\n830|                args[:] = (\n831|                    self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n832|                    + args\n833|                )\n834|        self._initini(args)\n835|        if addopts:\n836|            args[:] = (\n837|                self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n838|            )\n839|\n840|        self._checkversion()\n841|        self._consider_importhook(args)\n842|        self.pluginmanager.consider_preparse(args)\n843|        if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n844|            # Don't autoload from setuptools entry point. Only explicitly specified\n845|            # plugins are going to be loaded.\n846|            self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n847|        self.pluginmanager.consider_env()\n848|        self.known_args_namespace = ns = self._parser.parse_known_args(\n849|            args, namespace=copy.copy(self.option)\n850|        )\n851|        if self.known_args_namespace.confcutdir is None and self.inifile:\n852|            confcutdir = py.path.local(self.inifile).dirname\n853|            self.known_args_namespace.confcutdir = confcutdir\n854|        try:\n855|            self.hook.pytest_load_initial_conftests(\n856|                early_config=self, args=args, parser=self._parser\n857|            )\n858|        except ConftestImportFailure:\n859|            e = sys.exc_info()[1]\n860|            if ns.help or ns.version:\n861|                # we don't want to prevent --help/--version to work\n862|                # so just let is pass and print a warning at the end\n863|                from _pytest.warnings import _issue_warning_captured\n864|\n865|                _issue_warning_captured(\n866|                    PytestConfigWarning(\n867|                        \"could not load initial conftests: {}\".format(e.path)\n868|                    ),\n869|                    self.hook,\n870|                    stacklevel=2,\n871|                )\n872|            else:\n873|                raise\n874|\n875|    def _checkversion(self):\n876|        import pytest\n877|        from pkg_resources import parse_version\n878|\n879|        minver = self.inicfg.get(\"minversion\", None)\n880|        if minver:\n881|            if parse_version(minver) > parse_version(pytest.__version__):\n882|                raise pytest.UsageError(\n883|                    \"%s:%d: requires pytest-%s, actual pytest-%s'\"\n884|                    % (\n885|                        self.inicfg.config.path,\n886|                        self.inicfg.lineof(\"minversion\"),\n887|                        minver,\n888|                        pytest.__version__,\n889|                    )\n890|                )\n891|\n892|    def parse(self, args, addopts=True):\n893|        # parse given cmdline arguments into this config object.\n894|        assert not hasattr(\n895|            self, \"args\"\n896|        ), \"can only parse cmdline args at most once per Config object\"\n897|        self._origargs = args\n898|        self.hook.pytest_addhooks.call_historic(\n899|            kwargs=dict(pluginmanager=self.pluginmanager)\n900|        )\n901|        self._preparse(args, addopts=addopts)\n902|        # XXX deprecated hook:\n903|        self.hook.pytest_cmdline_preparse(config=self, args=args)\n904|        self._parser.after_preparse = True\n905|        try:\n906|            args = self._parser.parse_setoption(\n907|                args, self.option, namespace=self.option\n908|            )\n909|            if not args:\n910|                if self.invocation_dir == self.rootdir:\n911|                    args = self.getini(\"testpaths\")\n912|                if not args:\n913|                    args = [str(self.invocation_dir)]\n914|            self.args = args\n915|        except PrintHelp:\n916|            pass\n917|\n918|    def addinivalue_line(self, name, line):\n919|        \"\"\" add a line to an ini-file option. The option must have been\n920|        declared but might not yet be set in which case the line becomes the\n921|        the first line in its value. \"\"\"\n922|        x = self.getini(name)\n923|        assert isinstance(x, list)\n924|        x.append(line)  # modifies the cached list inline\n925|\n926|    def getini(self, name):\n927|        \"\"\" return configuration value from an :ref:`ini file <inifiles>`. If the\n928|        specified name hasn't been registered through a prior\n929|        :py:func:`parser.addini <_pytest.config.Parser.addini>`\n930|        call (usually from a plugin), a ValueError is raised. \"\"\"\n931|        try:\n932|            return self._inicache[name]\n933|        except KeyError:\n934|            self._inicache[name] = val = self._getini(name)\n935|            return val\n936|\n937|    def _getini(self, name):\n938|        try:\n939|            description, type, default = self._parser._inidict[name]\n940|        except KeyError:\n941|            raise ValueError(\"unknown configuration value: %r\" % (name,))\n942|        value = self._get_override_ini_value(name)\n943|        if value is None:\n944|            try:\n945|                value = self.inicfg[name]\n946|            except KeyError:\n947|                if default is not None:\n948|                    return default\n949|                if type is None:\n950|                    return \"\"\n951|                return []\n952|        if type == \"pathlist\":\n953|            dp = py.path.local(self.inicfg.config.path).dirpath()\n954|            values = []\n955|            for relpath in shlex.split(value):\n956|                values.append(dp.join(relpath, abs=True))\n957|            return values\n958|        elif type == \"args\":\n959|            return shlex.split(value)\n960|        elif type == \"linelist\":\n961|            return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n962|        elif type == \"bool\":\n963|            return bool(_strtobool(value.strip()))\n964|        else:\n965|            assert type is None\n966|            return value\n967|\n968|    def _getconftest_pathlist(self, name, path):\n969|        try:\n970|            mod, relroots = self.pluginmanager._rget_with_confmod(name, path)\n971|        except KeyError:\n972|            return None\n973|        modpath = py.path.local(mod.__file__).dirpath()\n974|        values = []\n975|        for relroot in relroots:\n976|            if not isinstance(relroot, py.path.local):\n977|                relroot = relroot.replace(\"/\", py.path.local.sep)\n978|                relroot = modpath.join(relroot, abs=True)\n979|            values.append(relroot)\n980|        return values\n981|\n982|    def _get_override_ini_value(self, name):\n983|        value = None\n984|        # override_ini is a list of \"ini=value\" options\n985|        # always use the last item if multiple values are set for same ini-name,\n986|        # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2\n987|        for ini_config in self._override_ini:\n988|            try:\n989|                key, user_ini_value = ini_config.split(\"=\", 1)\n990|            except ValueError:\n991|                raise UsageError(\"-o/--override-ini expects option=value style.\")\n992|            else:\n993|                if key == name:\n994|                    value = user_ini_value\n995|        return value\n996|\n997|    def getoption(self, name, default=notset, skip=False):\n998|        \"\"\" return command line option value.\n999|\n1000|        :arg name: name of the option.  You may also specify\n1001|            the literal ``--OPT`` option instead of the \"dest\" option name.\n1002|        :arg default: default value if no option of that name exists.\n1003|        :arg skip: if True raise pytest.skip if option does not exists\n1004|            or has a None value.\n1005|        \"\"\"\n1006|        name = self._opt2dest.get(name, name)\n1007|        try:\n1008|            val = getattr(self.option, name)\n1009|            if val is None and skip:\n1010|                raise AttributeError(name)\n1011|            return val\n1012|        except AttributeError:\n1013|            if default is not notset:\n1014|                return default\n1015|            if skip:\n1016|                import pytest\n1017|\n1018|                pytest.skip(\"no %r option found\" % (name,))\n1019|            raise ValueError(\"no option named %r\" % (name,))\n1020|\n1021|    def getvalue(self, name, path=None):\n1022|        \"\"\" (deprecated, use getoption()) \"\"\"\n1023|        return self.getoption(name)\n1024|\n1025|    def getvalueorskip(self, name, path=None):\n1026|        \"\"\" (deprecated, use getoption(skip=True)) \"\"\"\n1027|        return self.getoption(name, skip=True)\n1028|\n1029|\n1030|def _assertion_supported():\n1031|    try:\n1032|        assert False\n1033|    except AssertionError:\n1034|        return True\n1035|    else:\n1036|        return False\n1037|\n...\n\n\n\n\n###\n\nPlease provide the class name, function or method name, or the exact line numbers that need to be edited.\n### Examples:\n```\nfull_path1/file1.py\nline: 10\nclass: MyClass1\nline: 51\n\nfull_path2/file2.py\nfunction: MyClass2.my_method\nline: 12\n\nfull_path3/file3.py\nfunction: my_function\nline: 24\nline: 156\n```\n\nReturn just the location(s)\n", "response": ["```\nsrc/_pytest/logging.py\nline: 18\n\nsrc/_pytest/logging.py\nfunction: LoggingPlugin.__init__\nline: 395\n\nsrc/_pytest/logging.py\nfunction: LoggingPlugin._setup_cli_logging\nline: 440\n```", "```\nsrc/_pytest/logging.py\nline: 18\n\nsrc/_pytest/terminal.py\nfunction: TerminalReporter._locationline\nline: 711\n```", "```\nsrc/_pytest/logging.py\nline: 18\n\nsrc/_pytest/logging.py\nfunction: LoggingPlugin.__init__\nline: 395\n\nsrc/_pytest/logging.py\nfunction: LoggingPlugin._setup_cli_logging\nline: 440\n```", "```\nsrc/_pytest/logging.py\nline: 18\n```"], "usage": {"completion_tokens": 160, "prompt_tokens": 17276}}}
