2024-10-18 13:48:41,318 - INFO - Processing bug scikit-learn__scikit-learn-25500
2024-10-18 13:48:59,941 - INFO - ================ localize scikit-learn__scikit-learn-25500 ================
2024-10-18 13:49:00,006 - INFO - prompting with message:
Please look through the following GitHub problem description, and Repository structure and provide a list of files that one would need to edit to fix the problem.

### GitHub Problem Description ###
CalibratedClassifierCV doesn't work with `set_config(transform_output="pandas")`
### Describe the bug

CalibratedClassifierCV with isotonic regression doesn't work when we previously set `set_config(transform_output="pandas")`.
The IsotonicRegression seems to return a dataframe, which is a problem for `_CalibratedClassifier`  in `predict_proba` where it tries to put the dataframe in a numpy array row `proba[:, class_idx] = calibrator.predict(this_pred)`.

### Steps/Code to Reproduce

```python
import numpy as np
from sklearn import set_config
from sklearn.calibration import CalibratedClassifierCV
from sklearn.linear_model import SGDClassifier

set_config(transform_output="pandas")
model = CalibratedClassifierCV(SGDClassifier(), method='isotonic')
model.fit(np.arange(90).reshape(30, -1), np.arange(30) % 2)
model.predict(np.arange(90).reshape(30, -1))
```

### Expected Results

It should not crash.

### Actual Results

```
../core/model_trainer.py:306: in train_model
    cv_predictions = cross_val_predict(pipeline,
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/model_selection/_validation.py:968: in cross_val_predict
    predictions = parallel(
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:1085: in __call__
    if self.dispatch_one_batch(iterator):
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:901: in dispatch_one_batch
    self._dispatch(tasks)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:819: in _dispatch
    job = self._backend.apply_async(batch, callback=cb)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/_parallel_backends.py:208: in apply_async
    result = ImmediateResult(func)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/_parallel_backends.py:597: in __init__
    self.results = batch()
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:288: in __call__
    return [func(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:288: in <listcomp>
    return [func(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/utils/fixes.py:117: in __call__
    return self.function(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/model_selection/_validation.py:1052: in _fit_and_predict
    predictions = func(X_test)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/pipeline.py:548: in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **predict_proba_params)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/calibration.py:477: in predict_proba
    proba = calibrated_classifier.predict_proba(X)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/calibration.py:764: in predict_proba
    proba[:, class_idx] = calibrator.predict(this_pred)
E   ValueError: could not broadcast input array from shape (20,1) into shape (20,)
```

### Versions

```shell
System:
    python: 3.9.15 (main, Nov 24 2022, 14:31:59)  [GCC 11.2.0]
executable: /home/philippe/.anaconda3/envs/strategy-training/bin/python
   machine: Linux-5.15.0-57-generic-x86_64-with-glibc2.31

Python dependencies:
      sklearn: 1.2.0
          pip: 22.2.2
   setuptools: 62.3.2
        numpy: 1.23.5
        scipy: 1.9.3
       Cython: None
       pandas: 1.4.1
   matplotlib: 3.6.3
       joblib: 1.2.0
threadpoolctl: 3.1.0

Built with OpenMP: True

threadpoolctl info:
       user_api: openmp
   internal_api: openmp
         prefix: libgomp
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/scikit_learn.libs/libgomp-a34b3233.so.1.0.0
        version: None
    num_threads: 12

       user_api: blas
   internal_api: openblas
         prefix: libopenblas
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/numpy.libs/libopenblas64_p-r0-742d56dc.3.20.so
        version: 0.3.20
threading_layer: pthreads
   architecture: Haswell
    num_threads: 12

       user_api: blas
   internal_api: openblas
         prefix: libopenblas
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/scipy.libs/libopenblasp-r0-41284840.3.18.so
        version: 0.3.18
threading_layer: pthreads
   architecture: Haswell
    num_threads: 12
```



###



### Repository Structure ###
scikit-learn/
    conftest.py
    setup.py
sklearn/
    base.py
    discriminant_analysis.py
    naive_bayes.py
    conftest.py
    kernel_approximation.py
    kernel_ridge.py
    exceptions.py
    pipeline.py
    random_projection.py
    calibration.py
    multioutput.py
    _min_dependencies.py
    _distributor_init.py
    dummy.py
    isotonic.py
    __init__.py
    multiclass.py
    _config.py
    feature_selection/
        _from_model.py
        _variance_threshold.py
        _univariate_selection.py
        _mutual_info.py
        _base.py
        _rfe.py
        _sequential.py
        __init__.py
    datasets/
        _california_housing.py
        _svmlight_format_io.py
        _samples_generator.py
        _rcv1.py
        _twenty_newsgroups.py
        _olivetti_faces.py
        _arff_parser.py
        _covtype.py
        _lfw.py
        _openml.py
        _base.py
        __init__.py
        _species_distributions.py
        _kddcup99.py
        descr/
            __init__.py
        images/
            __init__.py
        data/
            __init__.py
    mixture/
        _bayesian_mixture.py
        _base.py
        _gaussian_mixture.py
        __init__.py
    neural_network/
        _multilayer_perceptron.py
        _rbm.py
        _base.py
        _stochastic_optimizers.py
        __init__.py
    preprocessing/
        _encoders.py
        _discretization.py
        _label.py
        _function_transformer.py
        _data.py
        _polynomial.py
        __init__.py
    tree/
        _export.py
        _classes.py
        _reingold_tilford.py
        __init__.py
    _build_utils/
        openmp_helpers.py
        __init__.py
        pre_build_helpers.py
    __check_build/
        __init__.py
    decomposition/
        _nmf.py
        _kernel_pca.py
        _sparse_pca.py
        _factor_analysis.py
        _dict_learning.py
        _truncated_svd.py
        _base.py
        _incremental_pca.py
        _pca.py
        _lda.py
        __init__.py
        _fastica.py
    model_selection/
        _split.py
        _plot.py
        _search_successive_halving.py
        _validation.py
        _search.py
        __init__.py
    impute/
        _iterative.py
        _knn.py
        _base.py
        __init__.py
    ensemble/
        _bagging.py
        _weight_boosting.py
        _forest.py
        _stacking.py
        _voting.py
        _gb.py
        _iforest.py
        _base.py
        _gb_losses.py
        __init__.py
        _hist_gradient_boosting/
            predictor.py
            gradient_boosting.py
            grower.py
            binning.py
            __init__.py
    cluster/
        _mean_shift.py
        _dbscan.py
        _bicluster.py
        _bisect_k_means.py
        _kmeans.py
        _agglomerative.py
        _feature_agglomeration.py
        _optics.py
        _spectral.py
        _affinity_propagation.py
        _birch.py
        __init__.py
    svm/
        _classes.py
        _base.py
        _bounds.py
        __init__.py
    cross_decomposition/
        _pls.py
        __init__.py
    semi_supervised/
        _self_training.py
        _label_propagation.py
        __init__.py
    neighbors/
        _graph.py
        _unsupervised.py
        _distance_metric.py
        _lof.py
        _nca.py
        _kde.py
        _base.py
        _nearest_centroid.py
        _regression.py
        _classification.py
        __init__.py
    compose/
        _column_transformer.py
        _target.py
        __init__.py
    externals/
        _arff.py
        conftest.py
        _lobpcg.py
        __init__.py
        _packaging/
            version.py
            _structures.py
            __init__.py
    linear_model/
        _linear_loss.py
        _passive_aggressive.py
        _theil_sen.py
        _huber.py
        _ransac.py
        _sag.py
        _least_angle.py
        _ridge.py
        _coordinate_descent.py
        _omp.py
        _perceptron.py
        _base.py
        _quantile.py
        _stochastic_gradient.py
        _bayes.py
        __init__.py
        _logistic.py
        _glm/
            glm.py
            _newton_solver.py
            __init__.py
    feature_extraction/
        image.py
        _stop_words.py
        _dict_vectorizer.py
        _hash.py
        __init__.py
        text.py
    metrics/
        _ranking.py
        _base.py
        _scorer.py
        pairwise.py
        _regression.py
        _classification.py
        __init__.py
        _pairwise_distances_reduction/
            _dispatcher.py
            __init__.py
        _plot/
            confusion_matrix.py
            base.py
            roc_curve.py
            det_curve.py
            precision_recall_curve.py
            regression.py
            __init__.py
        cluster/
            _unsupervised.py
            _bicluster.py
            _supervised.py
            __init__.py
    gaussian_process/
        _gpr.py
        _gpc.py
        __init__.py
        kernels.py
    manifold/
        _t_sne.py
        _isomap.py
        _mds.py
        _locally_linear.py
        _spectral_embedding.py
        __init__.py
    covariance/
        _graph_lasso.py
        _elliptic_envelope.py
        _shrunk_covariance.py
        _robust_covariance.py
        _empirical_covariance.py
        __init__.py
    utils/
        validation.py
        _testing.py
        estimator_checks.py
        graph.py
        _pprint.py
        random.py
        _set_output.py
        _mask.py
        _arpack.py
        _param_validation.py
        _show_versions.py
        fixes.py
        _joblib.py
        _encode.py
        _estimator_html_repr.py
        discovery.py
        deprecation.py
        metaestimators.py
        _available_if.py
        _tags.py
        extmath.py
        _bunch.py
        stats.py
        sparsefuncs.py
        _mocking.py
        _array_api.py
        __init__.py
        optimize.py
        multiclass.py
        class_weight.py
        parallel.py
    inspection/
        _permutation_importance.py
        _pd_utils.py
        _partial_dependence.py
        __init__.py
        _plot/
            partial_dependence.py
            decision_boundary.py
            __init__.py
    experimental/
        enable_iterative_imputer.py
        enable_hist_gradient_boosting.py
        enable_halving_search_cv.py
        __init__.py
    _loss/
        loss.py
        glm_distribution.py
        link.py
        __init__.py
maint_tools/
    sort_whats_new.py
    check_pxd_in_installation.py
    update_tracking_issue.py
asv_benchmarks/
    benchmarks/
        metrics.py
        manifold.py
        common.py
        svm.py
        neighbors.py
        model_selection.py
        cluster.py
        decomposition.py
        utils.py
        ensemble.py
        linear_model.py
        datasets.py
        __init__.py
doc/
    conf.py
    conftest.py
    tutorial/
        machine_learning_map/
            svg2imagemap.py
            parse_path.py
            pyparsing.py
        text_analytics/
            solutions/
                exercise_01_language_train_model.py
                exercise_02_sentiment.py
                generate_skeletons.py
            skeletons/
                exercise_01_language_train_model.py
                exercise_02_sentiment.py
            data/
                languages/
                    fetch_data.py
                movie_reviews/
                    fetch_data.py
    sphinxext/
        allow_nan_estimators.py
        github_link.py
        add_toctree_functions.py
        doi_role.py
        sphinx_issues.py
build_tools/
    update_environments_and_lock_files.py
    generate_authors_table.py
    circle/
        list_versions.py
    github/
        check_wheels.py
        vendor.py
    azure/
        get_commit_message.py
        get_selected_tests.py
benchmarks/
    bench_lasso.py
    bench_hist_gradient_boosting_categorical_only.py
    bench_20newsgroups.py
    bench_kernel_pca_solvers_time_vs_n_samples.py
    bench_covertype.py
    bench_tsne_mnist.py
    bench_online_ocsvm.py
    bench_plot_ward.py
    bench_random_projections.py
    bench_sgd_regression.py
    bench_isotonic.py
    bench_hist_gradient_boosting_higgsboson.py
    bench_plot_parallel_pairwise.py
    bench_plot_omp_lars.py
    bench_rcv1_logreg_convergence.py
    bench_plot_polynomial_kernel_approximation.py
    bench_hist_gradient_boosting_adult.py
    bench_glmnet.py
    bench_mnist.py
    bench_sparsify.py
    bench_text_vectorizers.py
    bench_plot_hierarchical.py
    bench_feature_expansions.py
    plot_tsne_mnist.py
    bench_plot_incremental_pca.py
    bench_plot_nmf.py
    bench_multilabel_metrics.py
    bench_plot_randomized_svd.py
    bench_tree.py
    bench_saga.py
    bench_kernel_pca_solvers_time_vs_n_components.py
    bench_plot_lasso_path.py
    bench_sample_without_replacement.py
    bench_isolation_forest.py
    bench_lof.py
    bench_plot_neighbors.py
    bench_hist_gradient_boosting_threading.py
    bench_plot_svd.py
    bench_plot_fastkmeans.py
    bench_hist_gradient_boosting.py
    bench_glm.py
examples/
    feature_selection/
        plot_f_test_vs_mi.py
        plot_select_from_model_diabetes.py
        plot_rfe_with_cross_validation.py
        plot_rfe_digits.py
        plot_feature_selection_pipeline.py
        plot_feature_selection.py
    datasets/
        plot_random_dataset.py
        plot_random_multilabel_dataset.py
        plot_iris_dataset.py
        plot_digits_last_image.py
    mixture/
        plot_concentration_prior.py
        plot_gmm_selection.py
        plot_gmm_init.py
        plot_gmm_sin.py
        plot_gmm_pdf.py
        plot_gmm_covariances.py
        plot_gmm.py
    neural_networks/
        plot_rbm_logistic_classification.py
        plot_mlp_training_curves.py
        plot_mlp_alpha.py
        plot_mnist_filters.py
    multioutput/
        plot_classifier_chain_yeast.py
    preprocessing/
        plot_all_scaling.py
        plot_discretization_classification.py
        plot_map_data_to_normal.py
        plot_discretization_strategies.py
        plot_scaling_importance.py
        plot_discretization.py
    tree/
        plot_cost_complexity_pruning.py
        plot_unveil_tree_structure.py
        plot_iris_dtc.py
        plot_tree_regression_multioutput.py
        plot_tree_regression.py
    decomposition/
        plot_varimax_fa.py
        plot_pca_3d.py
        plot_ica_vs_pca.py
        plot_image_denoising.py
        plot_faces_decomposition.py
        plot_incremental_pca.py
        plot_ica_blind_source_separation.py
        plot_sparse_coding.py
        plot_pca_iris.py
        plot_beta_divergence.py
        plot_kernel_pca.py
        plot_pca_vs_fa_model_selection.py
        plot_pca_vs_lda.py
    model_selection/
        plot_successive_halving_heatmap.py
        plot_learning_curve.py
        plot_det.py
        plot_confusion_matrix.py
        plot_roc.py
        plot_precision_recall.py
        plot_randomized_search.py
        plot_grid_search_refit_callable.py
        plot_permutation_tests_for_classification.py
        plot_grid_search_digits.py
        plot_cv_indices.py
        plot_cv_predict.py
        plot_grid_search_text_feature_extraction.py
        plot_underfitting_overfitting.py
        plot_roc_crossval.py
        plot_grid_search_stats.py
        plot_multi_metric_evaluation.py
        plot_validation_curve.py
        plot_likelihood_ratios.py
        plot_successive_halving_iterations.py
        plot_train_error_vs_test_error.py
        plot_nested_cross_validation_iris.py
    impute/
        plot_iterative_imputer_variants_comparison.py
        plot_missing_values.py
    ensemble/
        plot_gradient_boosting_regularization.py
        plot_isolation_forest.py
        plot_feature_transformation.py
        plot_adaboost_multiclass.py
        plot_voting_probas.py
        plot_adaboost_twoclass.py
        plot_random_forest_embedding.py
        plot_gradient_boosting_quantile.py
        plot_forest_importances.py
        plot_forest_iris.py
        plot_gradient_boosting_oob.py
        plot_gradient_boosting_early_stopping.py
        plot_adaboost_regression.py
        plot_monotonic_constraints.py
        plot_gradient_boosting_regression.py
        plot_ensemble_oob.py
        plot_random_forest_regression_multioutput.py
        plot_voting_regressor.py
        plot_adaboost_hastie_10_2.py
        plot_forest_importances_faces.py
        plot_stack_predictors.py
        plot_gradient_boosting_categorical.py
        plot_bias_variance.py
        plot_voting_decision_regions.py
    cluster/
        plot_dbscan.py
        plot_coin_segmentation.py
        plot_linkage_comparison.py
        plot_agglomerative_dendrogram.py
        plot_birch_vs_minibatchkmeans.py
        plot_digits_linkage.py
        plot_segmentation_toy.py
        plot_bisect_kmeans.py
        plot_cluster_iris.py
        plot_kmeans_silhouette_analysis.py
        plot_optics.py
        plot_affinity_propagation.py
        plot_kmeans_stability_low_dim_dense.py
        plot_ward_structured_vs_unstructured.py
        plot_feature_agglomeration_vs_univariate_selection.py
        plot_agglomerative_clustering_metrics.py
        plot_mean_shift.py
        plot_mini_batch_kmeans.py
        plot_color_quantization.py
        plot_dict_face_patches.py
        plot_kmeans_assumptions.py
        plot_digits_agglomeration.py
        plot_inductive_clustering.py
        plot_kmeans_digits.py
        plot_kmeans_plusplus.py
        plot_coin_ward_segmentation.py
        plot_face_compress.py
        plot_cluster_comparison.py
        plot_agglomerative_clustering.py
        plot_adjusted_for_chance_measures.py
    svm/
        plot_separating_hyperplane.py
        plot_separating_hyperplane_unbalanced.py
        plot_svm_kernels.py
        plot_linearsvc_support_vectors.py
        plot_svm_tie_breaking.py
        plot_svm_anova.py
        plot_svm_margin.py
        plot_svm_scale_c.py
        plot_rbf_parameters.py
        plot_oneclass.py
        plot_weighted_samples.py
        plot_custom_kernel.py
        plot_iris_svc.py
        plot_svm_nonlinear.py
        plot_svm_regression.py
    cross_decomposition/
        plot_compare_cross_decomposition.py
        plot_pcr_vs_pls.py
    bicluster/
        plot_bicluster_newsgroups.py
        plot_spectral_biclustering.py
        plot_spectral_coclustering.py
    miscellaneous/
        plot_pipeline_display.py
        plot_isotonic_regression.py
        plot_kernel_approximation.py
        plot_outlier_detection_bench.py
        plot_partial_dependence_visualization_api.py
        plot_display_object_visualization.py
        plot_set_output.py
        plot_johnson_lindenstrauss_bound.py
        plot_anomaly_comparison.py
        plot_kernel_ridge_regression.py
        plot_estimator_representation.py
        plot_multioutput_face_completion.py
        plot_roc_curve_visualization_api.py
        plot_multilabel.py
    semi_supervised/
        plot_label_propagation_digits.py
        plot_self_training_varying_threshold.py
        plot_semi_supervised_newsgroups.py
        plot_label_propagation_structure.py
        plot_label_propagation_digits_active_learning.py
        plot_semi_supervised_versus_svm_iris.py
    classification/
        plot_lda_qda.py
        plot_digits_classification.py
        plot_classification_probability.py
        plot_lda.py
        plot_classifier_comparison.py
    neighbors/
        plot_regression.py
        plot_nca_illustration.py
        approximate_nearest_neighbors.py
        plot_lof_outlier_detection.py
        plot_nearest_centroid.py
        plot_kde_1d.py
        plot_species_kde.py
        plot_digits_kde_sampling.py
        plot_classification.py
        plot_caching_nearest_neighbors.py
        plot_lof_novelty_detection.py
        plot_nca_dim_reduction.py
        plot_nca_classification.py
    kernel_approximation/
        plot_scalable_poly_kernels.py
    compose/
        plot_digits_pipe.py
        plot_column_transformer_mixed_types.py
        plot_feature_union.py
        plot_compare_reduction.py
        plot_transformed_target.py
        plot_column_transformer.py
    linear_model/
        plot_robust_fit.py
        plot_theilsen.py
        plot_lasso_model_selection.py
        plot_lasso_lars.py
        plot_lasso_dense_vs_sparse_data.py
        plot_nnls.py
        plot_ransac.py
        plot_sgd_early_stopping.py
        plot_lasso_and_elasticnet.py
        plot_elastic_net_precomputed_gram_matrix_with_weighted_samples.py
        plot_ridge_path.py
        plot_sgd_loss_functions.py
        plot_bayesian_ridge_curvefit.py
        plot_sgd_weighted_samples.py
        plot_huber_vs_ridge.py
        plot_sgd_iris.py
        plot_sgd_penalties.py
        plot_logistic_path.py
        plot_poisson_regression_non_normal_loss.py
        plot_ard.py
        plot_ols_3d.py
        plot_tweedie_regression_insurance_claims.py
        plot_sgd_comparison.py
        plot_logistic.py
        plot_logistic_multinomial.py
        plot_omp.py
        plot_sparse_logistic_regression_20newsgroups.py
        plot_sgd_separating_hyperplane.py
        plot_ols.py
        plot_polynomial_interpolation.py
        plot_ols_ridge_variance.py
        plot_sparse_logistic_regression_mnist.py
        plot_logistic_l1_l2_sparsity.py
        plot_multi_task_lasso_support.py
        plot_lasso_coordinate_descent_path.py
        plot_sgdocsvm_vs_ocsvm.py
        plot_quantile_regression.py
        plot_lasso_lars_ic.py
        plot_ridge_coeffs.py
        plot_iris_logistic.py
    calibration/
        plot_calibration_curve.py
        plot_calibration.py
        plot_compare_calibration.py
        plot_calibration_multiclass.py
    gaussian_process/
        plot_gpc_isoprobability.py
        plot_gpc_iris.py
        plot_gpr_on_structured_data.py
        plot_compare_gpr_krr.py
        plot_gpc_xor.py
        plot_gpc.py
        plot_gpr_noisy_targets.py
        plot_gpr_prior_posterior.py
        plot_gpr_noisy.py
        plot_gpr_co2.py
    manifold/
        plot_compare_methods.py
        plot_manifold_sphere.py
        plot_lle_digits.py
        plot_swissroll.py
        plot_t_sne_perplexity.py
        plot_mds.py
    release_highlights/
        plot_release_highlights_1_1_0.py
        plot_release_highlights_0_22_0.py
        plot_release_highlights_1_0_0.py
        plot_release_highlights_1_2_0.py
        plot_release_highlights_0_23_0.py
        plot_release_highlights_0_24_0.py
    covariance/
        plot_mahalanobis_distances.py
        plot_robust_vs_empirical_covariance.py
        plot_covariance_estimation.py
        plot_lw_vs_oas.py
        plot_sparse_cov.py
    text/
        plot_document_classification_20newsgroups.py
        plot_document_clustering.py
        plot_hashing_vs_dict_vectorizer.py
    applications/
        plot_species_distribution_modeling.py
        plot_out_of_core_classification.py
        plot_digits_denoising.py
        plot_model_complexity_influence.py
        plot_prediction_latency.py
        plot_stock_market.py
        plot_tomography_l1_reconstruction.py
        svm_gui.py
        plot_cyclical_feature_engineering.py
        wikipedia_principal_eigenvector.py
        plot_face_recognition.py
        plot_outlier_detection_wine.py
        plot_topics_extraction_with_nmf_lda.py
    inspection/
        plot_linear_model_coefficient_interpretation.py
        plot_causal_interpretation.py
        plot_partial_dependence.py
        plot_permutation_importance_multicollinear.py
        plot_permutation_importance.py
    exercises/
        plot_cv_diabetes.py
        plot_iris_exercise.py
        plot_cv_digits.py
        plot_digits_classification_exercise.py

###

Please only provide the full path and return at most 5 files.
The returned files should be separated by new lines ordered by most to least important and wrapped with ```
For example:
```
file1.py
file2.py
```
2024-10-18 13:49:00,007 - INFO - ================================================================================
2024-10-18 13:49:00,091 - INFO - Creating API request
2024-10-18 13:49:01,183 - INFO - API response ChatCompletion(id='chatcmpl-AJoC4OT9c9jMmupxCB79QCu7oovN2', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```\nsklearn/calibration.py\nsklearn/isotonic.py\nsklearn/_config.py\nsklearn/utils/_set_output.py\nsklearn/utils/validation.py\n```', refusal=None, role='assistant', function_call=None, tool_calls=None))], created=1729284540, model='gpt-4o-2024-05-13', object='chat.completion', service_tier=None, system_fingerprint='fp_939d701e6c', usage=CompletionUsage(completion_tokens=37, prompt_tokens=6286, total_tokens=6323, completion_tokens_details=CompletionTokensDetails(audio_tokens=None, reasoning_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0)))
2024-10-18 13:49:01,188 - INFO - ```
sklearn/calibration.py
sklearn/isotonic.py
sklearn/_config.py
sklearn/utils/_set_output.py
sklearn/utils/validation.py
```
2024-10-18 13:49:02,222 - INFO - prompting with message:

Please look through the following GitHub Problem Description, and the Skeleton of Relevant Files.
Identify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.
For each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.

### GitHub Problem Description ###
CalibratedClassifierCV doesn't work with `set_config(transform_output="pandas")`
### Describe the bug

CalibratedClassifierCV with isotonic regression doesn't work when we previously set `set_config(transform_output="pandas")`.
The IsotonicRegression seems to return a dataframe, which is a problem for `_CalibratedClassifier`  in `predict_proba` where it tries to put the dataframe in a numpy array row `proba[:, class_idx] = calibrator.predict(this_pred)`.

### Steps/Code to Reproduce

```python
import numpy as np
from sklearn import set_config
from sklearn.calibration import CalibratedClassifierCV
from sklearn.linear_model import SGDClassifier

set_config(transform_output="pandas")
model = CalibratedClassifierCV(SGDClassifier(), method='isotonic')
model.fit(np.arange(90).reshape(30, -1), np.arange(30) % 2)
model.predict(np.arange(90).reshape(30, -1))
```

### Expected Results

It should not crash.

### Actual Results

```
../core/model_trainer.py:306: in train_model
    cv_predictions = cross_val_predict(pipeline,
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/model_selection/_validation.py:968: in cross_val_predict
    predictions = parallel(
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:1085: in __call__
    if self.dispatch_one_batch(iterator):
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:901: in dispatch_one_batch
    self._dispatch(tasks)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:819: in _dispatch
    job = self._backend.apply_async(batch, callback=cb)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/_parallel_backends.py:208: in apply_async
    result = ImmediateResult(func)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/_parallel_backends.py:597: in __init__
    self.results = batch()
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:288: in __call__
    return [func(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:288: in <listcomp>
    return [func(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/utils/fixes.py:117: in __call__
    return self.function(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/model_selection/_validation.py:1052: in _fit_and_predict
    predictions = func(X_test)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/pipeline.py:548: in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **predict_proba_params)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/calibration.py:477: in predict_proba
    proba = calibrated_classifier.predict_proba(X)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/calibration.py:764: in predict_proba
    proba[:, class_idx] = calibrator.predict(this_pred)
E   ValueError: could not broadcast input array from shape (20,1) into shape (20,)
```

### Versions

```shell
System:
    python: 3.9.15 (main, Nov 24 2022, 14:31:59)  [GCC 11.2.0]
executable: /home/philippe/.anaconda3/envs/strategy-training/bin/python
   machine: Linux-5.15.0-57-generic-x86_64-with-glibc2.31

Python dependencies:
      sklearn: 1.2.0
          pip: 22.2.2
   setuptools: 62.3.2
        numpy: 1.23.5
        scipy: 1.9.3
       Cython: None
       pandas: 1.4.1
   matplotlib: 3.6.3
       joblib: 1.2.0
threadpoolctl: 3.1.0

Built with OpenMP: True

threadpoolctl info:
       user_api: openmp
   internal_api: openmp
         prefix: libgomp
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/scikit_learn.libs/libgomp-a34b3233.so.1.0.0
        version: None
    num_threads: 12

       user_api: blas
   internal_api: openblas
         prefix: libopenblas
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/numpy.libs/libopenblas64_p-r0-742d56dc.3.20.so
        version: 0.3.20
threading_layer: pthreads
   architecture: Haswell
    num_threads: 12

       user_api: blas
   internal_api: openblas
         prefix: libopenblas
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/scipy.libs/libopenblasp-r0-41284840.3.18.so
        version: 0.3.18
threading_layer: pthreads
   architecture: Haswell
    num_threads: 12
```



###



### Skeleton of Relevant Files ###

### File: sklearn/calibration.py ###
```python


class CalibratedClassifierCV(ClassifierMixin, MetaEstimatorMixin, BaseEstimator):

    _parameter_constraints: dict = {
        "estimator": [
            HasMethods(["fit", "predict_proba"]),
            HasMethods(["fit", "decision_function"]),
            None,
        ],
        "method": [StrOptions({"isotonic", "sigmoid"})],
        "cv": ["cv_object", StrOptions({"prefit"})],
        "n_jobs": [Integral, None],
        "ensemble": ["boolean"],
        "base_estimator": [
            HasMethods(["fit", "predict_proba"]),
            HasMethods(["fit", "decision_function"]),
            None,
            Hidden(StrOptions({"deprecated"})),
        ],
    }

    def __init__(
        self,
        estimator=None,
        *,
        method="sigmoid",
        cv=None,
        n_jobs=None,
        ensemble=True,
        base_estimator="deprecated",
    ):
...
    def fit(self, X, y, sample_weight=None, **fit_params):
...
    def predict_proba(self, X):
...
    def predict(self, X):
...
    def _more_tags(self):
...

def _fit_classifier_calibrator_pair(
    estimator,
    X,
    y,
    train,
    test,
    supports_sw,
    method,
    classes,
    sample_weight=None,
    **fit_params,
):
...

def _get_prediction_method(clf):
...

def _compute_predictions(pred_method, method_name, X, n_classes):
...

def _fit_calibrator(clf, predictions, y, classes, method, sample_weight=None):
...

class _CalibratedClassifier:

    def __init__(self, estimator, calibrators, *, classes, method="sigmoid"):
...
    def predict_proba(self, X):
...

def _sigmoid_calibration(predictions, y, sample_weight=None):
...

class _SigmoidCalibration(RegressorMixin, BaseEstimator):

    def fit(self, X, y, sample_weight=None):
...
    def predict(self, T):
...

def calibration_curve(
    y_true,
    y_prob,
    *,
    pos_label=None,
    normalize="deprecated",
    n_bins=5,
    strategy="uniform",
):
...

class CalibrationDisplay:

    def __init__(
        self, prob_true, prob_pred, y_prob, *, estimator_name=None, pos_label=None
    ):
...
    def plot(self, *, ax=None, name=None, ref_line=True, **kwargs):
...
    @classmethod
    def from_estimator(
        cls,
        estimator,
        X,
        y,
        *,
        n_bins=5,
        strategy="uniform",
        pos_label=None,
        name=None,
        ref_line=True,
        ax=None,
        **kwargs,
    ):
...
    @classmethod
    def from_predictions(
        cls,
        y_true,
        y_prob,
        *,
        n_bins=5,
        strategy="uniform",
        pos_label=None,
        name=None,
        ref_line=True,
        ax=None,
        **kwargs,
    ):

```

### File: sklearn/isotonic.py ###
```python
# Authors: Fabian Pedregosa <fabian@fseoane.net>
#          Alexandre Gramfort <alexandre.gramfort@inria.fr>
#          Nelle Varoquaux <nelle.varoquaux@gmail.com>
# License: BSD 3 clause



__all__ = ["check_increasing", "isotonic_regression", "IsotonicRegression"]


def check_increasing(x, y):
...

def isotonic_regression(
    y, *, sample_weight=None, y_min=None, y_max=None, increasing=True
):
...

class IsotonicRegression(RegressorMixin, TransformerMixin, BaseEstimator):

    _parameter_constraints: dict = {
        "y_min": [Interval(Real, None, None, closed="both"), None],
        "y_max": [Interval(Real, None, None, closed="both"), None],
        "increasing": ["boolean", StrOptions({"auto"})],
        "out_of_bounds": [StrOptions({"nan", "clip", "raise"})],
    }

    def __init__(self, *, y_min=None, y_max=None, increasing=True, out_of_bounds="nan"):
...
    def _check_input_data_shape(self, X):
...
    def _build_f(self, X, y):
...
    def _build_y(self, X, y, sample_weight, trim_duplicates=True):
...
    def fit(self, X, y, sample_weight=None):
...
    def transform(self, T):
...
    def predict(self, T):
...
    # We implement get_feature_names_out here instead of using
    # `ClassNamePrefixFeaturesOutMixin`` because `input_features` are ignored.
    # `input_features` are ignored because `IsotonicRegression` accepts 1d
    # arrays and the semantics of `feature_names_in_` are not clear for 1d arrays.
    def get_feature_names_out(self, input_features=None):
...
    def __getstate__(self):
...
    def __setstate__(self, state):
...
    def _more_tags(self):

```

### File: sklearn/_config.py ###
```python

_global_config = {
    "assume_finite": bool(os.environ.get("SKLEARN_ASSUME_FINITE", False)),
    "working_memory": int(os.environ.get("SKLEARN_WORKING_MEMORY", 1024)),
    "print_changed_only": True,
    "display": "diagram",
    "pairwise_dist_chunk_size": int(
        os.environ.get("SKLEARN_PAIRWISE_DIST_CHUNK_SIZE", 256)
    ),
    "enable_cython_pairwise_dist": True,
    "array_api_dispatch": False,
    "transform_output": "default",
}
_threadlocal = threading.local()


def _get_threadlocal_config():
...

def get_config():
...

def set_config(
    assume_finite=None,
    working_memory=None,
    print_changed_only=None,
    display=None,
    pairwise_dist_chunk_size=None,
    enable_cython_pairwise_dist=None,
    array_api_dispatch=None,
    transform_output=None,
):
...

@contextmanager
def config_context(
    *,
    assume_finite=None,
    working_memory=None,
    print_changed_only=None,
    display=None,
    pairwise_dist_chunk_size=None,
    enable_cython_pairwise_dist=None,
    array_api_dispatch=None,
    transform_output=None,
):

```


###

Please provide the complete set of locations as either a class name, a function name, or a variable name.
Note that if you include a class, you do not need to list its specific methods.
You can include either the entire class or don't include the class name and instead include specific methods in the class.
### Examples:
```
full_path1/file1.py
function: my_function_1
class: MyClass1
function: MyClass2.my_method

full_path2/file2.py
variable: my_var
function: MyClass3.my_method

full_path3/file3.py
function: my_function_2
function: my_function_3
function: MyClass4.my_method_1
class: MyClass5
```

Return just the locations.

2024-10-18 13:49:02,222 - INFO - ================================================================================
2024-10-18 13:49:02,280 - INFO - Creating API request
2024-10-18 13:49:03,739 - INFO - API response ChatCompletion(id='chatcmpl-AJoC68O6WXugvJ3I9nvXrFx86A1SZ', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```\nsklearn/calibration.py\nclass: CalibratedClassifierCV\nfunction: _fit_classifier_calibrator_pair\nfunction: _get_prediction_method\nfunction: _compute_predictions\nfunction: _fit_calibrator\nclass: _CalibratedClassifier\n\nsklearn/isotonic.py\nclass: IsotonicRegression\n\nsklearn/_config.py\nvariable: _global_config\nfunction: set_config\n```', refusal=None, role='assistant', function_call=None, tool_calls=None))], created=1729284542, model='gpt-4o-2024-05-13', object='chat.completion', service_tier=None, system_fingerprint='fp_568f3bfff7', usage=CompletionUsage(completion_tokens=85, prompt_tokens=2920, total_tokens=3005, completion_tokens_details=CompletionTokensDetails(audio_tokens=None, reasoning_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0)))
2024-10-18 13:49:03,739 - INFO - ==== raw output ====
2024-10-18 13:49:03,739 - INFO - ```
sklearn/calibration.py
class: CalibratedClassifierCV
function: _fit_classifier_calibrator_pair
function: _get_prediction_method
function: _compute_predictions
function: _fit_calibrator
class: _CalibratedClassifier

sklearn/isotonic.py
class: IsotonicRegression

sklearn/_config.py
variable: _global_config
function: set_config
```
2024-10-18 13:49:03,739 - INFO - ================================================================================
2024-10-18 13:49:03,739 - INFO - ==== extracted locs ====
2024-10-18 13:49:03,739 - INFO - ['class: CalibratedClassifierCV\nfunction: _fit_classifier_calibrator_pair\nfunction: _get_prediction_method\nfunction: _compute_predictions\nfunction: _fit_calibrator\nclass: _CalibratedClassifier']
2024-10-18 13:49:03,739 - INFO - ['class: IsotonicRegression']
2024-10-18 13:49:03,739 - INFO - ['variable: _global_config\nfunction: set_config']
2024-10-18 13:49:03,739 - INFO - ================================================================================
2024-10-18 13:49:04,592 - INFO - prompting with message:

Please review the following GitHub problem description, and relevant files, and provide a set of locations that need to be edited to fix the issue.
The locations can be specified as class names, function or method names, or exact line numbers that require modification.

### GitHub Problem Description ###
CalibratedClassifierCV doesn't work with `set_config(transform_output="pandas")`
### Describe the bug

CalibratedClassifierCV with isotonic regression doesn't work when we previously set `set_config(transform_output="pandas")`.
The IsotonicRegression seems to return a dataframe, which is a problem for `_CalibratedClassifier`  in `predict_proba` where it tries to put the dataframe in a numpy array row `proba[:, class_idx] = calibrator.predict(this_pred)`.

### Steps/Code to Reproduce

```python
import numpy as np
from sklearn import set_config
from sklearn.calibration import CalibratedClassifierCV
from sklearn.linear_model import SGDClassifier

set_config(transform_output="pandas")
model = CalibratedClassifierCV(SGDClassifier(), method='isotonic')
model.fit(np.arange(90).reshape(30, -1), np.arange(30) % 2)
model.predict(np.arange(90).reshape(30, -1))
```

### Expected Results

It should not crash.

### Actual Results

```
../core/model_trainer.py:306: in train_model
    cv_predictions = cross_val_predict(pipeline,
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/model_selection/_validation.py:968: in cross_val_predict
    predictions = parallel(
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:1085: in __call__
    if self.dispatch_one_batch(iterator):
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:901: in dispatch_one_batch
    self._dispatch(tasks)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:819: in _dispatch
    job = self._backend.apply_async(batch, callback=cb)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/_parallel_backends.py:208: in apply_async
    result = ImmediateResult(func)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/_parallel_backends.py:597: in __init__
    self.results = batch()
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:288: in __call__
    return [func(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/joblib/parallel.py:288: in <listcomp>
    return [func(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/utils/fixes.py:117: in __call__
    return self.function(*args, **kwargs)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/model_selection/_validation.py:1052: in _fit_and_predict
    predictions = func(X_test)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/pipeline.py:548: in predict_proba
    return self.steps[-1][1].predict_proba(Xt, **predict_proba_params)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/calibration.py:477: in predict_proba
    proba = calibrated_classifier.predict_proba(X)
../../../../.anaconda3/envs/strategy-training/lib/python3.9/site-packages/sklearn/calibration.py:764: in predict_proba
    proba[:, class_idx] = calibrator.predict(this_pred)
E   ValueError: could not broadcast input array from shape (20,1) into shape (20,)
```

### Versions

```shell
System:
    python: 3.9.15 (main, Nov 24 2022, 14:31:59)  [GCC 11.2.0]
executable: /home/philippe/.anaconda3/envs/strategy-training/bin/python
   machine: Linux-5.15.0-57-generic-x86_64-with-glibc2.31

Python dependencies:
      sklearn: 1.2.0
          pip: 22.2.2
   setuptools: 62.3.2
        numpy: 1.23.5
        scipy: 1.9.3
       Cython: None
       pandas: 1.4.1
   matplotlib: 3.6.3
       joblib: 1.2.0
threadpoolctl: 3.1.0

Built with OpenMP: True

threadpoolctl info:
       user_api: openmp
   internal_api: openmp
         prefix: libgomp
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/scikit_learn.libs/libgomp-a34b3233.so.1.0.0
        version: None
    num_threads: 12

       user_api: blas
   internal_api: openblas
         prefix: libopenblas
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/numpy.libs/libopenblas64_p-r0-742d56dc.3.20.so
        version: 0.3.20
threading_layer: pthreads
   architecture: Haswell
    num_threads: 12

       user_api: blas
   internal_api: openblas
         prefix: libopenblas
       filepath: /home/philippe/.anaconda3/envs/strategy-training/lib/python3.9/site-packages/scipy.libs/libopenblasp-r0-41284840.3.18.so
        version: 0.3.18
threading_layer: pthreads
   architecture: Haswell
    num_threads: 12
```



###



### sklearn/calibration.py
...
45|    check_is_fitted,
46|)
47|from .utils import _safe_indexing
48|from .isotonic import IsotonicRegression
49|from .svm import LinearSVC
50|from .model_selection import check_cv, cross_val_predict
51|from .metrics._base import _check_pos_label_consistency
52|from .metrics._plot.base import _get_response
53|
54|
55|class CalibratedClassifierCV(ClassifierMixin, MetaEstimatorMixin, BaseEstimator):
56|    """Probability calibration with isotonic regression or logistic regression.
57|
58|    This class uses cross-validation to both estimate the parameters of a
59|    classifier and subsequently calibrate a classifier. With default
60|    `ensemble=True`, for each cv split it
61|    fits a copy of the base estimator to the training subset, and calibrates it
62|    using the testing subset. For prediction, predicted probabilities are
63|    averaged across these individual calibrated classifiers. When
64|    `ensemble=False`, cross-validation is used to obtain unbiased predictions,
65|    via :func:`~sklearn.model_selection.cross_val_predict`, which are then
66|    used for calibration. For prediction, the base estimator, trained using all
67|    the data, is used. This is the method implemented when `probabilities=True`
68|    for :mod:`sklearn.svm` estimators.
69|
70|    Already fitted classifiers can be calibrated via the parameter
71|    `cv="prefit"`. In this case, no cross-validation is used and all provided
72|    data is used for calibration. The user has to take care manually that data
73|    for model fitting and calibration are disjoint.
74|
75|    The calibration is based on the :term:`decision_function` method of the
76|    `estimator` if it exists, else on :term:`predict_proba`.
77|
78|    Read more in the :ref:`User Guide <calibration>`.
79|
80|    Parameters
81|    ----------
82|    estimator : estimator instance, default=None
83|        The classifier whose output need to be calibrated to provide more
84|        accurate `predict_proba` outputs. The default classifier is
85|        a :class:`~sklearn.svm.LinearSVC`.
86|
87|        .. versionadded:: 1.2
88|
89|    method : {'sigmoid', 'isotonic'}, default='sigmoid'
90|        The method to use for calibration. Can be 'sigmoid' which
91|        corresponds to Platt's method (i.e. a logistic regression model) or
92|        'isotonic' which is a non-parametric approach. It is not advised to
93|        use isotonic calibration with too few calibration samples
94|        ``(<<1000)`` since it tends to overfit.
95|
96|    cv : int, cross-validation generator, iterable or "prefit", \
97|            default=None
98|        Determines the cross-validation splitting strategy.
99|        Possible inputs for cv are:
100|
101|        - None, to use the default 5-fold cross-validation,
102|        - integer, to specify the number of folds.
103|        - :term:`CV splitter`,
104|        - An iterable yielding (train, test) splits as arrays of indices.
105|
106|        For integer/None inputs, if ``y`` is binary or multiclass,
107|        :class:`~sklearn.model_selection.StratifiedKFold` is used. If ``y`` is
108|        neither binary nor multiclass, :class:`~sklearn.model_selection.KFold`
109|        is used.
110|
111|        Refer to the :ref:`User Guide <cross_validation>` for the various
112|        cross-validation strategies that can be used here.
113|
114|        If "prefit" is passed, it is assumed that `estimator` has been
115|        fitted already and all data is used for calibration.
116|
117|        .. versionchanged:: 0.22
118|            ``cv`` default value if None changed from 3-fold to 5-fold.
119|
120|    n_jobs : int, default=None
121|        Number of jobs to run in parallel.
122|        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context.
123|        ``-1`` means using all processors.
124|
125|        Base estimator clones are fitted in parallel across cross-validation
126|        iterations. Therefore parallelism happens only when `cv != "prefit"`.
127|
128|        See :term:`Glossary <n_jobs>` for more details.
129|
130|        .. versionadded:: 0.24
131|
132|    ensemble : bool, default=True
133|        Determines how the calibrator is fitted when `cv` is not `'prefit'`.
134|        Ignored if `cv='prefit'`.
135|
136|        If `True`, the `estimator` is fitted using training data, and
137|        calibrated using testing data, for each `cv` fold. The final estimator
138|        is an ensemble of `n_cv` fitted classifier and calibrator pairs, where
139|        `n_cv` is the number of cross-validation folds. The output is the
140|        average predicted probabilities of all pairs.
141|
142|        If `False`, `cv` is used to compute unbiased predictions, via
143|        :func:`~sklearn.model_selection.cross_val_predict`, which are then
144|        used for calibration. At prediction time, the classifier used is the
145|        `estimator` trained on all the data.
146|        Note that this method is also internally implemented  in
147|        :mod:`sklearn.svm` estimators with the `probabilities=True` parameter.
148|
149|        .. versionadded:: 0.24
150|
151|    base_estimator : estimator instance
152|        This parameter is deprecated. Use `estimator` instead.
153|
154|        .. deprecated:: 1.2
155|           The parameter `base_estimator` is deprecated in 1.2 and will be
156|           removed in 1.4. Use `estimator` instead.
157|
158|    Attributes
159|    ----------
160|    classes_ : ndarray of shape (n_classes,)
161|        The class labels.
162|
163|    n_features_in_ : int
164|        Number of features seen during :term:`fit`. Only defined if the
165|        underlying estimator exposes such an attribute when fit.
166|
167|        .. versionadded:: 0.24
168|
169|    feature_names_in_ : ndarray of shape (`n_features_in_`,)
170|        Names of features seen during :term:`fit`. Only defined if the
171|        underlying estimator exposes such an attribute when fit.
172|
173|        .. versionadded:: 1.0
174|
175|    calibrated_classifiers_ : list (len() equal to cv or 1 if `cv="prefit"` \
176|            or `ensemble=False`)
177|        The list of classifier and calibrator pairs.
178|
179|        - When `cv="prefit"`, the fitted `estimator` and fitted
180|          calibrator.
181|        - When `cv` is not "prefit" and `ensemble=True`, `n_cv` fitted
182|          `estimator` and calibrator pairs. `n_cv` is the number of
183|          cross-validation folds.
184|        - When `cv` is not "prefit" and `ensemble=False`, the `estimator`,
185|          fitted on all the data, and fitted calibrator.
186|
187|        .. versionchanged:: 0.24
188|            Single calibrated classifier case when `ensemble=False`.
189|
190|    See Also
191|    --------
192|    calibration_curve : Compute true and predicted probabilities
193|        for a calibration curve.
194|
195|    References
196|    ----------
197|    .. [1] Obtaining calibrated probability estimates from decision trees
198|           and naive Bayesian classifiers, B. Zadrozny & C. Elkan, ICML 2001
199|
200|    .. [2] Transforming Classifier Scores into Accurate Multiclass
201|           Probability Estimates, B. Zadrozny & C. Elkan, (KDD 2002)
202|
203|    .. [3] Probabilistic Outputs for Support Vector Machines and Comparisons to
204|           Regularized Likelihood Methods, J. Platt, (1999)
205|
206|    .. [4] Predicting Good Probabilities with Supervised Learning,
207|           A. Niculescu-Mizil & R. Caruana, ICML 2005
208|
209|    Examples
210|    --------
211|    >>> from sklearn.datasets import make_classification
212|    >>> from sklearn.naive_bayes import GaussianNB
213|    >>> from sklearn.calibration import CalibratedClassifierCV
214|    >>> X, y = make_classification(n_samples=100, n_features=2,
215|    ...                            n_redundant=0, random_state=42)
216|    >>> base_clf = GaussianNB()
217|    >>> calibrated_clf = CalibratedClassifierCV(base_clf, cv=3)
218|    >>> calibrated_clf.fit(X, y)
219|    CalibratedClassifierCV(...)
220|    >>> len(calibrated_clf.calibrated_classifiers_)
221|    3
222|    >>> calibrated_clf.predict_proba(X)[:5, :]
223|    array([[0.110..., 0.889...],
224|           [0.072..., 0.927...],
225|           [0.928..., 0.071...],
226|           [0.928..., 0.071...],
227|           [0.071..., 0.928...]])
228|    >>> from sklearn.model_selection import train_test_split
229|    >>> X, y = make_classification(n_samples=100, n_features=2,
230|    ...                            n_redundant=0, random_state=42)
231|    >>> X_train, X_calib, y_train, y_calib = train_test_split(
232|    ...        X, y, random_state=42
233|    ... )
234|    >>> base_clf = GaussianNB()
235|    >>> base_clf.fit(X_train, y_train)
236|    GaussianNB()
237|    >>> calibrated_clf = CalibratedClassifierCV(base_clf, cv="prefit")
238|    >>> calibrated_clf.fit(X_calib, y_calib)
239|    CalibratedClassifierCV(...)
240|    >>> len(calibrated_clf.calibrated_classifiers_)
241|    1
242|    >>> calibrated_clf.predict_proba([[-0.5, 0.5]])
243|    array([[0.936..., 0.063...]])
244|    """
245|
246|    _parameter_constraints: dict = {
247|        "estimator": [
248|            HasMethods(["fit", "predict_proba"]),
249|            HasMethods(["fit", "decision_function"]),
250|            None,
251|        ],
252|        "method": [StrOptions({"isotonic", "sigmoid"})],
253|        "cv": ["cv_object", StrOptions({"prefit"})],
254|        "n_jobs": [Integral, None],
255|        "ensemble": ["boolean"],
256|        "base_estimator": [
257|            HasMethods(["fit", "predict_proba"]),
258|            HasMethods(["fit", "decision_function"]),
259|            None,
260|            Hidden(StrOptions({"deprecated"})),
261|        ],
262|    }
263|
264|    def __init__(
265|        self,
266|        estimator=None,
267|        *,
268|        method="sigmoid",
269|        cv=None,
270|        n_jobs=None,
271|        ensemble=True,
272|        base_estimator="deprecated",
273|    ):
274|        self.estimator = estimator
275|        self.method = method
276|        self.cv = cv
277|        self.n_jobs = n_jobs
278|        self.ensemble = ensemble
279|        self.base_estimator = base_estimator
280|
281|    def fit(self, X, y, sample_weight=None, **fit_params):
282|        """Fit the calibrated model.
283|
284|        Parameters
285|        ----------
286|        X : array-like of shape (n_samples, n_features)
287|            Training data.
288|
289|        y : array-like of shape (n_samples,)
290|            Target values.
291|
292|        sample_weight : array-like of shape (n_samples,), default=None
293|            Sample weights. If None, then samples are equally weighted.
294|
295|        **fit_params : dict
296|            Parameters to pass to the `fit` method of the underlying
297|            classifier.
298|
299|        Returns
300|        -------
301|        self : object
302|            Returns an instance of self.
303|        """
304|        self._validate_params()
305|
306|        check_classification_targets(y)
307|        X, y = indexable(X, y)
308|        if sample_weight is not None:
309|            sample_weight = _check_sample_weight(sample_weight, X)
310|
311|        for sample_aligned_params in fit_params.values():
312|            check_consistent_length(y, sample_aligned_params)
313|
314|        # TODO(1.4): Remove when base_estimator is removed
315|        if self.base_estimator != "deprecated":
316|            if self.estimator is not None:
317|                raise ValueError(
318|                    "Both `base_estimator` and `estimator` are set. Only set "
319|                    "`estimator` since `base_estimator` is deprecated."
320|                )
321|            warnings.warn(
322|                "`base_estimator` was renamed to `estimator` in version 1.2 and "
323|                "will be removed in 1.4.",
324|                FutureWarning,
325|            )
326|            estimator = self.base_estimator
327|        else:
328|            estimator = self.estimator
329|
330|        if estimator is None:
331|            # we want all classifiers that don't expose a random_state
332|            # to be deterministic (and we don't want to expose this one).
333|            estimator = LinearSVC(random_state=0)
334|
335|        self.calibrated_classifiers_ = []
336|        if self.cv == "prefit":
337|            # `classes_` should be consistent with that of estimator
338|            check_is_fitted(self.estimator, attributes=["classes_"])
339|            self.classes_ = self.estimator.classes_
340|
341|            pred_method, method_name = _get_prediction_method(estimator)
342|            n_classes = len(self.classes_)
343|            predictions = _compute_predictions(pred_method, method_name, X, n_classes)
344|
345|            calibrated_classifier = _fit_calibrator(
346|                estimator,
347|                predictions,
348|                y,
349|                self.classes_,
350|                self.method,
351|                sample_weight,
352|            )
353|            self.calibrated_classifiers_.append(calibrated_classifier)
354|        else:
355|            # Set `classes_` using all `y`
356|            label_encoder_ = LabelEncoder().fit(y)
357|            self.classes_ = label_encoder_.classes_
358|            n_classes = len(self.classes_)
359|
360|            # sample_weight checks
361|            fit_parameters = signature(estimator.fit).parameters
362|            supports_sw = "sample_weight" in fit_parameters
363|            if sample_weight is not None and not supports_sw:
364|                estimator_name = type(estimator).__name__
365|                warnings.warn(
366|                    f"Since {estimator_name} does not appear to accept sample_weight, "
367|                    "sample weights will only be used for the calibration itself. This "
368|                    "can be caused by a limitation of the current scikit-learn API. "
369|                    "See the following issue for more details: "
370|                    "https://github.com/scikit-learn/scikit-learn/issues/21134. Be "
371|                    "warned that the result of the calibration is likely to be "
372|                    "incorrect."
373|                )
374|
375|            # Check that each cross-validation fold can have at least one
376|            # example per class
377|            if isinstance(self.cv, int):
378|                n_folds = self.cv
379|            elif hasattr(self.cv, "n_splits"):
380|                n_folds = self.cv.n_splits
381|            else:
382|                n_folds = None
383|            if n_folds and np.any(
384|                [np.sum(y == class_) < n_folds for class_ in self.classes_]
385|            ):
386|                raise ValueError(
387|                    f"Requesting {n_folds}-fold "
388|                    "cross-validation but provided less than "
389|                    f"{n_folds} examples for at least one class."
390|                )
391|            cv = check_cv(self.cv, y, classifier=True)
392|
393|            if self.ensemble:
394|                parallel = Parallel(n_jobs=self.n_jobs)
395|                self.calibrated_classifiers_ = parallel(
396|                    delayed(_fit_classifier_calibrator_pair)(
397|                        clone(estimator),
398|                        X,
399|                        y,
400|                        train=train,
401|                        test=test,
402|                        method=self.method,
403|                        classes=self.classes_,
404|                        supports_sw=supports_sw,
405|                        sample_weight=sample_weight,
406|                        **fit_params,
407|                    )
408|                    for train, test in cv.split(X, y)
409|                )
410|            else:
411|                this_estimator = clone(estimator)
412|                _, method_name = _get_prediction_method(this_estimator)
413|                fit_params = (
414|                    {"sample_weight": sample_weight}
415|                    if sample_weight is not None and supports_sw
416|                    else None
417|                )
418|                pred_method = partial(
419|                    cross_val_predict,
420|                    estimator=this_estimator,
421|                    X=X,
422|                    y=y,
423|                    cv=cv,
424|                    method=method_name,
425|                    n_jobs=self.n_jobs,
426|                    fit_params=fit_params,
427|                )
428|                predictions = _compute_predictions(
429|                    pred_method, method_name, X, n_classes
430|                )
431|
432|                if sample_weight is not None and supports_sw:
433|                    this_estimator.fit(X, y, sample_weight=sample_weight)
434|                else:
435|                    this_estimator.fit(X, y)
436|                # Note: Here we don't pass on fit_params because the supported
437|                # calibrators don't support fit_params anyway
438|                calibrated_classifier = _fit_calibrator(
439|                    this_estimator,
440|                    predictions,
441|                    y,
442|                    self.classes_,
443|                    self.method,
444|                    sample_weight,
445|                )
446|                self.calibrated_classifiers_.append(calibrated_classifier)
447|
448|        first_clf = self.calibrated_classifiers_[0].estimator
449|        if hasattr(first_clf, "n_features_in_"):
450|            self.n_features_in_ = first_clf.n_features_in_
451|        if hasattr(first_clf, "feature_names_in_"):
452|            self.feature_names_in_ = first_clf.feature_names_in_
453|        return self
454|
455|    def predict_proba(self, X):
456|        """Calibrated probabilities of classification.
457|
458|        This function returns calibrated probabilities of classification
459|        according to each class on an array of test vectors X.
460|
461|        Parameters
462|        ----------
463|        X : array-like of shape (n_samples, n_features)
464|            The samples, as accepted by `estimator.predict_proba`.
465|
466|        Returns
467|        -------
468|        C : ndarray of shape (n_samples, n_classes)
469|            The predicted probas.
470|        """
471|        check_is_fitted(self)
472|        # Compute the arithmetic mean of the predictions of the calibrated
473|        # classifiers
474|        mean_proba = np.zeros((_num_samples(X), len(self.classes_)))
475|        for calibrated_classifier in self.calibrated_classifiers_:
476|            proba = calibrated_classifier.predict_proba(X)
477|            mean_proba += proba
478|
479|        mean_proba /= len(self.calibrated_classifiers_)
480|
481|        return mean_proba
482|
483|    def predict(self, X):
484|        """Predict the target of new samples.
485|
486|        The predicted class is the class that has the highest probability,
487|        and can thus be different from the prediction of the uncalibrated classifier.
488|
489|        Parameters
490|        ----------
491|        X : array-like of shape (n_samples, n_features)
492|            The samples, as accepted by `estimator.predict`.
493|
494|        Returns
495|        -------
496|        C : ndarray of shape (n_samples,)
497|            The predicted class.
498|        """
499|        check_is_fitted(self)
500|        return self.classes_[np.argmax(self.predict_proba(X), axis=1)]
501|
502|    def _more_tags(self):
503|        return {
504|            "_xfail_checks": {
505|                "check_sample_weights_invariance": (
506|                    "Due to the cross-validation and sample ordering, removing a sample"
507|                    " is not strictly equal to putting is weight to zero. Specific unit"
508|                    " tests are added for CalibratedClassifierCV specifically."
509|                ),
510|            }
511|        }
512|
513|
514|def _fit_classifier_calibrator_pair(
515|    estimator,
516|    X,
517|    y,
518|    train,
519|    test,
520|    supports_sw,
521|    method,
522|    classes,
523|    sample_weight=None,
524|    **fit_params,
525|):
526|    """Fit a classifier/calibration pair on a given train/test split.
527|
528|    Fit the classifier on the train set, compute its predictions on the test
529|    set and use the predictions as input to fit the calibrator along with the
530|    test labels.
531|
532|    Parameters
533|    ----------
534|    estimator : estimator instance
535|        Cloned base estimator.
536|
537|    X : array-like, shape (n_samples, n_features)
538|        Sample data.
539|
540|    y : array-like, shape (n_samples,)
541|        Targets.
542|
543|    train : ndarray, shape (n_train_indices,)
544|        Indices of the training subset.
545|
546|    test : ndarray, shape (n_test_indices,)
547|        Indices of the testing subset.
548|
549|    supports_sw : bool
550|        Whether or not the `estimator` supports sample weights.
551|
552|    method : {'sigmoid', 'isotonic'}
553|        Method to use for calibration.
554|
555|    classes : ndarray, shape (n_classes,)
556|        The target classes.
557|
558|    sample_weight : array-like, default=None
559|        Sample weights for `X`.
560|
561|    **fit_params : dict
562|        Parameters to pass to the `fit` method of the underlying
563|        classifier.
564|
565|    Returns
566|    -------
567|    calibrated_classifier : _CalibratedClassifier instance
568|    """
569|    fit_params_train = _check_fit_params(X, fit_params, train)
570|    X_train, y_train = _safe_indexing(X, train), _safe_indexing(y, train)
571|    X_test, y_test = _safe_indexing(X, test), _safe_indexing(y, test)
572|
573|    if sample_weight is not None and supports_sw:
574|        sw_train = _safe_indexing(sample_weight, train)
575|        estimator.fit(X_train, y_train, sample_weight=sw_train, **fit_params_train)
576|    else:
577|        estimator.fit(X_train, y_train, **fit_params_train)
578|
579|    n_classes = len(classes)
580|    pred_method, method_name = _get_prediction_method(estimator)
581|    predictions = _compute_predictions(pred_method, method_name, X_test, n_classes)
582|
583|    sw_test = None if sample_weight is None else _safe_indexing(sample_weight, test)
584|    calibrated_classifier = _fit_calibrator(
585|        estimator, predictions, y_test, classes, method, sample_weight=sw_test
586|    )
587|    return calibrated_classifier
588|
589|
590|def _get_prediction_method(clf):
591|    """Return prediction method.
592|
593|    `decision_function` method of `clf` returned, if it
594|    exists, otherwise `predict_proba` method returned.
595|
596|    Parameters
597|    ----------
598|    clf : Estimator instance
599|        Fitted classifier to obtain the prediction method from.
600|
601|    Returns
602|    -------
603|    prediction_method : callable
604|        The prediction method.
605|    method_name : str
606|        The name of the prediction method.
607|    """
608|    if hasattr(clf, "decision_function"):
609|        method = getattr(clf, "decision_function")
610|        return method, "decision_function"
611|
612|    if hasattr(clf, "predict_proba"):
613|        method = getattr(clf, "predict_proba")
614|        return method, "predict_proba"
615|
616|
617|def _compute_predictions(pred_method, method_name, X, n_classes):
618|    """Return predictions for `X` and reshape binary outputs to shape
619|    (n_samples, 1).
620|
621|    Parameters
622|    ----------
623|    pred_method : callable
624|        Prediction method.
625|
626|    method_name: str
627|        Name of the prediction method
628|
629|    X : array-like or None
630|        Data used to obtain predictions.
631|
632|    n_classes : int
633|        Number of classes present.
634|
635|    Returns
636|    -------
637|    predictions : array-like, shape (X.shape[0], len(clf.classes_))
638|        The predictions. Note if there are 2 classes, array is of shape
639|        (X.shape[0], 1).
640|    """
641|    predictions = pred_method(X=X)
642|
643|    if method_name == "decision_function":
644|        if predictions.ndim == 1:
645|            predictions = predictions[:, np.newaxis]
646|    elif method_name == "predict_proba":
647|        if n_classes == 2:
648|            predictions = predictions[:, 1:]
649|    else:  # pragma: no cover
650|        # this branch should be unreachable.
651|        raise ValueError(f"Invalid prediction method: {method_name}")
652|    return predictions
653|
654|
655|def _fit_calibrator(clf, predictions, y, classes, method, sample_weight=None):
656|    """Fit calibrator(s) and return a `_CalibratedClassifier`
657|    instance.
658|
659|    `n_classes` (i.e. `len(clf.classes_)`) calibrators are fitted.
660|    However, if `n_classes` equals 2, one calibrator is fitted.
661|
662|    Parameters
663|    ----------
664|    clf : estimator instance
665|        Fitted classifier.
666|
667|    predictions : array-like, shape (n_samples, n_classes) or (n_samples, 1) \
668|                    when binary.
669|        Raw predictions returned by the un-calibrated base classifier.
670|
671|    y : array-like, shape (n_samples,)
672|        The targets.
673|
674|    classes : ndarray, shape (n_classes,)
675|        All the prediction classes.
676|
677|    method : {'sigmoid', 'isotonic'}
678|        The method to use for calibration.
679|
680|    sample_weight : ndarray, shape (n_samples,), default=None
681|        Sample weights. If None, then samples are equally weighted.
682|
683|    Returns
684|    -------
685|    pipeline : _CalibratedClassifier instance
686|    """
687|    Y = label_binarize(y, classes=classes)
688|    label_encoder = LabelEncoder().fit(classes)
689|    pos_class_indices = label_encoder.transform(clf.classes_)
690|    calibrators = []
691|    for class_idx, this_pred in zip(pos_class_indices, predictions.T):
692|        if method == "isotonic":
693|            calibrator = IsotonicRegression(out_of_bounds="clip")
694|        else:  # "sigmoid"
695|            calibrator = _SigmoidCalibration()
696|        calibrator.fit(this_pred, Y[:, class_idx], sample_weight)
697|        calibrators.append(calibrator)
698|
699|    pipeline = _CalibratedClassifier(clf, calibrators, method=method, classes=classes)
700|    return pipeline
701|
702|
703|class _CalibratedClassifier:
704|    """Pipeline-like chaining a fitted classifier and its fitted calibrators.
705|
706|    Parameters
707|    ----------
708|    estimator : estimator instance
709|        Fitted classifier.
710|
711|    calibrators : list of fitted estimator instances
712|        List of fitted calibrators (either 'IsotonicRegression' or
713|        '_SigmoidCalibration'). The number of calibrators equals the number of
714|        classes. However, if there are 2 classes, the list contains only one
715|        fitted calibrator.
716|
717|    classes : array-like of shape (n_classes,)
718|        All the prediction classes.
719|
720|    method : {'sigmoid', 'isotonic'}, default='sigmoid'
721|        The method to use for calibration. Can be 'sigmoid' which
722|        corresponds to Platt's method or 'isotonic' which is a
723|        non-parametric approach based on isotonic regression.
724|    """
725|
726|    def __init__(self, estimator, calibrators, *, classes, method="sigmoid"):
727|        self.estimator = estimator
728|        self.calibrators = calibrators
729|        self.classes = classes
730|        self.method = method
731|
732|    def predict_proba(self, X):
733|        """Calculate calibrated probabilities.
734|
735|        Calculates classification calibrated probabilities
736|        for each class, in a one-vs-all manner, for `X`.
737|
738|        Parameters
739|        ----------
740|        X : ndarray of shape (n_samples, n_features)
741|            The sample data.
742|
743|        Returns
744|        -------
745|        proba : array, shape (n_samples, n_classes)
746|            The predicted probabilities. Can be exact zeros.
747|        """
748|        n_classes = len(self.classes)
749|        pred_method, method_name = _get_prediction_method(self.estimator)
750|        predictions = _compute_predictions(pred_method, method_name, X, n_classes)
751|
752|        label_encoder = LabelEncoder().fit(self.classes)
753|        pos_class_indices = label_encoder.transform(self.estimator.classes_)
754|
755|        proba = np.zeros((_num_samples(X), n_classes))
756|        for class_idx, this_pred, calibrator in zip(
757|            pos_class_indices, predictions.T, self.calibrators
758|        ):
759|            if n_classes == 2:
760|                # When binary, `predictions` consists only of predictions for
761|                # clf.classes_[1] but `pos_class_indices` = 0
762|                class_idx += 1
763|            proba[:, class_idx] = calibrator.predict(this_pred)
764|
765|        # Normalize the probabilities
766|        if n_classes == 2:
767|            proba[:, 0] = 1.0 - proba[:, 1]
768|        else:
769|            denominator = np.sum(proba, axis=1)[:, np.newaxis]
770|            # In the edge case where for each class calibrator returns a null
771|            # probability for a given sample, use the uniform distribution
772|            # instead.
773|            uniform_proba = np.full_like(proba, 1 / n_classes)
774|            proba = np.divide(
775|                proba, denominator, out=uniform_proba, where=denominator != 0
776|            )
777|
778|        # Deal with cases where the predicted probability minimally exceeds 1.0
779|        proba[(1.0 < proba) & (proba <= 1.0 + 1e-5)] = 1.0
780|
781|        return proba
782|
783|
784|def _sigmoid_calibration(predictions, y, sample_weight=None):
785|    """Probability Calibration with sigmoid method (Platt 2000)
786|
787|    Parameters
788|    ----------
789|    predictions : ndarray of shape (n_samples,)
790|        The decision function or predict proba for the samples.
791|
...


### sklearn/isotonic.py
...
127|    if y_min is not None or y_max is not None:
128|        # Older versions of np.clip don't accept None as a bound, so use np.inf
129|        if y_min is None:
130|            y_min = -np.inf
131|        if y_max is None:
132|            y_max = np.inf
133|        np.clip(y, y_min, y_max, y)
134|    return y[order]
135|
136|
137|class IsotonicRegression(RegressorMixin, TransformerMixin, BaseEstimator):
138|    """Isotonic regression model.
139|
140|    Read more in the :ref:`User Guide <isotonic>`.
141|
142|    .. versionadded:: 0.13
143|
144|    Parameters
145|    ----------
146|    y_min : float, default=None
147|        Lower bound on the lowest predicted value (the minimum value may
148|        still be higher). If not set, defaults to -inf.
149|
150|    y_max : float, default=None
151|        Upper bound on the highest predicted value (the maximum may still be
152|        lower). If not set, defaults to +inf.
153|
154|    increasing : bool or 'auto', default=True
155|        Determines whether the predictions should be constrained to increase
156|        or decrease with `X`. 'auto' will decide based on the Spearman
157|        correlation estimate's sign.
158|
159|    out_of_bounds : {'nan', 'clip', 'raise'}, default='nan'
160|        Handles how `X` values outside of the training domain are handled
161|        during prediction.
162|
163|        - 'nan', predictions will be NaN.
164|        - 'clip', predictions will be set to the value corresponding to
165|          the nearest train interval endpoint.
166|        - 'raise', a `ValueError` is raised.
167|
168|    Attributes
169|    ----------
170|    X_min_ : float
171|        Minimum value of input array `X_` for left bound.
172|
173|    X_max_ : float
174|        Maximum value of input array `X_` for right bound.
175|
176|    X_thresholds_ : ndarray of shape (n_thresholds,)
177|        Unique ascending `X` values used to interpolate
178|        the y = f(X) monotonic function.
179|
180|        .. versionadded:: 0.24
181|
182|    y_thresholds_ : ndarray of shape (n_thresholds,)
183|        De-duplicated `y` values suitable to interpolate the y = f(X)
184|        monotonic function.
185|
186|        .. versionadded:: 0.24
187|
188|    f_ : function
189|        The stepwise interpolating function that covers the input domain ``X``.
190|
191|    increasing_ : bool
192|        Inferred value for ``increasing``.
193|
194|    See Also
195|    --------
196|    sklearn.linear_model.LinearRegression : Ordinary least squares Linear
197|        Regression.
198|    sklearn.ensemble.HistGradientBoostingRegressor : Gradient boosting that
199|        is a non-parametric model accepting monotonicity constraints.
200|    isotonic_regression : Function to solve the isotonic regression model.
201|
202|    Notes
203|    -----
204|    Ties are broken using the secondary method from de Leeuw, 1977.
205|
206|    References
207|    ----------
208|    Isotonic Median Regression: A Linear Programming Approach
209|    Nilotpal Chakravarti
210|    Mathematics of Operations Research
211|    Vol. 14, No. 2 (May, 1989), pp. 303-308
212|
213|    Isotone Optimization in R : Pool-Adjacent-Violators
214|    Algorithm (PAVA) and Active Set Methods
215|    de Leeuw, Hornik, Mair
216|    Journal of Statistical Software 2009
217|
218|    Correctness of Kruskal's algorithms for monotone regression with ties
219|    de Leeuw, Psychometrica, 1977
220|
221|    Examples
222|    --------
223|    >>> from sklearn.datasets import make_regression
224|    >>> from sklearn.isotonic import IsotonicRegression
225|    >>> X, y = make_regression(n_samples=10, n_features=1, random_state=41)
226|    >>> iso_reg = IsotonicRegression().fit(X, y)
227|    >>> iso_reg.predict([.1, .2])
228|    array([1.8628..., 3.7256...])
229|    """
230|
231|    _parameter_constraints: dict = {
232|        "y_min": [Interval(Real, None, None, closed="both"), None],
233|        "y_max": [Interval(Real, None, None, closed="both"), None],
234|        "increasing": ["boolean", StrOptions({"auto"})],
235|        "out_of_bounds": [StrOptions({"nan", "clip", "raise"})],
236|    }
237|
238|    def __init__(self, *, y_min=None, y_max=None, increasing=True, out_of_bounds="nan"):
239|        self.y_min = y_min
240|        self.y_max = y_max
241|        self.increasing = increasing
242|        self.out_of_bounds = out_of_bounds
243|
244|    def _check_input_data_shape(self, X):
245|        if not (X.ndim == 1 or (X.ndim == 2 and X.shape[1] == 1)):
246|            msg = (
247|                "Isotonic regression input X should be a 1d array or "
248|                "2d array with 1 feature"
249|            )
250|            raise ValueError(msg)
251|
252|    def _build_f(self, X, y):
253|        """Build the f_ interp1d function."""
254|
255|        bounds_error = self.out_of_bounds == "raise"
256|        if len(y) == 1:
257|            # single y, constant prediction
258|            self.f_ = lambda x: y.repeat(x.shape)
259|        else:
260|            self.f_ = interpolate.interp1d(
261|                X, y, kind="linear", bounds_error=bounds_error
262|            )
263|
264|    def _build_y(self, X, y, sample_weight, trim_duplicates=True):
265|        """Build the y_ IsotonicRegression."""
266|        self._check_input_data_shape(X)
267|        X = X.reshape(-1)  # use 1d view
268|
269|        # Determine increasing if auto-determination requested
270|        if self.increasing == "auto":
271|            self.increasing_ = check_increasing(X, y)
272|        else:
273|            self.increasing_ = self.increasing
274|
275|        # If sample_weights is passed, removed zero-weight values and clean
276|        # order
277|        sample_weight = _check_sample_weight(sample_weight, X, dtype=X.dtype)
278|        mask = sample_weight > 0
279|        X, y, sample_weight = X[mask], y[mask], sample_weight[mask]
280|
281|        order = np.lexsort((y, X))
282|        X, y, sample_weight = [array[order] for array in [X, y, sample_weight]]
283|        unique_X, unique_y, unique_sample_weight = _make_unique(X, y, sample_weight)
284|
285|        X = unique_X
286|        y = isotonic_regression(
287|            unique_y,
288|            sample_weight=unique_sample_weight,
289|            y_min=self.y_min,
290|            y_max=self.y_max,
291|            increasing=self.increasing_,
292|        )
293|
294|        # Handle the left and right bounds on X
295|        self.X_min_, self.X_max_ = np.min(X), np.max(X)
296|
297|        if trim_duplicates:
298|            # Remove unnecessary points for faster prediction
299|            keep_data = np.ones((len(y),), dtype=bool)
300|            # Aside from the 1st and last point, remove points whose y values
301|            # are equal to both the point before and the point after it.
302|            keep_data[1:-1] = np.logical_or(
303|                np.not_equal(y[1:-1], y[:-2]), np.not_equal(y[1:-1], y[2:])
304|            )
305|            return X[keep_data], y[keep_data]
306|        else:
307|            # The ability to turn off trim_duplicates is only used to it make
308|            # easier to unit test that removing duplicates in y does not have
309|            # any impact the resulting interpolation function (besides
310|            # prediction speed).
311|            return X, y
312|
313|    def fit(self, X, y, sample_weight=None):
314|        """Fit the model using X, y as training data.
315|
316|        Parameters
317|        ----------
318|        X : array-like of shape (n_samples,) or (n_samples, 1)
319|            Training data.
320|
321|            .. versionchanged:: 0.24
322|               Also accepts 2d array with 1 feature.
323|
324|        y : array-like of shape (n_samples,)
325|            Training target.
326|
327|        sample_weight : array-like of shape (n_samples,), default=None
328|            Weights. If set to None, all weights will be set to 1 (equal
329|            weights).
330|
331|        Returns
332|        -------
333|        self : object
334|            Returns an instance of self.
335|
336|        Notes
337|        -----
338|        X is stored for future use, as :meth:`transform` needs X to interpolate
339|        new input data.
340|        """
341|        self._validate_params()
342|        check_params = dict(accept_sparse=False, ensure_2d=False)
343|        X = check_array(
344|            X, input_name="X", dtype=[np.float64, np.float32], **check_params
345|        )
346|        y = check_array(y, input_name="y", dtype=X.dtype, **check_params)
347|        check_consistent_length(X, y, sample_weight)
348|
349|        # Transform y by running the isotonic regression algorithm and
350|        # transform X accordingly.
351|        X, y = self._build_y(X, y, sample_weight)
352|
353|        # It is necessary to store the non-redundant part of the training set
354|        # on the model to make it possible to support model persistence via
355|        # the pickle module as the object built by scipy.interp1d is not
356|        # picklable directly.
357|        self.X_thresholds_, self.y_thresholds_ = X, y
358|
359|        # Build the interpolation function
360|        self._build_f(X, y)
361|        return self
362|
363|    def transform(self, T):
364|        """Transform new data by linear interpolation.
365|
366|        Parameters
367|        ----------
368|        T : array-like of shape (n_samples,) or (n_samples, 1)
369|            Data to transform.
370|
371|            .. versionchanged:: 0.24
372|               Also accepts 2d array with 1 feature.
373|
374|        Returns
375|        -------
376|        y_pred : ndarray of shape (n_samples,)
377|            The transformed data.
378|        """
379|
380|        if hasattr(self, "X_thresholds_"):
381|            dtype = self.X_thresholds_.dtype
382|        else:
383|            dtype = np.float64
384|
385|        T = check_array(T, dtype=dtype, ensure_2d=False)
386|
387|        self._check_input_data_shape(T)
388|        T = T.reshape(-1)  # use 1d view
389|
390|        if self.out_of_bounds == "clip":
391|            T = np.clip(T, self.X_min_, self.X_max_)
392|
393|        res = self.f_(T)
394|
395|        # on scipy 0.17, interp1d up-casts to float64, so we cast back
396|        res = res.astype(T.dtype)
397|
398|        return res
399|
400|    def predict(self, T):
401|        """Predict new data by linear interpolation.
402|
403|        Parameters
404|        ----------
405|        T : array-like of shape (n_samples,) or (n_samples, 1)
406|            Data to transform.
407|
408|        Returns
409|        -------
410|        y_pred : ndarray of shape (n_samples,)
411|            Transformed data.
412|        """
413|        return self.transform(T)
414|
415|    # We implement get_feature_names_out here instead of using
416|    # `ClassNamePrefixFeaturesOutMixin`` because `input_features` are ignored.
417|    # `input_features` are ignored because `IsotonicRegression` accepts 1d
418|    # arrays and the semantics of `feature_names_in_` are not clear for 1d arrays.
419|    def get_feature_names_out(self, input_features=None):
420|        """Get output feature names for transformation.
421|
422|        Parameters
423|        ----------
424|        input_features : array-like of str or None, default=None
425|            Ignored.
426|
427|        Returns
428|        -------
429|        feature_names_out : ndarray of str objects
430|            An ndarray with one string i.e. ["isotonicregression0"].
431|        """
432|        check_is_fitted(self, "f_")
433|        class_name = self.__class__.__name__.lower()
434|        return np.asarray([f"{class_name}0"], dtype=object)
435|
436|    def __getstate__(self):
437|        """Pickle-protocol - return state of the estimator."""
438|        state = super().__getstate__()
439|        # remove interpolation method
440|        state.pop("f_", None)
441|        return state
442|
443|    def __setstate__(self, state):
444|        """Pickle-protocol - set state of the estimator.
445|
446|        We need to rebuild the interpolation function.
447|        """
448|        super().__setstate__(state)
449|        if hasattr(self, "X_thresholds_") and hasattr(self, "y_thresholds_"):
450|            self._build_f(self.X_thresholds_, self.y_thresholds_)
451|
452|    def _more_tags(self):
453|        return {"X_types": ["1darray"]}


### sklearn/_config.py
1|"""Global configuration state and functions for management
2|"""
3|import os
4|from contextlib import contextmanager as contextmanager
5|import threading
6|
7|_global_config = {
8|    "assume_finite": bool(os.environ.get("SKLEARN_ASSUME_FINITE", False)),
9|    "working_memory": int(os.environ.get("SKLEARN_WORKING_MEMORY", 1024)),
10|    "print_changed_only": True,
11|    "display": "diagram",
12|    "pairwise_dist_chunk_size": int(
13|        os.environ.get("SKLEARN_PAIRWISE_DIST_CHUNK_SIZE", 256)
14|    ),
15|    "enable_cython_pairwise_dist": True,
16|    "array_api_dispatch": False,
17|    "transform_output": "default",
18|}
19|_threadlocal = threading.local()
20|
21|
22|def _get_threadlocal_config():
23|    """Get a threadlocal **mutable** configuration. If the configuration
24|    does not exist, copy the default global configuration."""
25|    if not hasattr(_threadlocal, "global_config"):
26|        _threadlocal.global_config = _global_config.copy()
27|    return _threadlocal.global_config
28|
...
38|    See Also
39|    --------
40|    config_context : Context manager for global scikit-learn configuration.
41|    set_config : Set global scikit-learn configuration.
42|    """
43|    # Return a copy of the threadlocal configuration so that users will
44|    # not be able to modify the configuration with the returned dict.
45|    return _get_threadlocal_config().copy()
46|
47|
48|def set_config(
49|    assume_finite=None,
50|    working_memory=None,
51|    print_changed_only=None,
52|    display=None,
53|    pairwise_dist_chunk_size=None,
54|    enable_cython_pairwise_dist=None,
55|    array_api_dispatch=None,
56|    transform_output=None,
57|):
58|    """Set global scikit-learn configuration
59|
60|    .. versionadded:: 0.19
61|
62|    Parameters
63|    ----------
64|    assume_finite : bool, default=None
65|        If True, validation for finiteness will be skipped,
66|        saving time, but leading to potential crashes. If
67|        False, validation for finiteness will be performed,
68|        avoiding error.  Global default: False.
69|
70|        .. versionadded:: 0.19
71|
72|    working_memory : int, default=None
73|        If set, scikit-learn will attempt to limit the size of temporary arrays
74|        to this number of MiB (per job when parallelised), often saving both
75|        computation time and memory on expensive operations that can be
76|        performed in chunks. Global default: 1024.
77|
78|        .. versionadded:: 0.20
79|
80|    print_changed_only : bool, default=None
81|        If True, only the parameters that were set to non-default
82|        values will be printed when printing an estimator. For example,
83|        ``print(SVC())`` while True will only print 'SVC()' while the default
84|        behaviour would be to print 'SVC(C=1.0, cache_size=200, ...)' with
85|        all the non-changed parameters.
86|
87|        .. versionadded:: 0.21
88|
89|    display : {'text', 'diagram'}, default=None
90|        If 'diagram', estimators will be displayed as a diagram in a Jupyter
91|        lab or notebook context. If 'text', estimators will be displayed as
92|        text. Default is 'diagram'.
93|
94|        .. versionadded:: 0.23
95|
96|    pairwise_dist_chunk_size : int, default=None
97|        The number of row vectors per chunk for the accelerated pairwise-
98|        distances reduction backend. Default is 256 (suitable for most of
99|        modern laptops' caches and architectures).
100|
101|        Intended for easier benchmarking and testing of scikit-learn internals.
102|        End users are not expected to benefit from customizing this configuration
103|        setting.
104|
105|        .. versionadded:: 1.1
106|
107|    enable_cython_pairwise_dist : bool, default=None
108|        Use the accelerated pairwise-distances reduction backend when
109|        possible. Global default: True.
110|
111|        Intended for easier benchmarking and testing of scikit-learn internals.
112|        End users are not expected to benefit from customizing this configuration
113|        setting.
114|
115|        .. versionadded:: 1.1
116|
117|    array_api_dispatch : bool, default=None
118|        Use Array API dispatching when inputs follow the Array API standard.
119|        Default is False.
120|
121|        See the :ref:`User Guide <array_api>` for more details.
122|
123|        .. versionadded:: 1.2
124|
125|    transform_output : str, default=None
126|        Configure output of `transform` and `fit_transform`.
127|
128|        See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`
129|        for an example on how to use the API.
130|
131|        - `"default"`: Default output format of a transformer
132|        - `"pandas"`: DataFrame output
133|        - `None`: Transform configuration is unchanged
134|
135|        .. versionadded:: 1.2
136|
137|    See Also
138|    --------
139|    config_context : Context manager for global scikit-learn configuration.
140|    get_config : Retrieve current values of the global configuration.
141|    """
142|    local_config = _get_threadlocal_config()
143|
144|    if assume_finite is not None:
145|        local_config["assume_finite"] = assume_finite
146|    if working_memory is not None:
147|        local_config["working_memory"] = working_memory
148|    if print_changed_only is not None:
149|        local_config["print_changed_only"] = print_changed_only
150|    if display is not None:
151|        local_config["display"] = display
152|    if pairwise_dist_chunk_size is not None:
153|        local_config["pairwise_dist_chunk_size"] = pairwise_dist_chunk_size
154|    if enable_cython_pairwise_dist is not None:
155|        local_config["enable_cython_pairwise_dist"] = enable_cython_pairwise_dist
156|    if array_api_dispatch is not None:
157|        local_config["array_api_dispatch"] = array_api_dispatch
158|    if transform_output is not None:
159|        local_config["transform_output"] = transform_output
160|
161|
162|@contextmanager
163|def config_context(
164|    *,
165|    assume_finite=None,
166|    working_memory=None,
167|    print_changed_only=None,
168|    display=None,
169|    pairwise_dist_chunk_size=None,
...




###

Please provide the class name, function or method name, or the exact line numbers that need to be edited.
### Examples:
```
full_path1/file1.py
line: 10
class: MyClass1
line: 51

full_path2/file2.py
function: MyClass2.my_method
line: 12

full_path3/file3.py
function: my_function
line: 24
line: 156
```

Return just the location(s)

2024-10-18 13:49:04,592 - INFO - ================================================================================
2024-10-18 13:49:04,691 - INFO - Creating API request
2024-10-18 13:49:07,597 - INFO - API response ChatCompletion(id='chatcmpl-AJoC9RclBIt4VHT4bioYYLmFiSiWj', choices=[Choice(finish_reason='stop', index=0, logprobs=None, message=ChatCompletionMessage(content='```\nsklearn/calibration.py\nfunction: _fit_calibrator\nline: 655\n\nsklearn/calibration.py\nclass: _CalibratedClassifier\nfunction: predict_proba\nline: 763\n```', refusal=None, role='assistant', function_call=None, tool_calls=None)), Choice(finish_reason='stop', index=1, logprobs=None, message=ChatCompletionMessage(content='```\nsklearn/calibration.py\nclass: _CalibratedClassifier\nfunction: _CalibratedClassifier.predict_proba\nline: 763\n```', refusal=None, role='assistant', function_call=None, tool_calls=None)), Choice(finish_reason='stop', index=2, logprobs=None, message=ChatCompletionMessage(content='```\nsklearn/calibration.py\nclass: _CalibratedClassifier\nfunction: _CalibratedClassifier.predict_proba\nline: 763\n\nsklearn/isotonic.py\nclass: IsotonicRegression\nfunction: IsotonicRegression.predict\nline: 413\n```', refusal=None, role='assistant', function_call=None, tool_calls=None)), Choice(finish_reason='stop', index=3, logprobs=None, message=ChatCompletionMessage(content='```\nsklearn/calibration.py\nfunction: _CalibratedClassifier.predict_proba\nline: 763\n\nsklearn/calibration.py\nfunction: _compute_predictions\nline: 641\n```', refusal=None, role='assistant', function_call=None, tool_calls=None))], created=1729284545, model='gpt-4o-2024-05-13', object='chat.completion', service_tier=None, system_fingerprint='fp_568f3bfff7', usage=CompletionUsage(completion_tokens=181, prompt_tokens=13814, total_tokens=13995, completion_tokens_details=CompletionTokensDetails(audio_tokens=None, reasoning_tokens=0), prompt_tokens_details=PromptTokensDetails(audio_tokens=None, cached_tokens=0)))
2024-10-18 13:49:07,597 - INFO - ==== raw output ====
2024-10-18 13:49:07,597 - INFO - ```
sklearn/calibration.py
function: _fit_calibrator
line: 655

sklearn/calibration.py
class: _CalibratedClassifier
function: predict_proba
line: 763
```
2024-10-18 13:49:07,597 - INFO - ================================================================================
2024-10-18 13:49:07,597 - INFO - ==== extracted locs ====
2024-10-18 13:49:07,598 - INFO - ['function: _fit_calibrator\nline: 655\nclass: _CalibratedClassifier\nfunction: predict_proba\nline: 763']
2024-10-18 13:49:07,598 - INFO - ['']
2024-10-18 13:49:07,598 - INFO - ['']
2024-10-18 13:49:07,598 - INFO - ================================================================================
2024-10-18 13:49:07,598 - INFO - ==== raw output ====
2024-10-18 13:49:07,598 - INFO - ```
sklearn/calibration.py
class: _CalibratedClassifier
function: _CalibratedClassifier.predict_proba
line: 763
```
2024-10-18 13:49:07,598 - INFO - ================================================================================
2024-10-18 13:49:07,598 - INFO - ==== extracted locs ====
2024-10-18 13:49:07,598 - INFO - ['class: _CalibratedClassifier\nfunction: _CalibratedClassifier.predict_proba\nline: 763']
2024-10-18 13:49:07,598 - INFO - ['']
2024-10-18 13:49:07,598 - INFO - ['']
2024-10-18 13:49:07,598 - INFO - ================================================================================
2024-10-18 13:49:07,598 - INFO - ==== raw output ====
2024-10-18 13:49:07,598 - INFO - ```
sklearn/calibration.py
class: _CalibratedClassifier
function: _CalibratedClassifier.predict_proba
line: 763

sklearn/isotonic.py
class: IsotonicRegression
function: IsotonicRegression.predict
line: 413
```
2024-10-18 13:49:07,598 - INFO - ================================================================================
2024-10-18 13:49:07,598 - INFO - ==== extracted locs ====
2024-10-18 13:49:07,598 - INFO - ['class: _CalibratedClassifier\nfunction: _CalibratedClassifier.predict_proba\nline: 763']
2024-10-18 13:49:07,598 - INFO - ['class: IsotonicRegression\nfunction: IsotonicRegression.predict\nline: 413']
2024-10-18 13:49:07,598 - INFO - ['']
2024-10-18 13:49:07,598 - INFO - ================================================================================
2024-10-18 13:49:07,598 - INFO - ==== raw output ====
2024-10-18 13:49:07,598 - INFO - ```
sklearn/calibration.py
function: _CalibratedClassifier.predict_proba
line: 763

sklearn/calibration.py
function: _compute_predictions
line: 641
```
2024-10-18 13:49:07,598 - INFO - ================================================================================
2024-10-18 13:49:07,598 - INFO - ==== extracted locs ====
2024-10-18 13:49:07,598 - INFO - ['function: _CalibratedClassifier.predict_proba\nline: 763\nfunction: _compute_predictions\nline: 641']
2024-10-18 13:49:07,598 - INFO - ['']
2024-10-18 13:49:07,598 - INFO - ['']
2024-10-18 13:49:07,598 - INFO - ================================================================================
2024-10-18 13:49:07,599 - INFO - ==== Input coarse_locs
2024-10-18 13:49:07,599 - INFO - 
### sklearn/calibration.py
class: CalibratedClassifierCV
function: _fit_classifier_calibrator_pair
function: _get_prediction_method
function: _compute_predictions
function: _fit_calibrator
class: _CalibratedClassifier
### sklearn/isotonic.py
class: IsotonicRegression
### sklearn/_config.py
variable: _global_config
function: set_config

