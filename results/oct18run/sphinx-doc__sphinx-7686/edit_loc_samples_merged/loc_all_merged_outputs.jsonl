{"instance_id": "sphinx-doc__sphinx-7686", "found_files": ["sphinx/ext/autosummary/generate.py", "sphinx/ext/autosummary/__init__.py", "sphinx/config.py", "sphinx/application.py", "sphinx/util/template.py"], "additional_artifact_loc_file": {"raw_output_files": "```\nsphinx/ext/autosummary/generate.py\nsphinx/ext/autosummary/__init__.py\nsphinx/config.py\nsphinx/application.py\nsphinx/util/template.py\n```"}, "file_traj": {"response": "```\nsphinx/ext/autosummary/generate.py\nsphinx/ext/autosummary/__init__.py\nsphinx/config.py\nsphinx/application.py\nsphinx/util/template.py\n```", "usage": {"completion_tokens": 40, "prompt_tokens": 1423}, "prompt": "Please look through the following GitHub problem description, and Repository structure and provide a list of files that one would need to edit to fix the problem.\n\n### GitHub Problem Description ###\nautosummary: The members variable for module template contains imported members\n**Describe the bug**\r\nautosummary: The members variable for module template contains imported members even if autosummary_imported_members is False.\r\n\r\n**To Reproduce**\r\n\r\n```\r\n# _templates/autosummary/module.rst\r\n{{ fullname | escape | underline }}\r\n\r\n.. automodule:: {{ fullname }}\r\n\r\n   .. autosummary::\r\n   {% for item in members %}\r\n      {{ item }}\r\n   {%- endfor %}\r\n\r\n```\r\n```\r\n# example.py\r\nimport os\r\n```\r\n```\r\n# index.rst\r\n.. autosummary::\r\n   :toctree: generated\r\n\r\n   example\r\n```\r\n```\r\n# conf.py\r\nautosummary_generate = True\r\nautosummary_imported_members = False\r\n```\r\n\r\nAs a result, I got following output:\r\n```\r\n# generated/example.rst\r\nexample\r\n=======\r\n\r\n.. automodule:: example\r\n\r\n   .. autosummary::\r\n\r\n      __builtins__\r\n      __cached__\r\n      __doc__\r\n      __file__\r\n      __loader__\r\n      __name__\r\n      __package__\r\n      __spec__\r\n      os\r\n```\r\n\r\n**Expected behavior**\r\nThe template variable `members` should not contain imported members when `autosummary_imported_members` is False.\r\n\r\n**Your project**\r\nNo\r\n\r\n**Screenshots**\r\nNo\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.8.2\r\n- Sphinx version: 3.1.0dev\r\n- Sphinx extensions:  sphinx.ext.autosummary\r\n- Extra tools: No\r\n\r\n**Additional context**\r\nNo\r\n\n\n\n###\n\n\n\n### Repository Structure ###\nsphinx/\n    setup.py\n    events.py\n    addnodes.py\n    parsers.py\n    versioning.py\n    jinja2glue.py\n    project.py\n    extension.py\n    highlighting.py\n    setup_command.py\n    io.py\n    deprecation.py\n    pygments_styles.py\n    roles.py\n    errors.py\n    config.py\n    registry.py\n    theming.py\n    application.py\n    __init__.py\n    __main__.py\n    transforms/\n        i18n.py\n        references.py\n        compact_bullet_list.py\n        __init__.py\n        post_transforms/\n            code.py\n            images.py\n            __init__.py\n    domains/\n        index.py\n        python.py\n        javascript.py\n        changeset.py\n        citation.py\n        std.py\n        cpp.py\n        math.py\n        rst.py\n        c.py\n        __init__.py\n    ext/\n        graphviz.py\n        imgconverter.py\n        imgmath.py\n        githubpages.py\n        intersphinx.py\n        inheritance_diagram.py\n        linkcode.py\n        viewcode.py\n        ifconfig.py\n        todo.py\n        mathjax.py\n        jsmath.py\n        apidoc.py\n        coverage.py\n        autosectionlabel.py\n        extlinks.py\n        __init__.py\n        doctest.py\n        duration.py\n        napoleon/\n            iterators.py\n            docstring.py\n            __init__.py\n        autosummary/\n            generate.py\n            __init__.py\n        autodoc/\n            typehints.py\n            importer.py\n            mock.py\n            directive.py\n            type_comment.py\n            __init__.py\n    writers/\n        html5.py\n        manpage.py\n        latex.py\n        html.py\n        texinfo.py\n        xml.py\n        __init__.py\n        text.py\n    pycode/\n        ast.py\n        parser.py\n        __init__.py\n    cmd/\n        build.py\n        quickstart.py\n        make_mode.py\n        __init__.py\n    directives/\n        code.py\n        other.py\n        patches.py\n        __init__.py\n    util/\n        requests.py\n        smartypants.py\n        typing.py\n        template.py\n        i18n.py\n        matching.py\n        texescape.py\n        jsdump.py\n        images.py\n        compat.py\n        inventory.py\n        fileutil.py\n        console.py\n        inspect.py\n        jsonimpl.py\n        pycompat.py\n        nodes.py\n        cfamily.py\n        math.py\n        docfields.py\n        rst.py\n        logging.py\n        docstrings.py\n        osutil.py\n        build_phase.py\n        docutils.py\n        png.py\n        __init__.py\n        tags.py\n        parallel.py\n        stemmer/\n            porter.py\n            __init__.py\n    environment/\n        __init__.py\n        collectors/\n            asset.py\n            indexentries.py\n            title.py\n            dependencies.py\n            toctree.py\n            metadata.py\n            __init__.py\n        adapters/\n            asset.py\n            indexentries.py\n            toctree.py\n            __init__.py\n    search/\n        es.py\n        hu.py\n        ru.py\n        zh.py\n        sv.py\n        jssplitter.py\n        ja.py\n        ro.py\n        en.py\n        da.py\n        pt.py\n        tr.py\n        fr.py\n        de.py\n        it.py\n        nl.py\n        fi.py\n        __init__.py\n        no.py\n    locale/\n        __init__.py\n    builders/\n        singlehtml.py\n        manpage.py\n        applehelp.py\n        linkcheck.py\n        gettext.py\n        epub3.py\n        changes.py\n        _epub_base.py\n        htmlhelp.py\n        devhelp.py\n        texinfo.py\n        dirhtml.py\n        dummy.py\n        xml.py\n        qthelp.py\n        __init__.py\n        text.py\n        latex/\n            transforms.py\n            constants.py\n            nodes.py\n            theming.py\n            util.py\n            __init__.py\n        html/\n            transforms.py\n            __init__.py\ndoc/\n    conf.py\n    usage/\n        extensions/\n            example_google.py\n            example_numpy.py\n    development/\n        tutorials/\n            examples/\n                recipe.py\n                todo.py\n                helloworld.py\nutils/\n    checks.py\n    bump_version.py\n    doclinter.py\n    __init__.py\n    jssplitter_generator.py\n\n###\n\nPlease only provide the full path and return at most 5 files.\nThe returned files should be separated by new lines ordered by most to least important and wrapped with ```\nFor example:\n```\nfile1.py\nfile2.py\n```"}, "found_related_locs": [["function: generate_autosummary_content\nfunction: generate_autosummary_docs"], ["class: Autosummary\nfunction: get_documenter"], ["class: Config"]], "additional_artifact_loc_related": [{"raw_output_loc": "```\nsphinx/ext/autosummary/generate.py\nfunction: generate_autosummary_content\nfunction: generate_autosummary_docs\n\nsphinx/ext/autosummary/__init__.py\nclass: Autosummary\nfunction: get_documenter\n\nsphinx/config.py\nclass: Config\n```"}], "related_loc_traj": {"response": "```\nsphinx/ext/autosummary/generate.py\nfunction: generate_autosummary_content\nfunction: generate_autosummary_docs\n\nsphinx/ext/autosummary/__init__.py\nclass: Autosummary\nfunction: get_documenter\n\nsphinx/config.py\nclass: Config\n```", "usage": {"completion_tokens": 60, "prompt_tokens": 3266}, "prompt": "\nPlease look through the following GitHub Problem Description, and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nautosummary: The members variable for module template contains imported members\n**Describe the bug**\r\nautosummary: The members variable for module template contains imported members even if autosummary_imported_members is False.\r\n\r\n**To Reproduce**\r\n\r\n```\r\n# _templates/autosummary/module.rst\r\n{{ fullname | escape | underline }}\r\n\r\n.. automodule:: {{ fullname }}\r\n\r\n   .. autosummary::\r\n   {% for item in members %}\r\n      {{ item }}\r\n   {%- endfor %}\r\n\r\n```\r\n```\r\n# example.py\r\nimport os\r\n```\r\n```\r\n# index.rst\r\n.. autosummary::\r\n   :toctree: generated\r\n\r\n   example\r\n```\r\n```\r\n# conf.py\r\nautosummary_generate = True\r\nautosummary_imported_members = False\r\n```\r\n\r\nAs a result, I got following output:\r\n```\r\n# generated/example.rst\r\nexample\r\n=======\r\n\r\n.. automodule:: example\r\n\r\n   .. autosummary::\r\n\r\n      __builtins__\r\n      __cached__\r\n      __doc__\r\n      __file__\r\n      __loader__\r\n      __name__\r\n      __package__\r\n      __spec__\r\n      os\r\n```\r\n\r\n**Expected behavior**\r\nThe template variable `members` should not contain imported members when `autosummary_imported_members` is False.\r\n\r\n**Your project**\r\nNo\r\n\r\n**Screenshots**\r\nNo\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.8.2\r\n- Sphinx version: 3.1.0dev\r\n- Sphinx extensions:  sphinx.ext.autosummary\r\n- Extra tools: No\r\n\r\n**Additional context**\r\nNo\r\n\n\n\n###\n\n\n\n### Skeleton of Relevant Files ###\n\n### File: sphinx/ext/autosummary/generate.py ###\n```python\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass DummyApplication:\n\n    def __init__(self, translator: NullTranslations) -> None:\n...\n    def emit_firstresult(self, *args: Any) -> None:\n...\n\nAutosummaryEntry = NamedTuple('AutosummaryEntry', [('name', str),\n                                                   ('path', str),\n                                                   ('template', str),\n                                                   ('recursive', bool)])\n\n\ndef setup_documenters(app: Any) -> None:\n...\n\ndef _simple_info(msg: str) -> None:\n...\n\ndef _simple_warn(msg: str) -> None:\n...\n\ndef _underline(title: str, line: str = '=') -> str:\n...\n\nclass AutosummaryRenderer:\n\n    def __init__(self, app: Union[Builder, Sphinx], template_dir: str = None) -> None:\n...\n    def exists(self, template_name: str) -> bool:\n...\n    def render(self, template_name: str, context: Dict) -> str:\n...\n\n# -- Generating output ---------------------------------------------------------\n\n\ndef generate_autosummary_content(name: str, obj: Any, parent: Any,\n                                 template: AutosummaryRenderer, template_name: str,\n                                 imported_members: bool, app: Any,\n                                 recursive: bool, context: Dict) -> str:\n...\n\ndef generate_autosummary_docs(sources: List[str], output_dir: str = None,\n                              suffix: str = '.rst', warn: Callable = None,\n                              info: Callable = None, base_path: str = None,\n                              builder: Builder = None, template_dir: str = None,\n                              imported_members: bool = False, app: Any = None,\n                              overwrite: bool = True) -> None:\n...\n\n# -- Finding documented entries in files ---------------------------------------\n\ndef find_autosummary_in_files(filenames: List[str]) -> List[AutosummaryEntry]:\n...\n\ndef find_autosummary_in_docstring(name: str, module: str = None, filename: str = None\n                                  ) -> List[AutosummaryEntry]:\n...\n\ndef find_autosummary_in_lines(lines: List[str], module: str = None, filename: str = None\n                              ) -> List[AutosummaryEntry]:\n...\n\ndef get_parser() -> argparse.ArgumentParser:\n...\n\ndef main(argv: List[str] = sys.argv[1:]) -> None:\n\n```\n\n### File: sphinx/ext/autosummary/__init__.py ###\n```python\n\n\nlogger = logging.getLogger(__name__)\n\n\nperiods_re = re.compile(r'\\.(?:\\s+)')\nliteral_re = re.compile(r'::\\s*$')\n\n\n# -- autosummary_toc node ------------------------------------------------------\n\nclass autosummary_toc(nodes.comment):\n    pass\n\n\ndef process_autosummary_toc(app: Sphinx, doctree: nodes.document) -> None:\n...\n\ndef autosummary_toc_visit_html(self: nodes.NodeVisitor, node: autosummary_toc) -> None:\n...\n\ndef autosummary_noop(self: nodes.NodeVisitor, node: Node) -> None:\n...\n\n# -- autosummary_table node ----------------------------------------------------\n\nclass autosummary_table(nodes.comment):\n    pass\n\n\ndef autosummary_table_visit_html(self: HTMLTranslator, node: autosummary_table) -> None:\n...\n\n# -- autodoc integration -------------------------------------------------------\n\n# current application object (used in `get_documenter()`).\n_app = None  # type: Sphinx\n\n\nclass FakeDirective(DocumenterBridge):\n    def __init__(self) -> None:\n...\n\ndef get_documenter(app: Sphinx, obj: Any, parent: Any) -> \"Type[Documenter]\":\n...\n\n# -- .. autosummary:: ----------------------------------------------------------\n\nclass Autosummary(SphinxDirective):\n\n    required_arguments = 0\n    optional_arguments = 0\n    final_argument_whitespace = False\n    has_content = True\n    option_spec = {\n        'caption': directives.unchanged_required,\n        'toctree': directives.unchanged,\n        'nosignatures': directives.flag,\n        'recursive': directives.flag,\n        'template': directives.unchanged,\n    }\n\n    def run(self) -> List[Node]:\n...\n    def get_items(self, names: List[str]) -> List[Tuple[str, str, str, str]]:\n...\n    def get_table(self, items: List[Tuple[str, str, str, str]]) -> List[Node]:\n...\n    def warn(self, msg: str) -> None:\n...\n    @property\n    def genopt(self) -> Options:\n...\n    @property\n    def warnings(self) -> List[Node]:\n...\n    @property\n    def result(self) -> StringList:\n...\n\ndef strip_arg_typehint(s: str) -> str:\n...\n\ndef mangle_signature(sig: str, max_chars: int = 30) -> str:\n...\n\ndef extract_summary(doc: List[str], document: Any) -> str:\n...\n\ndef limited_join(sep: str, items: List[str], max_chars: int = 30,\n                 overflow_marker: str = \"...\") -> str:\n...\n\n# -- Importing items -----------------------------------------------------------\n\ndef get_import_prefixes_from_env(env: BuildEnvironment) -> List[str]:\n...\n\ndef import_by_name(name: str, prefixes: List[str] = [None]) -> Tuple[str, Any, Any, str]:\n...\n\ndef _import_by_name(name: str) -> Tuple[Any, Any, str]:\n...\n\n# -- :autolink: (smart default role) -------------------------------------------\n\ndef autolink_role(typ: str, rawtext: str, etext: str, lineno: int, inliner: Inliner,\n                  options: Dict = {}, content: List[str] = []\n                  ) -> Tuple[List[Node], List[system_message]]:\n...\n\nclass AutoLink(SphinxRole):\n    def run(self) -> Tuple[List[Node], List[system_message]]:\n...\n\ndef get_rst_suffix(app: Sphinx) -> str:\n...\n\ndef process_generate_options(app: Sphinx) -> None:\n...\n\ndef setup(app: Sphinx) -> Dict[str, Any]:\n\n```\n\n### File: sphinx/config.py ###\n```python\n\nlogger = logging.getLogger(__name__)\n\nCONFIG_FILENAME = 'conf.py'\nUNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)\ncopyright_year_re = re.compile(r'^((\\d{4}-)?)(\\d{4})(?=[ ,])')\n\nConfigValue = NamedTuple('ConfigValue', [('name', str),\n                                         ('value', Any),\n                                         ('rebuild', Union[bool, str])])\n\n\ndef is_serializable(obj: Any) -> bool:\n...\n\nclass ENUM:\n    def __init__(self, *candidates: str) -> None:\n...\n    def match(self, value: Union[str, List, Tuple]) -> bool:\n...\n\n# RemovedInSphinx40Warning\nstring_classes = [str]  # type: List\n\n\nclass Config:\n\n    # the values are: (default, what needs to be rebuilt if changed)\n\n    # If you add a value here, don't forget to include it in the\n    # quickstart.py file template as well as in the docs!\n\n    config_values = {\n        # general options\n        'project': ('Python', 'env', []),\n        'author': ('unknown', 'env', []),\n        'copyright': ('', 'html', []),\n        'version': ('', 'env', []),\n        'release': ('', 'env', []),\n        'today': ('', 'env', []),\n        # the real default is locale-dependent\n        'today_fmt': (None, 'env', [str]),\n\n        'language': (None, 'env', [str]),\n        'locale_dirs': (['locales'], 'env', []),\n        'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n\n        'master_doc': ('index', 'env', []),\n        'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n        'source_encoding': ('utf-8-sig', 'env', []),\n        'source_parsers': ({}, 'env', []),\n        'exclude_patterns': ([], 'env', []),\n        'default_role': (None, 'env', [str]),\n        'add_function_parentheses': (True, 'env', []),\n        'add_module_names': (True, 'env', []),\n        'trim_footnote_reference_space': (False, 'env', []),\n        'show_authors': (False, 'env', []),\n        'pygments_style': (None, 'html', [str]),\n        'highlight_language': ('default', 'env', []),\n        'highlight_options': ({}, 'env', []),\n        'templates_path': ([], 'html', []),\n        'template_bridge': (None, 'html', [str]),\n        'keep_warnings': (False, 'env', []),\n        'suppress_warnings': ([], 'env', []),\n        'modindex_common_prefix': ([], 'html', []),\n        'rst_epilog': (None, 'env', [str]),\n        'rst_prolog': (None, 'env', [str]),\n        'trim_doctest_flags': (True, 'env', []),\n        'primary_domain': ('py', 'env', [NoneType]),   # type: ignore\n        'needs_sphinx': (None, None, [str]),\n        'needs_extensions': ({}, None, []),\n        'manpages_url': (None, 'env', []),\n        'nitpicky': (False, None, []),\n        'nitpick_ignore': ([], None, []),\n        'numfig': (False, 'env', []),\n        'numfig_secnum_depth': (1, 'env', []),\n        'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n\n        'math_number_all': (False, 'env', []),\n        'math_eqref_format': (None, 'env', [str]),\n        'math_numfig': (True, 'env', []),\n        'tls_verify': (True, 'env', []),\n        'tls_cacerts': (None, 'env', []),\n        'user_agent': (None, 'env', [str]),\n        'smartquotes': (True, 'env', []),\n        'smartquotes_action': ('qDe', 'env', []),\n        'smartquotes_excludes': ({'languages': ['ja'],\n                                  'builders': ['man', 'text']},\n                                 'env', []),\n    }  # type: Dict[str, Tuple]\n\n    def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:\n...\n    @classmethod\n    def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> \"Config\":\n...\n    def convert_overrides(self, name: str, value: Any) -> Any:\n...\n    def pre_init_values(self) -> None:\n...\n    def init_values(self) -> None:\n...\n    def __getattr__(self, name: str) -> Any:\n...\n    def __getitem__(self, name: str) -> str:\n...\n    def __setitem__(self, name: str, value: Any) -> None:\n...\n    def __delitem__(self, name: str) -> None:\n...\n    def __contains__(self, name: str) -> bool:\n...\n    def __iter__(self) -> Generator[ConfigValue, None, None]:\n...\n    def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:\n...\n    def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:\n...\n    def __getstate__(self) -> Dict:\n...\n    def __setstate__(self, state: Dict) -> None:\n...\n\ndef eval_config_file(filename: str, tags: Tags) -> Dict[str, Any]:\n...\n\ndef convert_source_suffix(app: \"Sphinx\", config: Config) -> None:\n...\n\ndef init_numfig_format(app: \"Sphinx\", config: Config) -> None:\n...\n\ndef correct_copyright_year(app: \"Sphinx\", config: Config) -> None:\n...\n\ndef check_confval_types(app: \"Sphinx\", config: Config) -> None:\n...\n\ndef check_unicode(config: Config) -> None:\n...\n\ndef check_primary_domain(app: \"Sphinx\", config: Config) -> None:\n...\n\ndef check_master_doc(app: \"Sphinx\", env: \"BuildEnvironment\", added: Set[str],\n                     changed: Set[str], removed: Set[str]) -> Set[str]:\n...\n\ndef setup(app: \"Sphinx\") -> Dict[str, Any]:\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations.\n"}, "found_edit_locs": ["line: 249\nline: 251\nline: 253\nline: 255\nline: 257\nfunction: generate_autosummary_content\nline: 248\nfunction: get_members\nline: 207\nfunction: generate_autosummary_content\nline: 249\nfunction: get_members\nline: 207\nfunction: generate_autosummary_content\nline: 248\nline: 249\nline: 257", "class: Autosummary\nfunction: Autosummary.get_items\nline: 301\nline: 302\n\n\n", "\n\n\n"], "additional_artifact_loc_edit_location": [{"raw_output_loc": ["```\nsphinx/ext/autosummary/generate.py\nline: 249\nline: 251\nline: 253\nline: 255\nline: 257\n\nsphinx/ext/autosummary/__init__.py\nclass: Autosummary\nfunction: Autosummary.get_items\nline: 301\nline: 302\n```", "```\nsphinx/ext/autosummary/generate.py\nfunction: generate_autosummary_content\nline: 248\n\nsphinx/ext/autosummary/generate.py\nfunction: get_members\nline: 207\n```", "```\nsphinx/ext/autosummary/generate.py\nfunction: generate_autosummary_content\nline: 249\n\nsphinx/ext/autosummary/generate.py\nfunction: get_members\nline: 207\n```", "```\nsphinx/ext/autosummary/generate.py\nfunction: generate_autosummary_content\nline: 248\nline: 249\nline: 257\n```"]}], "edit_loc_traj": {"prompt": "\nPlease review the following GitHub problem description, and relevant files, and provide a set of locations that need to be edited to fix the issue.\nThe locations can be specified as class names, function or method names, or exact line numbers that require modification.\n\n### GitHub Problem Description ###\nautosummary: The members variable for module template contains imported members\n**Describe the bug**\r\nautosummary: The members variable for module template contains imported members even if autosummary_imported_members is False.\r\n\r\n**To Reproduce**\r\n\r\n```\r\n# _templates/autosummary/module.rst\r\n{{ fullname | escape | underline }}\r\n\r\n.. automodule:: {{ fullname }}\r\n\r\n   .. autosummary::\r\n   {% for item in members %}\r\n      {{ item }}\r\n   {%- endfor %}\r\n\r\n```\r\n```\r\n# example.py\r\nimport os\r\n```\r\n```\r\n# index.rst\r\n.. autosummary::\r\n   :toctree: generated\r\n\r\n   example\r\n```\r\n```\r\n# conf.py\r\nautosummary_generate = True\r\nautosummary_imported_members = False\r\n```\r\n\r\nAs a result, I got following output:\r\n```\r\n# generated/example.rst\r\nexample\r\n=======\r\n\r\n.. automodule:: example\r\n\r\n   .. autosummary::\r\n\r\n      __builtins__\r\n      __cached__\r\n      __doc__\r\n      __file__\r\n      __loader__\r\n      __name__\r\n      __package__\r\n      __spec__\r\n      os\r\n```\r\n\r\n**Expected behavior**\r\nThe template variable `members` should not contain imported members when `autosummary_imported_members` is False.\r\n\r\n**Your project**\r\nNo\r\n\r\n**Screenshots**\r\nNo\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.8.2\r\n- Sphinx version: 3.1.0dev\r\n- Sphinx extensions:  sphinx.ext.autosummary\r\n- Extra tools: No\r\n\r\n**Additional context**\r\nNo\r\n\n\n\n###\n\n\n\n### sphinx/ext/autosummary/generate.py\n...\n169|            except TemplateNotFound:\n170|                # fallback to base.rst\n171|                template = self.env.get_template('autosummary/base.rst')\n172|\n173|        return template.render(context)\n174|\n175|\n176|# -- Generating output ---------------------------------------------------------\n177|\n178|\n179|def generate_autosummary_content(name: str, obj: Any, parent: Any,\n180|                                 template: AutosummaryRenderer, template_name: str,\n181|                                 imported_members: bool, app: Any,\n182|                                 recursive: bool, context: Dict) -> str:\n183|    doc = get_documenter(app, obj, parent)\n184|\n185|    def skip_member(obj: Any, name: str, objtype: str) -> bool:\n186|        try:\n187|            return app.emit_firstresult('autodoc-skip-member', objtype, name,\n188|                                        obj, False, {})\n189|        except Exception as exc:\n190|            logger.warning(__('autosummary: failed to determine %r to be documented, '\n191|                              'the following exception was raised:\\n%s'),\n192|                           name, exc, type='autosummary')\n193|            return False\n194|\n195|    def get_members(obj: Any, types: Set[str], include_public: List[str] = [],\n196|                    imported: bool = True) -> Tuple[List[str], List[str]]:\n197|        items = []  # type: List[str]\n198|        public = []  # type: List[str]\n199|        for name in dir(obj):\n200|            try:\n201|                value = safe_getattr(obj, name)\n202|            except AttributeError:\n203|                continue\n204|            documenter = get_documenter(app, value, obj)\n205|            if documenter.objtype in types:\n206|                # skip imported members if expected\n207|                if imported or getattr(value, '__module__', None) == obj.__name__:\n208|                    skipped = skip_member(value, name, documenter.objtype)\n209|                    if skipped is True:\n210|                        pass\n211|                    elif skipped is False:\n212|                        # show the member forcedly\n213|                        items.append(name)\n214|                        public.append(name)\n215|                    else:\n216|                        items.append(name)\n217|                        if name in include_public or not name.startswith('_'):\n218|                            # considers member as public\n219|                            public.append(name)\n220|        return public, items\n221|\n222|    def get_module_attrs(members: Any) -> Tuple[List[str], List[str]]:\n223|        \"\"\"Find module attributes with docstrings.\"\"\"\n224|        attrs, public = [], []\n225|        try:\n226|            analyzer = ModuleAnalyzer.for_module(name)\n227|            attr_docs = analyzer.find_attr_docs()\n228|            for namespace, attr_name in attr_docs:\n229|                if namespace == '' and attr_name in members:\n230|                    attrs.append(attr_name)\n231|                    if not attr_name.startswith('_'):\n232|                        public.append(attr_name)\n233|        except PycodeError:\n234|            pass    # give up if ModuleAnalyzer fails to parse code\n235|        return public, attrs\n236|\n237|    def get_modules(obj: Any) -> Tuple[List[str], List[str]]:\n238|        items = []  # type: List[str]\n239|        for _, modname, ispkg in pkgutil.iter_modules(obj.__path__):\n240|            fullname = name + '.' + modname\n241|            items.append(fullname)\n242|        public = [x for x in items if not x.split('.')[-1].startswith('_')]\n243|        return public, items\n244|\n245|    ns = {}  # type: Dict[str, Any]\n246|    ns.update(context)\n247|\n248|    if doc.objtype == 'module':\n249|        ns['members'] = dir(obj)\n250|        ns['functions'], ns['all_functions'] = \\\n251|            get_members(obj, {'function'}, imported=imported_members)\n252|        ns['classes'], ns['all_classes'] = \\\n253|            get_members(obj, {'class'}, imported=imported_members)\n254|        ns['exceptions'], ns['all_exceptions'] = \\\n255|            get_members(obj, {'exception'}, imported=imported_members)\n256|        ns['attributes'], ns['all_attributes'] = \\\n257|            get_module_attrs(ns['members'])\n258|        ispackage = hasattr(obj, '__path__')\n259|        if ispackage and recursive:\n260|            ns['modules'], ns['all_modules'] = get_modules(obj)\n261|    elif doc.objtype == 'class':\n262|        ns['members'] = dir(obj)\n263|        ns['inherited_members'] = \\\n264|            set(dir(obj)) - set(obj.__dict__.keys())\n265|        ns['methods'], ns['all_methods'] = \\\n266|            get_members(obj, {'method'}, ['__init__'])\n267|        ns['attributes'], ns['all_attributes'] = \\\n268|            get_members(obj, {'attribute', 'property'})\n269|\n270|    modname, qualname = split_full_qualified_name(name)\n271|    if doc.objtype in ('method', 'attribute', 'property'):\n272|        ns['class'] = qualname.rsplit(\".\", 1)[0]\n273|\n274|    if doc.objtype in ('class',):\n275|        shortname = qualname\n276|    else:\n277|        shortname = qualname.rsplit(\".\", 1)[-1]\n278|\n279|    ns['fullname'] = name\n280|    ns['module'] = modname\n281|    ns['objname'] = qualname\n282|    ns['name'] = shortname\n283|\n284|    ns['objtype'] = doc.objtype\n285|    ns['underline'] = len(name) * '='\n286|\n287|    if template_name:\n288|        return template.render(template_name, ns)\n289|    else:\n290|        return template.render(doc.objtype, ns)\n291|\n292|\n293|def generate_autosummary_docs(sources: List[str], output_dir: str = None,\n294|                              suffix: str = '.rst', warn: Callable = None,\n295|                              info: Callable = None, base_path: str = None,\n296|                              builder: Builder = None, template_dir: str = None,\n297|                              imported_members: bool = False, app: Any = None,\n298|                              overwrite: bool = True) -> None:\n299|    if info:\n300|        warnings.warn('info argument for generate_autosummary_docs() is deprecated.',\n301|                      RemovedInSphinx40Warning, stacklevel=2)\n302|        _info = info\n303|    else:\n304|        _info = logger.info\n305|\n306|    if warn:\n307|        warnings.warn('warn argument for generate_autosummary_docs() is deprecated.',\n308|                      RemovedInSphinx40Warning, stacklevel=2)\n309|        _warn = warn\n310|    else:\n311|        _warn = logger.warning\n312|\n313|    if builder:\n314|        warnings.warn('builder argument for generate_autosummary_docs() is deprecated.',\n315|                      RemovedInSphinx50Warning, stacklevel=2)\n316|\n317|    if template_dir:\n318|        warnings.warn('template_dir argument for generate_autosummary_docs() is deprecated.',\n319|                      RemovedInSphinx50Warning, stacklevel=2)\n320|\n321|    showed_sources = list(sorted(sources))\n322|    if len(showed_sources) > 20:\n323|        showed_sources = showed_sources[:10] + ['...'] + showed_sources[-10:]\n324|    _info(__('[autosummary] generating autosummary for: %s') %\n325|          ', '.join(showed_sources))\n326|\n327|    if output_dir:\n328|        _info(__('[autosummary] writing to %s') % output_dir)\n329|\n330|    if base_path is not None:\n331|        sources = [os.path.join(base_path, filename) for filename in sources]\n332|\n333|    template = AutosummaryRenderer(app)\n334|\n335|    # read\n336|    items = find_autosummary_in_files(sources)\n337|\n338|    # keep track of new files\n339|    new_files = []\n340|\n341|    # write\n342|    for entry in sorted(set(items), key=str):\n343|        if entry.path is None:\n344|            # The corresponding autosummary:: directive did not have\n345|            # a :toctree: option\n346|            continue\n347|\n348|        path = output_dir or os.path.abspath(entry.path)\n349|        ensuredir(path)\n350|\n351|        try:\n352|            name, obj, parent, mod_name = import_by_name(entry.name)\n353|        except ImportError as e:\n354|            _warn(__('[autosummary] failed to import %r: %s') % (entry.name, e))\n355|            continue\n356|\n357|        context = {}\n358|        if app:\n359|            context.update(app.config.autosummary_context)\n360|\n361|        content = generate_autosummary_content(name, obj, parent, template, entry.template,\n362|                                               imported_members, app, entry.recursive, context)\n363|\n364|        filename = os.path.join(path, name + suffix)\n365|        if os.path.isfile(filename):\n366|            with open(filename) as f:\n367|                old_content = f.read()\n368|\n369|            if content == old_content:\n370|                continue\n371|            elif overwrite:  # content has changed\n372|                with open(filename, 'w') as f:\n373|                    f.write(content)\n374|                new_files.append(filename)\n375|        else:\n376|            with open(filename, 'w') as f:\n377|                f.write(content)\n378|            new_files.append(filename)\n379|\n380|    # descend recursively to new files\n381|    if new_files:\n382|        generate_autosummary_docs(new_files, output_dir=output_dir,\n383|                                  suffix=suffix, warn=warn, info=info,\n384|                                  base_path=base_path,\n385|                                  imported_members=imported_members, app=app,\n386|                                  overwrite=overwrite)\n387|\n388|\n389|# -- Finding documented entries in files ---------------------------------------\n390|\n391|def find_autosummary_in_files(filenames: List[str]) -> List[AutosummaryEntry]:\n392|    \"\"\"Find out what items are documented in source/*.rst.\n393|\n394|    See `find_autosummary_in_lines`.\n395|    \"\"\"\n396|    documented = []  # type: List[AutosummaryEntry]\n...\n\n\n### sphinx/ext/autosummary/__init__.py\n...\n172|\n173|\n174|class FakeDirective(DocumenterBridge):\n175|    def __init__(self) -> None:\n176|        settings = Struct(tab_width=8)\n177|        document = Struct(settings=settings)\n178|        state = Struct(document=document)\n179|        super().__init__({}, None, Options(), 0, state)  # type: ignore\n180|\n181|\n182|def get_documenter(app: Sphinx, obj: Any, parent: Any) -> \"Type[Documenter]\":\n183|    \"\"\"Get an autodoc.Documenter class suitable for documenting the given\n184|    object.\n185|\n186|    *obj* is the Python object to be documented, and *parent* is an\n187|    another Python object (e.g. a module or a class) to which *obj*\n188|    belongs to.\n189|    \"\"\"\n190|    from sphinx.ext.autodoc import DataDocumenter, ModuleDocumenter\n191|\n192|    if inspect.ismodule(obj):\n193|        # ModuleDocumenter.can_document_member always returns False\n194|        return ModuleDocumenter\n195|\n196|    # Construct a fake documenter for *parent*\n197|    if parent is not None:\n198|        parent_doc_cls = get_documenter(app, parent, None)\n199|    else:\n200|        parent_doc_cls = ModuleDocumenter\n201|\n202|    if hasattr(parent, '__name__'):\n203|        parent_doc = parent_doc_cls(FakeDirective(), parent.__name__)\n204|    else:\n205|        parent_doc = parent_doc_cls(FakeDirective(), \"\")\n206|\n207|    # Get the corrent documenter class for *obj*\n208|    classes = [cls for cls in app.registry.documenters.values()\n209|               if cls.can_document_member(obj, '', False, parent_doc)]\n210|    if classes:\n211|        classes.sort(key=lambda cls: cls.priority)\n212|        return classes[-1]\n213|    else:\n214|        return DataDocumenter\n215|\n216|\n217|# -- .. autosummary:: ----------------------------------------------------------\n218|\n219|class Autosummary(SphinxDirective):\n220|    \"\"\"\n221|    Pretty table containing short signatures and summaries of functions etc.\n222|\n223|    autosummary can also optionally generate a hidden toctree:: node.\n224|    \"\"\"\n225|\n226|    required_arguments = 0\n227|    optional_arguments = 0\n228|    final_argument_whitespace = False\n229|    has_content = True\n230|    option_spec = {\n231|        'caption': directives.unchanged_required,\n232|        'toctree': directives.unchanged,\n233|        'nosignatures': directives.flag,\n234|        'recursive': directives.flag,\n235|        'template': directives.unchanged,\n236|    }\n237|\n238|    def run(self) -> List[Node]:\n239|        self.bridge = DocumenterBridge(self.env, self.state.document.reporter,\n240|                                       Options(), self.lineno, self.state)\n241|\n242|        names = [x.strip().split()[0] for x in self.content\n243|                 if x.strip() and re.search(r'^[~a-zA-Z_]', x.strip()[0])]\n244|        items = self.get_items(names)\n245|        nodes = self.get_table(items)\n246|\n247|        if 'toctree' in self.options:\n248|            dirname = posixpath.dirname(self.env.docname)\n249|\n250|            tree_prefix = self.options['toctree'].strip()\n251|            docnames = []\n252|            excluded = Matcher(self.config.exclude_patterns)\n253|            for name, sig, summary, real_name in items:\n254|                docname = posixpath.join(tree_prefix, real_name)\n255|                docname = posixpath.normpath(posixpath.join(dirname, docname))\n256|                if docname not in self.env.found_docs:\n257|                    location = self.state_machine.get_source_and_line(self.lineno)\n258|                    if excluded(self.env.doc2path(docname, None)):\n259|                        msg = __('autosummary references excluded document %r. Ignored.')\n260|                    else:\n261|                        msg = __('autosummary: stub file not found %r. '\n262|                                 'Check your autosummary_generate setting.')\n263|\n264|                    logger.warning(msg, real_name, location=location)\n265|                    continue\n266|\n267|                docnames.append(docname)\n268|\n269|            if docnames:\n270|                tocnode = addnodes.toctree()\n271|                tocnode['includefiles'] = docnames\n272|                tocnode['entries'] = [(None, docn) for docn in docnames]\n273|                tocnode['maxdepth'] = -1\n274|                tocnode['glob'] = None\n275|                tocnode['caption'] = self.options.get('caption')\n276|\n277|                nodes.append(autosummary_toc('', '', tocnode))\n278|\n279|        if 'toctree' not in self.options and 'caption' in self.options:\n280|            logger.warning(__('A captioned autosummary requires :toctree: option. ignored.'),\n281|                           location=nodes[-1])\n282|\n283|        return nodes\n284|\n285|    def get_items(self, names: List[str]) -> List[Tuple[str, str, str, str]]:\n286|        \"\"\"Try to import the given names, and return a list of\n287|        ``[(name, signature, summary_string, real_name), ...]``.\n288|        \"\"\"\n289|        prefixes = get_import_prefixes_from_env(self.env)\n290|\n291|        items = []  # type: List[Tuple[str, str, str, str]]\n292|\n293|        max_item_chars = 50\n294|\n295|        for name in names:\n296|            display_name = name\n297|            if name.startswith('~'):\n298|                name = name[1:]\n299|                display_name = name.split('.')[-1]\n300|\n301|            try:\n302|                with mock(self.config.autosummary_mock_imports):\n303|                    real_name, obj, parent, modname = import_by_name(name, prefixes=prefixes)\n304|            except ImportError:\n305|                logger.warning(__('autosummary: failed to import %s'), name)\n306|                continue\n307|\n308|            self.bridge.result = StringList()  # initialize for each documenter\n309|            full_name = real_name\n310|            if not isinstance(obj, ModuleType):\n311|                # give explicitly separated module name, so that members\n312|                # of inner classes can be documented\n313|                full_name = modname + '::' + full_name[len(modname) + 1:]\n314|            # NB. using full_name here is important, since Documenters\n315|            #     handle module prefixes slightly differently\n316|            doccls = get_documenter(self.env.app, obj, parent)\n317|            documenter = doccls(self.bridge, full_name)\n318|            if not documenter.parse_name():\n319|                logger.warning(__('failed to parse name %s'), real_name)\n320|                items.append((display_name, '', '', real_name))\n321|                continue\n322|            if not documenter.import_object():\n323|                logger.warning(__('failed to import object %s'), real_name)\n324|                items.append((display_name, '', '', real_name))\n325|                continue\n326|            if documenter.options.members and not documenter.check_module():\n327|                continue\n328|\n329|            # try to also get a source code analyzer for attribute docs\n330|            try:\n331|                documenter.analyzer = ModuleAnalyzer.for_module(\n332|                    documenter.get_real_modname())\n333|                # parse right now, to get PycodeErrors on parsing (results will\n334|                # be cached anyway)\n335|                documenter.analyzer.find_attr_docs()\n336|            except PycodeError as err:\n337|                logger.debug('[autodoc] module analyzer failed: %s', err)\n338|                # no source file -- e.g. for builtin and C modules\n339|                documenter.analyzer = None\n340|\n341|            # -- Grab the signature\n342|\n343|            try:\n344|                sig = documenter.format_signature(show_annotation=False)\n345|            except TypeError:\n346|                # the documenter does not support ``show_annotation`` option\n347|                sig = documenter.format_signature()\n348|\n349|            if not sig:\n350|                sig = ''\n351|            else:\n352|                max_chars = max(10, max_item_chars - len(display_name))\n353|                sig = mangle_signature(sig, max_chars=max_chars)\n354|\n355|            # -- Grab the summary\n356|\n357|            documenter.add_content(None)\n358|            summary = extract_summary(self.bridge.result.data[:], self.state.document)\n359|\n360|            items.append((display_name, sig, summary, real_name))\n361|\n362|        return items\n363|\n364|    def get_table(self, items: List[Tuple[str, str, str, str]]) -> List[Node]:\n365|        \"\"\"Generate a proper list of table nodes for autosummary:: directive.\n366|\n367|        *items* is a list produced by :meth:`get_items`.\n368|        \"\"\"\n369|        table_spec = addnodes.tabular_col_spec()\n370|        table_spec['spec'] = r'\\X{1}{2}\\X{1}{2}'\n371|\n372|        table = autosummary_table('')\n373|        real_table = nodes.table('', classes=['longtable'])\n374|        table.append(real_table)\n375|        group = nodes.tgroup('', cols=2)\n376|        real_table.append(group)\n377|        group.append(nodes.colspec('', colwidth=10))\n378|        group.append(nodes.colspec('', colwidth=90))\n379|        body = nodes.tbody('')\n380|        group.append(body)\n381|\n382|        def append_row(*column_texts: str) -> None:\n383|            row = nodes.row('')\n384|            source, line = self.state_machine.get_source_and_line()\n385|            for text in column_texts:\n386|                node = nodes.paragraph('')\n387|                vl = StringList()\n388|                vl.append(text, '%s:%d:<autosummary>' % (source, line))\n389|                with switch_source_input(self.state, vl):\n390|                    self.state.nested_parse(vl, 0, node)\n391|                    try:\n392|                        if isinstance(node[0], nodes.paragraph):\n393|                            node = node[0]\n394|                    except IndexError:\n395|                        pass\n396|                    row.append(nodes.entry('', node))\n397|            body.append(row)\n398|\n399|        for name, sig, summary, real_name in items:\n400|            qualifier = 'obj'\n401|            if 'nosignatures' not in self.options:\n402|                col1 = ':%s:`%s <%s>`\\\\ %s' % (qualifier, name, real_name, rst.escape(sig))\n403|            else:\n404|                col1 = ':%s:`%s <%s>`' % (qualifier, name, real_name)\n405|            col2 = summary\n406|            append_row(col1, col2)\n407|\n408|        return [table_spec, table]\n409|\n410|    def warn(self, msg: str) -> None:\n411|        warnings.warn('Autosummary.warn() is deprecated',\n412|                      RemovedInSphinx40Warning, stacklevel=2)\n413|        logger.warning(msg)\n414|\n415|    @property\n416|    def genopt(self) -> Options:\n417|        warnings.warn('Autosummary.genopt is deprecated',\n418|                      RemovedInSphinx40Warning, stacklevel=2)\n419|        return self.bridge.genopt\n420|\n421|    @property\n422|    def warnings(self) -> List[Node]:\n423|        warnings.warn('Autosummary.warnings is deprecated',\n424|                      RemovedInSphinx40Warning, stacklevel=2)\n425|        return []\n426|\n427|    @property\n428|    def result(self) -> StringList:\n429|        warnings.warn('Autosummary.result is deprecated',\n430|                      RemovedInSphinx40Warning, stacklevel=2)\n431|        return self.bridge.result\n432|\n433|\n434|def strip_arg_typehint(s: str) -> str:\n435|    \"\"\"Strip a type hint from argument definition.\"\"\"\n436|    return s.split(':')[0].strip()\n437|\n438|\n439|def mangle_signature(sig: str, max_chars: int = 30) -> str:\n440|    \"\"\"Reformat a function signature to a more compact form.\"\"\"\n441|    # Strip return type annotation\n...\n\n\n### sphinx/config.py\n...\n71|        if isinstance(value, (list, tuple)):\n72|            return all(item in self.candidates for item in value)\n73|        else:\n74|            return value in self.candidates\n75|\n76|\n77|# RemovedInSphinx40Warning\n78|string_classes = [str]  # type: List\n79|\n80|\n81|class Config:\n82|    \"\"\"Configuration file abstraction.\n83|\n84|    The config object makes the values of all config values available as\n85|    attributes.\n86|\n87|    It is exposed via the :py:attr:`sphinx.application.Application.config` and\n88|    :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n89|    to get the value of :confval:`language`, use either ``app.config.language``\n90|    or ``env.config.language``.\n91|    \"\"\"\n92|\n93|    # the values are: (default, what needs to be rebuilt if changed)\n94|\n95|    # If you add a value here, don't forget to include it in the\n96|    # quickstart.py file template as well as in the docs!\n97|\n98|    config_values = {\n99|        # general options\n100|        'project': ('Python', 'env', []),\n101|        'author': ('unknown', 'env', []),\n102|        'copyright': ('', 'html', []),\n103|        'version': ('', 'env', []),\n104|        'release': ('', 'env', []),\n105|        'today': ('', 'env', []),\n106|        # the real default is locale-dependent\n107|        'today_fmt': (None, 'env', [str]),\n108|\n109|        'language': (None, 'env', [str]),\n110|        'locale_dirs': (['locales'], 'env', []),\n111|        'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n112|\n113|        'master_doc': ('index', 'env', []),\n114|        'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n115|        'source_encoding': ('utf-8-sig', 'env', []),\n116|        'source_parsers': ({}, 'env', []),\n117|        'exclude_patterns': ([], 'env', []),\n118|        'default_role': (None, 'env', [str]),\n119|        'add_function_parentheses': (True, 'env', []),\n120|        'add_module_names': (True, 'env', []),\n121|        'trim_footnote_reference_space': (False, 'env', []),\n122|        'show_authors': (False, 'env', []),\n123|        'pygments_style': (None, 'html', [str]),\n124|        'highlight_language': ('default', 'env', []),\n125|        'highlight_options': ({}, 'env', []),\n126|        'templates_path': ([], 'html', []),\n127|        'template_bridge': (None, 'html', [str]),\n128|        'keep_warnings': (False, 'env', []),\n129|        'suppress_warnings': ([], 'env', []),\n130|        'modindex_common_prefix': ([], 'html', []),\n131|        'rst_epilog': (None, 'env', [str]),\n132|        'rst_prolog': (None, 'env', [str]),\n133|        'trim_doctest_flags': (True, 'env', []),\n134|        'primary_domain': ('py', 'env', [NoneType]),   # type: ignore\n135|        'needs_sphinx': (None, None, [str]),\n136|        'needs_extensions': ({}, None, []),\n137|        'manpages_url': (None, 'env', []),\n138|        'nitpicky': (False, None, []),\n139|        'nitpick_ignore': ([], None, []),\n140|        'numfig': (False, 'env', []),\n141|        'numfig_secnum_depth': (1, 'env', []),\n142|        'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n143|\n144|        'math_number_all': (False, 'env', []),\n145|        'math_eqref_format': (None, 'env', [str]),\n146|        'math_numfig': (True, 'env', []),\n147|        'tls_verify': (True, 'env', []),\n148|        'tls_cacerts': (None, 'env', []),\n149|        'user_agent': (None, 'env', [str]),\n150|        'smartquotes': (True, 'env', []),\n151|        'smartquotes_action': ('qDe', 'env', []),\n152|        'smartquotes_excludes': ({'languages': ['ja'],\n153|                                  'builders': ['man', 'text']},\n154|                                 'env', []),\n155|    }  # type: Dict[str, Tuple]\n156|\n157|    def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:\n158|        self.overrides = dict(overrides)\n159|        self.values = Config.config_values.copy()\n160|        self._raw_config = config\n161|        self.setup = config.get('setup', None)  # type: Callable\n162|\n163|        if 'extensions' in self.overrides:\n164|            if isinstance(self.overrides['extensions'], str):\n165|                config['extensions'] = self.overrides.pop('extensions').split(',')\n166|            else:\n167|                config['extensions'] = self.overrides.pop('extensions')\n168|        self.extensions = config.get('extensions', [])  # type: List[str]\n169|\n170|    @classmethod\n171|    def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> \"Config\":\n172|        \"\"\"Create a Config object from configuration file.\"\"\"\n173|        filename = path.join(confdir, CONFIG_FILENAME)\n174|        namespace = eval_config_file(filename, tags)\n175|        return cls(namespace, overrides or {})\n176|\n177|    def convert_overrides(self, name: str, value: Any) -> Any:\n178|        if not isinstance(value, str):\n179|            return value\n180|        else:\n181|            defvalue = self.values[name][0]\n182|            if self.values[name][2] == Any:\n183|                return value\n184|            elif type(defvalue) is bool or self.values[name][2] == [bool]:\n185|                if value == '0':\n186|                    # given falsy string from command line option\n187|                    return False\n188|                else:\n189|                    return bool(value)\n190|            elif isinstance(defvalue, dict):\n191|                raise ValueError(__('cannot override dictionary config setting %r, '\n192|                                    'ignoring (use %r to set individual elements)') %\n193|                                 (name, name + '.key=value'))\n194|            elif isinstance(defvalue, list):\n195|                return value.split(',')\n196|            elif isinstance(defvalue, int):\n197|                try:\n198|                    return int(value)\n199|                except ValueError:\n200|                    raise ValueError(__('invalid number %r for config value %r, ignoring') %\n201|                                     (value, name))\n202|            elif hasattr(defvalue, '__call__'):\n203|                return value\n204|            elif defvalue is not None and not isinstance(defvalue, str):\n205|                raise ValueError(__('cannot override config setting %r with unsupported '\n206|                                    'type, ignoring') % name)\n207|            else:\n208|                return value\n209|\n210|    def pre_init_values(self) -> None:\n211|        \"\"\"\n212|        Initialize some limited config variables before initialize i18n and loading extensions\n213|        \"\"\"\n214|        variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']\n215|        for name in variables:\n216|            try:\n217|                if name in self.overrides:\n218|                    self.__dict__[name] = self.convert_overrides(name, self.overrides[name])\n219|                elif name in self._raw_config:\n220|                    self.__dict__[name] = self._raw_config[name]\n221|            except ValueError as exc:\n222|                logger.warning(\"%s\", exc)\n223|\n224|    def init_values(self) -> None:\n225|        config = self._raw_config\n226|        for valname, value in self.overrides.items():\n227|            try:\n228|                if '.' in valname:\n229|                    realvalname, key = valname.split('.', 1)\n230|                    config.setdefault(realvalname, {})[key] = value\n231|                    continue\n232|                elif valname not in self.values:\n233|                    logger.warning(__('unknown config value %r in override, ignoring'),\n234|                                   valname)\n235|                    continue\n236|                if isinstance(value, str):\n237|                    config[valname] = self.convert_overrides(valname, value)\n238|                else:\n239|                    config[valname] = value\n240|            except ValueError as exc:\n241|                logger.warning(\"%s\", exc)\n242|        for name in config:\n243|            if name in self.values:\n244|                self.__dict__[name] = config[name]\n245|\n246|    def __getattr__(self, name: str) -> Any:\n247|        if name.startswith('_'):\n248|            raise AttributeError(name)\n249|        if name not in self.values:\n250|            raise AttributeError(__('No such config value: %s') % name)\n251|        default = self.values[name][0]\n252|        if hasattr(default, '__call__'):\n253|            return default(self)\n254|        return default\n255|\n256|    def __getitem__(self, name: str) -> str:\n257|        return getattr(self, name)\n258|\n259|    def __setitem__(self, name: str, value: Any) -> None:\n260|        setattr(self, name, value)\n261|\n262|    def __delitem__(self, name: str) -> None:\n263|        delattr(self, name)\n264|\n265|    def __contains__(self, name: str) -> bool:\n266|        return name in self.values\n267|\n268|    def __iter__(self) -> Generator[ConfigValue, None, None]:\n269|        for name, value in self.values.items():\n270|            yield ConfigValue(name, getattr(self, name), value[1])\n271|\n272|    def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:\n273|        if name in self.values:\n274|            raise ExtensionError(__('Config value %r already present') % name)\n275|        else:\n276|            self.values[name] = (default, rebuild, types)\n277|\n278|    def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:\n279|        if isinstance(rebuild, str):\n280|            rebuild = [rebuild]\n281|        return (value for value in self if value.rebuild in rebuild)\n282|\n283|    def __getstate__(self) -> Dict:\n284|        \"\"\"Obtains serializable data for pickling.\"\"\"\n285|        # remove potentially pickling-problematic values from config\n286|        __dict__ = {}\n287|        for key, value in self.__dict__.items():\n288|            if key.startswith('_') or not is_serializable(value):\n289|                pass\n290|            else:\n291|                __dict__[key] = value\n292|\n293|        # create a picklable copy of values list\n294|        __dict__['values'] = {}\n295|        for key, value in self.values.items():\n296|            real_value = getattr(self, key)\n297|            if not is_serializable(real_value):\n298|                # omit unserializable value\n299|                real_value = None\n300|\n301|            # types column is also omitted\n302|            __dict__['values'][key] = (real_value, value[1], None)\n303|\n304|        return __dict__\n305|\n306|    def __setstate__(self, state: Dict) -> None:\n307|        self.__dict__.update(state)\n308|\n309|\n310|def eval_config_file(filename: str, tags: Tags) -> Dict[str, Any]:\n311|    \"\"\"Evaluate a config file.\"\"\"\n312|    namespace = {}  # type: Dict[str, Any]\n313|    namespace['__file__'] = filename\n314|    namespace['tags'] = tags\n315|\n316|    with cd(path.dirname(filename)):\n317|        # during executing config file, current dir is changed to ``confdir``.\n...\n\n\n\n\n###\n\nPlease provide the class name, function or method name, or the exact line numbers that need to be edited.\n### Examples:\n```\nfull_path1/file1.py\nline: 10\nclass: MyClass1\nline: 51\n\nfull_path2/file2.py\nfunction: MyClass2.my_method\nline: 12\n\nfull_path3/file3.py\nfunction: my_function\nline: 24\nline: 156\n```\n\nReturn just the location(s)\n", "response": ["```\nsphinx/ext/autosummary/generate.py\nline: 249\nline: 251\nline: 253\nline: 255\nline: 257\n\nsphinx/ext/autosummary/__init__.py\nclass: Autosummary\nfunction: Autosummary.get_items\nline: 301\nline: 302\n```", "```\nsphinx/ext/autosummary/generate.py\nfunction: generate_autosummary_content\nline: 248\n\nsphinx/ext/autosummary/generate.py\nfunction: get_members\nline: 207\n```", "```\nsphinx/ext/autosummary/generate.py\nfunction: generate_autosummary_content\nline: 249\n\nsphinx/ext/autosummary/generate.py\nfunction: get_members\nline: 207\n```", "```\nsphinx/ext/autosummary/generate.py\nfunction: generate_autosummary_content\nline: 248\nline: 249\nline: 257\n```"], "usage": {"completion_tokens": 199, "prompt_tokens": 8421}}}
