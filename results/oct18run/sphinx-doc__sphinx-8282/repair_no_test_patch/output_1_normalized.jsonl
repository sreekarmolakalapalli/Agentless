{"model_name_or_path": "agentless", "instance_id": "sphinx-doc__sphinx-8282", "model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex a7def03..b1e3709 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -11,7 +11,7 @@\n import re\n from collections import OrderedDict\n from typing import Any, Dict, Iterable\n-from typing import cast\n+from typing import cast, get_overloads\n \n from docutils import nodes\n from docutils.nodes import Element\n@@ -28,7 +28,22 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         if callable(obj):\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj)\n+            if get_overloads(obj):\n+                overloads = get_overloads(obj)\n+                for overload_func in overloads:\n+                    sig = inspect.signature(overload_func)\n+                    for param in sig.parameters.values():\n+                        if param.annotation is not param.empty:\n+                            annotation[param.name] = typing.stringify(param.annotation)\n+                    if sig.return_annotation is not sig.empty:\n+                        annotation['return'] = typing.stringify(sig.return_annotation)\n+            else:\n+                sig = inspect.signature(obj)\n+                for param in sig.parameters.values():\n+                    if param.annotation is not param.empty:\n+                        annotation[param.name] = typing.stringify(param.annotation)\n+                if sig.return_annotation is not sig.empty:\n+                    annotation['return'] = typing.stringify(sig.return_annotation)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -47,24 +62,27 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n         return\n \n     try:\n-        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n-        if signature['module']:\n-            fullname = '.'.join([signature['module'], signature['fullname']])\n-        else:\n-            fullname = signature['fullname']\n+        signatures = [cast(addnodes.desc_signature, sig) for sig in contentnode.parent if isinstance(sig, addnodes.desc_signature)]\n+        fullnames = []\n+        for signature in signatures:\n+            if signature['module']:\n+                fullnames.append('.'.join([signature['module'], signature['fullname']]))\n+            else:\n+                fullnames.append(signature['fullname'])\n     except KeyError:\n         # signature node does not have valid context info for the target object\n         return\n \n-    annotations = app.env.temp_data.get('annotations', {})\n-    if annotations.get(fullname, {}):\n-        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n-        if field_lists == []:\n-            field_list = insert_field_list(contentnode)\n-            field_lists.append(field_list)\n+        annotations = app.env.temp_data.get('annotations', {})\n+        for fullname in fullnames:\n+            if annotations.get(fullname, {}):\n+                field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n+                if field_lists == []:\n+                    field_list = insert_field_list(contentnode)\n+                    field_lists.append(field_list)\n \n-        for field_list in field_lists:\n-            modify_field_list(field_list, annotations[fullname])\n+                for field_list in field_lists:\n+                    modify_field_list(field_list, annotations[fullname])\n \n \n def insert_field_list(node: Element) -> nodes.field_list:\n", "raw_model_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex a7def03..b1e3709 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -11,7 +11,7 @@\n import re\n from collections import OrderedDict\n from typing import Any, Dict, Iterable\n-from typing import cast\n+from typing import cast, get_overloads\n \n from docutils import nodes\n from docutils.nodes import Element\n@@ -28,7 +28,22 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n         if callable(obj):\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj)\n+            if get_overloads(obj):\n+                overloads = get_overloads(obj)\n+                for overload_func in overloads:\n+                    sig = inspect.signature(overload_func)\n+                    for param in sig.parameters.values():\n+                        if param.annotation is not param.empty:\n+                            annotation[param.name] = typing.stringify(param.annotation)\n+                    if sig.return_annotation is not sig.empty:\n+                        annotation['return'] = typing.stringify(sig.return_annotation)\n+            else:\n+                sig = inspect.signature(obj)\n+                for param in sig.parameters.values():\n+                    if param.annotation is not param.empty:\n+                        annotation[param.name] = typing.stringify(param.annotation)\n+                if sig.return_annotation is not sig.empty:\n+                    annotation['return'] = typing.stringify(sig.return_annotation)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -47,24 +62,27 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n         return\n \n     try:\n-        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n-        if signature['module']:\n-            fullname = '.'.join([signature['module'], signature['fullname']])\n-        else:\n-            fullname = signature['fullname']\n+        signatures = [cast(addnodes.desc_signature, sig) for sig in contentnode.parent if isinstance(sig, addnodes.desc_signature)]\n+        fullnames = []\n+        for signature in signatures:\n+            if signature['module']:\n+                fullnames.append('.'.join([signature['module'], signature['fullname']]))\n+            else:\n+                fullnames.append(signature['fullname'])\n     except KeyError:\n         # signature node does not have valid context info for the target object\n         return\n \n-    annotations = app.env.temp_data.get('annotations', {})\n-    if annotations.get(fullname, {}):\n-        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n-        if field_lists == []:\n-            field_list = insert_field_list(contentnode)\n-            field_lists.append(field_list)\n+        annotations = app.env.temp_data.get('annotations', {})\n+        for fullname in fullnames:\n+            if annotations.get(fullname, {}):\n+                field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n+                if field_lists == []:\n+                    field_list = insert_field_list(contentnode)\n+                    field_lists.append(field_list)\n \n-        for field_list in field_lists:\n-            modify_field_list(field_list, annotations[fullname])\n+                for field_list in field_lists:\n+                    modify_field_list(field_list, annotations[fullname])\n \n \n def insert_field_list(node: Element) -> nodes.field_list:\n", "original_file_content": "\"\"\"\n    sphinx.ext.autodoc.typehints\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Generating content for autodoc using typehints\n\n    :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport re\nfrom collections import OrderedDict\nfrom typing import Any, Dict, Iterable\nfrom typing import cast\n\nfrom docutils import nodes\nfrom docutils.nodes import Element\n\nfrom sphinx import addnodes\nfrom sphinx.application import Sphinx\nfrom sphinx.util import inspect, typing\n\n\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n    \"\"\"Record type hints to env object.\"\"\"\n    try:\n        if callable(obj):\n            annotations = app.env.temp_data.setdefault('annotations', {})\n            annotation = annotations.setdefault(name, OrderedDict())\n            sig = inspect.signature(obj)\n            for param in sig.parameters.values():\n                if param.annotation is not param.empty:\n                    annotation[param.name] = typing.stringify(param.annotation)\n            if sig.return_annotation is not sig.empty:\n                annotation['return'] = typing.stringify(sig.return_annotation)\n    except (TypeError, ValueError):\n        pass\n\n\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n    if domain != 'py':\n        return\n    if app.config.autodoc_typehints != 'description':\n        return\n    if objtype == 'class' and app.config.autoclass_content not in ('init', 'both'):\n        return\n\n    try:\n        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n        if signature['module']:\n            fullname = '.'.join([signature['module'], signature['fullname']])\n        else:\n            fullname = signature['fullname']\n    except KeyError:\n        # signature node does not have valid context info for the target object\n        return\n\n    annotations = app.env.temp_data.get('annotations', {})\n    if annotations.get(fullname, {}):\n        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n        if field_lists == []:\n            field_list = insert_field_list(contentnode)\n            field_lists.append(field_list)\n\n        for field_list in field_lists:\n            modify_field_list(field_list, annotations[fullname])\n\n\ndef insert_field_list(node: Element) -> nodes.field_list:\n    field_list = nodes.field_list()\n    desc = [n for n in node if isinstance(n, addnodes.desc)]\n    if desc:\n        # insert just before sub object descriptions (ex. methods, nested classes, etc.)\n        index = node.index(desc[0])\n        node.insert(index - 1, [field_list])\n    else:\n        node += field_list\n\n    return field_list\n\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n    arguments = {}  # type: Dict[str, Dict[str, bool]]\n    fields = cast(Iterable[nodes.field], node)\n    for field in fields:\n        field_name = field[0].astext()\n        parts = re.split(' +', field_name)\n        if parts[0] == 'param':\n            if len(parts) == 2:\n                # :param xxx:\n                arg = arguments.setdefault(parts[1], {})\n                arg['param'] = True\n            elif len(parts) > 2:\n                # :param xxx yyy:\n                name = ' '.join(parts[2:])\n                arg = arguments.setdefault(name, {})\n                arg['param'] = True\n                arg['type'] = True\n        elif parts[0] == 'type':\n            name = ' '.join(parts[1:])\n            arg = arguments.setdefault(name, {})\n            arg['type'] = True\n        elif parts[0] == 'rtype':\n            arguments['return'] = {'type': True}\n\n    for name, annotation in annotations.items():\n        if name == 'return':\n            continue\n\n        arg = arguments.get(name, {})\n        if not arg.get('type'):\n            field = nodes.field()\n            field += nodes.field_name('', 'type ' + name)\n            field += nodes.field_body('', nodes.paragraph('', annotation))\n            node += field\n        if not arg.get('param'):\n            field = nodes.field()\n            field += nodes.field_name('', 'param ' + name)\n            field += nodes.field_body('', nodes.paragraph('', ''))\n            node += field\n\n    if 'return' in annotations and 'return' not in arguments:\n        field = nodes.field()\n        field += nodes.field_name('', 'rtype')\n        field += nodes.field_body('', nodes.paragraph('', annotation))\n        node += field\n\n\ndef setup(app: Sphinx) -> Dict[str, Any]:\n    app.connect('autodoc-process-signature', record_typehints)\n    app.connect('object-description-transform', merge_typehints)\n\n    return {\n        'version': 'builtin',\n        'parallel_read_safe': True,\n        'parallel_write_safe': True,\n    }", "normalized_patch": "diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py\nindex 7b779e7..882997f 100644\n--- a/sphinx/ext/autodoc/typehints.py\n+++ b/sphinx/ext/autodoc/typehints.py\n@@ -1,7 +1,7 @@\n import re\n from collections import OrderedDict\n from typing import Any, Dict, Iterable\n-from typing import cast\n+from typing import cast, get_overloads\n from docutils import nodes\n from docutils.nodes import Element\n from sphinx import addnodes\n@@ -12,7 +12,22 @@ def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any, options: Di\n         if callable(obj):\n             annotations = app.env.temp_data.setdefault('annotations', {})\n             annotation = annotations.setdefault(name, OrderedDict())\n-            sig = inspect.signature(obj)\n+            if get_overloads(obj):\n+                overloads = get_overloads(obj)\n+                for overload_func in overloads:\n+                    sig = inspect.signature(overload_func)\n+                    for param in sig.parameters.values():\n+                        if param.annotation is not param.empty:\n+                            annotation[param.name] = typing.stringify(param.annotation)\n+                    if sig.return_annotation is not sig.empty:\n+                        annotation['return'] = typing.stringify(sig.return_annotation)\n+            else:\n+                sig = inspect.signature(obj)\n+                for param in sig.parameters.values():\n+                    if param.annotation is not param.empty:\n+                        annotation[param.name] = typing.stringify(param.annotation)\n+                if sig.return_annotation is not sig.empty:\n+                    annotation['return'] = typing.stringify(sig.return_annotation)\n             for param in sig.parameters.values():\n                 if param.annotation is not param.empty:\n                     annotation[param.name] = typing.stringify(param.annotation)\n@@ -28,21 +43,24 @@ def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element\n     if objtype == 'class' and app.config.autoclass_content not in ('init', 'both'):\n         return\n     try:\n-        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n-        if signature['module']:\n-            fullname = '.'.join([signature['module'], signature['fullname']])\n-        else:\n-            fullname = signature['fullname']\n+        signatures = [cast(addnodes.desc_signature, sig) for sig in contentnode.parent if isinstance(sig, addnodes.desc_signature)]\n+        fullnames = []\n+        for signature in signatures:\n+            if signature['module']:\n+                fullnames.append('.'.join([signature['module'], signature['fullname']]))\n+            else:\n+                fullnames.append(signature['fullname'])\n     except KeyError:\n         return\n-    annotations = app.env.temp_data.get('annotations', {})\n-    if annotations.get(fullname, {}):\n-        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n-        if field_lists == []:\n-            field_list = insert_field_list(contentnode)\n-            field_lists.append(field_list)\n-        for field_list in field_lists:\n-            modify_field_list(field_list, annotations[fullname])\n+        annotations = app.env.temp_data.get('annotations', {})\n+        for fullname in fullnames:\n+            if annotations.get(fullname, {}):\n+                field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n+                if field_lists == []:\n+                    field_list = insert_field_list(contentnode)\n+                    field_lists.append(field_list)\n+                for field_list in field_lists:\n+                    modify_field_list(field_list, annotations[fullname])\n def insert_field_list(node: Element) -> nodes.field_list:\n     field_list = nodes.field_list()\n     desc = [n for n in node if isinstance(n, addnodes.desc)]\n"}
