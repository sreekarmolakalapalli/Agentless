{"model_name_or_path": "agentless", "instance_id": "scikit-learn__scikit-learn-11281", "model_patch": "diff --git a/sklearn/mixture/base.py b/sklearn/mixture/base.py\nindex 721709f..ae497d3 100644\n--- a/sklearn/mixture/base.py\n+++ b/sklearn/mixture/base.py\n@@ -170,6 +170,65 @@ class BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n         pass\n \n     def fit(self, X, y=None):\n+        self.labels_ = None\n+        X = _check_X(X, self.n_components, ensure_min_samples=2)\n+        self._check_initial_parameters(X)\n+\n+        # if we enable warm_start, we will have a unique initialisation\n+        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n+        n_init = self.n_init if do_init else 1\n+\n+        max_lower_bound = -np.infty\n+        self.converged_ = False\n+\n+        random_state = check_random_state(self.random_state)\n+\n+        n_samples, _ = X.shape\n+        for init in range(n_init):\n+            self._print_verbose_msg_init_beg(init)\n+\n+            if do_init:\n+                self._initialize_parameters(X, random_state)\n+                self.lower_bound_ = -np.infty\n+\n+            for n_iter in range(1, self.max_iter + 1):\n+                prev_lower_bound = self.lower_bound_\n+\n+                log_prob_norm, log_resp = self._e_step(X)\n+                self._m_step(X, log_resp)\n+                self.lower_bound_ = self._compute_lower_bound(\n+                    log_resp, log_prob_norm)\n+\n+                change = self.lower_bound_ - prev_lower_bound\n+                self._print_verbose_msg_iter_end(n_iter, change)\n+\n+                if abs(change) < self.tol:\n+                    self.converged_ = True\n+                    break\n+\n+            self._print_verbose_msg_init_end(self.lower_bound_)\n+\n+            if self.lower_bound_ > max_lower_bound:\n+                max_lower_bound = self.lower_bound_\n+                best_params = self._get_parameters()\n+                best_n_iter = n_iter\n+\n+        if not self.converged_:\n+            warnings.warn('Initialization %d did not converge. '\n+                          'Try different init parameters, '\n+                          'or increase max_iter, tol '\n+                          'or check for degenerate data.'\n+                          % (init + 1), ConvergenceWarning)\n+\n+        self._set_parameters(best_params)\n+        self.n_iter_ = best_n_iter\n+\n+        self.labels_ = self.predict(X)\n+\n+        return self\n+\n+    def fit_predict(self, X, y=None):\n+        return self.fit(X, y).labels_\n         \"\"\"Estimate model parameters with the EM algorithm.\n \n         The method fit the model `n_init` times and set the parameters with\n@@ -323,6 +382,7 @@ class BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n         return self.score_samples(X).mean()\n \n     def predict(self, X):\n+        self.labels_ = self._estimate_weighted_log_prob(X).argmax(axis=1)\n         \"\"\"Predict the labels for the data samples in X using trained model.\n \n         Parameters\n@@ -500,4 +560,4 @@ class BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n             print(\"Initialization converged: %s\" % self.converged_)\n         elif self.verbose >= 2:\n             print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n-                  (self.converged_, time() - self._init_prev_time, ll))\n+                  (self.converged_, time() - self._init_prev_time, ll))\n", "raw_model_patch": "diff --git a/sklearn/mixture/base.py b/sklearn/mixture/base.py\nindex 721709f..ae497d3 100644\n--- a/sklearn/mixture/base.py\n+++ b/sklearn/mixture/base.py\n@@ -170,6 +170,65 @@ class BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n         pass\n \n     def fit(self, X, y=None):\n+        self.labels_ = None\n+        X = _check_X(X, self.n_components, ensure_min_samples=2)\n+        self._check_initial_parameters(X)\n+\n+        # if we enable warm_start, we will have a unique initialisation\n+        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n+        n_init = self.n_init if do_init else 1\n+\n+        max_lower_bound = -np.infty\n+        self.converged_ = False\n+\n+        random_state = check_random_state(self.random_state)\n+\n+        n_samples, _ = X.shape\n+        for init in range(n_init):\n+            self._print_verbose_msg_init_beg(init)\n+\n+            if do_init:\n+                self._initialize_parameters(X, random_state)\n+                self.lower_bound_ = -np.infty\n+\n+            for n_iter in range(1, self.max_iter + 1):\n+                prev_lower_bound = self.lower_bound_\n+\n+                log_prob_norm, log_resp = self._e_step(X)\n+                self._m_step(X, log_resp)\n+                self.lower_bound_ = self._compute_lower_bound(\n+                    log_resp, log_prob_norm)\n+\n+                change = self.lower_bound_ - prev_lower_bound\n+                self._print_verbose_msg_iter_end(n_iter, change)\n+\n+                if abs(change) < self.tol:\n+                    self.converged_ = True\n+                    break\n+\n+            self._print_verbose_msg_init_end(self.lower_bound_)\n+\n+            if self.lower_bound_ > max_lower_bound:\n+                max_lower_bound = self.lower_bound_\n+                best_params = self._get_parameters()\n+                best_n_iter = n_iter\n+\n+        if not self.converged_:\n+            warnings.warn('Initialization %d did not converge. '\n+                          'Try different init parameters, '\n+                          'or increase max_iter, tol '\n+                          'or check for degenerate data.'\n+                          % (init + 1), ConvergenceWarning)\n+\n+        self._set_parameters(best_params)\n+        self.n_iter_ = best_n_iter\n+\n+        self.labels_ = self.predict(X)\n+\n+        return self\n+\n+    def fit_predict(self, X, y=None):\n+        return self.fit(X, y).labels_\n         \"\"\"Estimate model parameters with the EM algorithm.\n \n         The method fit the model `n_init` times and set the parameters with\n@@ -323,6 +382,7 @@ class BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n         return self.score_samples(X).mean()\n \n     def predict(self, X):\n+        self.labels_ = self._estimate_weighted_log_prob(X).argmax(axis=1)\n         \"\"\"Predict the labels for the data samples in X using trained model.\n \n         Parameters\n@@ -500,4 +560,4 @@ class BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n             print(\"Initialization converged: %s\" % self.converged_)\n         elif self.verbose >= 2:\n             print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n-                  (self.converged_, time() - self._init_prev_time, ll))\n+                  (self.converged_, time() - self._init_prev_time, ll))\n", "original_file_content": "\"\"\"Base class for mixture models.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nfrom __future__ import print_function\n\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom time import time\n\nimport numpy as np\n\nfrom .. import cluster\nfrom ..base import BaseEstimator\nfrom ..base import DensityMixin\nfrom ..externals import six\nfrom ..exceptions import ConvergenceWarning\nfrom ..utils import check_array, check_random_state\nfrom ..utils.fixes import logsumexp\n\n\ndef _check_shape(param, param_shape, name):\n    \"\"\"Validate the shape of the input parameter 'param'.\n\n    Parameters\n    ----------\n    param : array\n\n    param_shape : tuple\n\n    name : string\n    \"\"\"\n    param = np.array(param)\n    if param.shape != param_shape:\n        raise ValueError(\"The parameter '%s' should have the shape of %s, \"\n                         \"but got %s\" % (name, param_shape, param.shape))\n\n\ndef _check_X(X, n_components=None, n_features=None, ensure_min_samples=1):\n    \"\"\"Check the input data X.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    n_components : int\n\n    Returns\n    -------\n    X : array, shape (n_samples, n_features)\n    \"\"\"\n    X = check_array(X, dtype=[np.float64, np.float32],\n                    ensure_min_samples=ensure_min_samples)\n    if n_components is not None and X.shape[0] < n_components:\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))", "normalized_patch": "diff --git a/sklearn/mixture/base.py b/sklearn/mixture/base.py\nindex 59e4e9c..3b791fb 100644\n--- a/sklearn/mixture/base.py\n+++ b/sklearn/mixture/base.py\n@@ -64,6 +64,43 @@ class BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n     def _initialize(self, X, resp):\n         pass\n     def fit(self, X, y=None):\n+        self.labels_ = None\n+        X = _check_X(X, self.n_components, ensure_min_samples=2)\n+        self._check_initial_parameters(X)\n+        do_init = not (self.warm_start and hasattr(self, 'converged_'))\n+        n_init = self.n_init if do_init else 1\n+        max_lower_bound = -np.infty\n+        self.converged_ = False\n+        random_state = check_random_state(self.random_state)\n+        (n_samples, _) = X.shape\n+        for init in range(n_init):\n+            self._print_verbose_msg_init_beg(init)\n+            if do_init:\n+                self._initialize_parameters(X, random_state)\n+                self.lower_bound_ = -np.infty\n+            for n_iter in range(1, self.max_iter + 1):\n+                prev_lower_bound = self.lower_bound_\n+                (log_prob_norm, log_resp) = self._e_step(X)\n+                self._m_step(X, log_resp)\n+                self.lower_bound_ = self._compute_lower_bound(log_resp, log_prob_norm)\n+                change = self.lower_bound_ - prev_lower_bound\n+                self._print_verbose_msg_iter_end(n_iter, change)\n+                if abs(change) < self.tol:\n+                    self.converged_ = True\n+                    break\n+            self._print_verbose_msg_init_end(self.lower_bound_)\n+            if self.lower_bound_ > max_lower_bound:\n+                max_lower_bound = self.lower_bound_\n+                best_params = self._get_parameters()\n+                best_n_iter = n_iter\n+        if not self.converged_:\n+            warnings.warn('Initialization %d did not converge. Try different init parameters, or increase max_iter, tol or check for degenerate data.' % (init + 1), ConvergenceWarning)\n+        self._set_parameters(best_params)\n+        self.n_iter_ = best_n_iter\n+        self.labels_ = self.predict(X)\n+        return self\n+    def fit_predict(self, X, y=None):\n+        return self.fit(X, y).labels_\n         X = _check_X(X, self.n_components, ensure_min_samples=2)\n         self._check_initial_parameters(X)\n         do_init = not (self.warm_start and hasattr(self, 'converged_'))\n@@ -119,6 +156,7 @@ class BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n     def score(self, X, y=None):\n         return self.score_samples(X).mean()\n     def predict(self, X):\n+        self.labels_ = self._estimate_weighted_log_prob(X).argmax(axis=1)\n         self._check_is_fitted()\n         X = _check_X(X, None, self.means_.shape[1])\n         return self._estimate_weighted_log_prob(X).argmax(axis=1)\n"}
