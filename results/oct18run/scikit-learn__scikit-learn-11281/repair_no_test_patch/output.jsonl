{"instance_id": "scikit-learn__scikit-learn-11281", "raw_output": ["To address the issue of making mixture models more like clusterers, we need to add the `labels_` attribute and the `fit_predict` method to the mixture models. Here are the necessary changes:\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n>>>>>>> REPLACE\n    def bic(self, X):\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n>>>>>>> REPLACE\n    def bic(self, X):\n```\n\nThese changes add the `fit_predict` method to both `GaussianMixture` and `BayesianGaussianMixture` classes, and ensure that the `labels_` attribute is set after fitting the model. This makes the mixture models more consistent with the clusterer interface.", "To address the issue of making mixture models more like clusterers, we need to perform the following changes:\n\n1. Add a `fit_predict` method to the `BaseMixture` class.\n2. Ensure the `labels_` attribute is stored in the mixture models.\n3. Update the documentation to reflect these changes.\n4. Optionally, change `n_components` to `n_clusters` for consistency with other clusterer interfaces.\n\nBelow are the *SEARCH/REPLACE* edits to achieve these changes:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n=======\n    labels_ : array-like, shape (n_samples,)\n        Labels of each point indicating which mixture component it belongs to.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n=======\n    labels_ : array-like, shape (n_samples,)\n        Labels of each point indicating which mixture component it belongs to.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n>>>>>>> REPLACE\n```\n\nThese changes will add the missing `fit_predict` method, ensure `labels_` are stored, and update the documentation to reflect these changes. This should make the mixture models' API more consistent with that of clusterers.", "To address the issue of making mixture models more like clusterers by adding a `fit_predict` method and storing the `labels_` of the training data, we need to edit the `GaussianMixture` and `BayesianGaussianMixture` classes. We'll add a `fit_predict` method and ensure `labels_` are stored after fitting.\n\nHere are the necessary changes:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n=======\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n        self.labels_ = self.predict(X)\n\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\nThese changes will ensure the mixture models have a `fit_predict` method and store the `labels_` of the training data, making them more consistent with the clustering interface.", "Here's how to align the mixture models with a clusterer-compatible interface based on your issue statement:\n\n1. Add `n_clusters` parameter to the `GaussianMixture` class.\n2. Implement the `fit_predict` method to get the predicted labels.\n3. Provide `labels_` as an attribute after fitting the model.\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    tol : float, defaults to 1e-3.\n=======\n    n_clusters : int, optional, defaults to None.\n        The number of mixture components. If provided, it will override\n        `n_components`.\n\n    tol : float, defaults to 1e-3.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        super(GaussianMixture, self).__init__(\n=======\n        if n_clusters is not None:\n            n_components = n_clusters\n        super(GaussianMixture, self).__init__(\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\nWithin the `fit` method, ensure that `self.labels_` is set after calling `self.predict(X)` to store the labels of the training data.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n>>>>>>> REPLACE\n```\n\nThis will make the mixture models more compatible with the clusterer interface.", "```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n=======\n    def __init__(self, n_clusters=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_clusters=n_clusters, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n        self.n_components = n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_clusters, tol, reg_covar,\n>>>>>>> REPLACE\n```", "```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _check_parameters(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def _check_parameters(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n=======\n    @property\n    def labels_(self):\n        \"\"\"Return the labels of the training data.\"\"\"\n        self._check_is_fitted()\n        return self.predict(self._X)\n\n    def predict(self, X):\n>>>>>>> REPLACE\n```", "To address the issue of making mixture models have a clusterer-compatible interface, we need to introduce the `fit_predict` method and `labels_` attribute to the mixture model classes. Here are the changes needed:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and then predict the labels for X.\n        \n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n        \n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def predict(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm and store the labels.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        super().fit(X, y)\n        self.labels_ = self.predict(X)\n        return self\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the variational inference algorithm and store the labels.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        super().fit(X, y)\n        self.labels_ = self.predict(X)\n        return self\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```", "The issue describes several discrepancies between the interface of mixture models and traditional clusterers. We can address these by making the following changes:\n\n1. Replace `n_components` with `n_clusters`.\n2. Add `labels_` attribute to store the labels of the training data.\n3. Implement a `fit_predict` method.\n\nLet's make these changes in the relevant files.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_clusters = n_components\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n=======\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n        self.labels_ = resp.argmax(axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n\n    def bic(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n=======\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.labels_ = None\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self._estimate_precisions(nk, xk, sk)\n=======\n        self._estimate_precisions(nk, xk, sk)\n        self.labels_ = resp.argmax(axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n>>>>>>> REPLACE\n```\n\nThese changes ensure that the mixture models now have a `clusterer`-compatible interface by:\n- Renaming `n_components` to `n_clusters`.\n- Adding `labels_` attribute.\n- Implementing `fit_predict` method.", "To address the issue of making mixture models have a clusterer-compatible interface, we need to make the following changes:\n\n1. Change the `n_components` parameter to `n_clusters`.\n2. Add the `labels_` attribute to store the labels of the training data.\n3. Implement the `fit_predict` method.\n\nHere are the required *SEARCH/REPLACE* edits to fix the issue:\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n=======\n        self.weights_ = weights if self.weights_init is None else self.weights_init\n        self.means_ = means if self.means_init is None else self.means_init\n        self.labels_ = np.argmax(resp, axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n=======\n        self.weights_, self.means_, self.covariances_ = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type\n        )\n        self.labels_ = np.argmax(log_resp, axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_clusters, tol, reg_covar,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_clusters = n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n=======\n        if self.n_clusters < 1:\n            raise ValueError(\"Invalid value for 'n_clusters': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_clusters)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n=======\n        X = _check_X(X, self.n_clusters, ensure_min_samples=2)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n=======\n            label = cluster.KMeans(n_clusters=self.n_clusters, n_init=1,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n=======\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self.covariances_ = np.empty((self.n_components, n_features,\n=======\n        self.covariances_ = np.empty((self.n_clusters, n_features,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n=======\n            self", "The issue mentioned is about making mixture models have a clusterer-compatible interface. The changes required are:\n\n1. Adding `n_clusters` as an alias for `n_components`.\n2. Storing the `labels_` attribute.\n3. Implementing the `fit_predict` method.\n\nLet's proceed with the necessary modifications.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_components=None, n_clusters=None, tol, reg_covar,\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_components = n_clusters if n_clusters is not None else n_components\n        self.n_clusters = self.n_components\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _check_is_fitted(self):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model using X and then predict the labels for the data samples in X.\n        \n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def _check_is_fitted(self):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_, self.means_, self.covariances_ = (\n=======\n        self.weights_, self.means_, self.covariances_ = ( \n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n=======\n        labels = self._estimate_weighted_log_prob(X).argmax(axis=1)\n        self.labels_ = labels\n        return labels\n>>>>>>> REPLACE\n```\n\nThis should address the issue by:\n1. Allowing `n_clusters` to be used instead of `n_components`.\n2. Storing the labels of the training data in the `labels_` attribute.\n3. Adding the `fit_predict` method to align with the clusterer interface."], "all_generations": [["To address the issue of making mixture models more like clusterers, we need to add the `labels_` attribute and the `fit_predict` method to the mixture models. Here are the necessary changes:\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n>>>>>>> REPLACE\n    def bic(self, X):\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n>>>>>>> REPLACE\n    def bic(self, X):\n```\n\nThese changes add the `fit_predict` method to both `GaussianMixture` and `BayesianGaussianMixture` classes, and ensure that the `labels_` attribute is set after fitting the model. This makes the mixture models more consistent with the clusterer interface.", "To address the issue of making mixture models more like clusterers, we need to perform the following changes:\n\n1. Add a `fit_predict` method to the `BaseMixture` class.\n2. Ensure the `labels_` attribute is stored in the mixture models.\n3. Update the documentation to reflect these changes.\n4. Optionally, change `n_components` to `n_clusters` for consistency with other clusterer interfaces.\n\nBelow are the *SEARCH/REPLACE* edits to achieve these changes:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n=======\n    labels_ : array-like, shape (n_samples,)\n        Labels of each point indicating which mixture component it belongs to.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n=======\n    labels_ : array-like, shape (n_samples,)\n        Labels of each point indicating which mixture component it belongs to.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n>>>>>>> REPLACE\n```\n\nThese changes will add the missing `fit_predict` method, ensure `labels_` are stored, and update the documentation to reflect these changes. This should make the mixture models' API more consistent with that of clusterers.", "To address the issue of making mixture models more like clusterers by adding a `fit_predict` method and storing the `labels_` of the training data, we need to edit the `GaussianMixture` and `BayesianGaussianMixture` classes. We'll add a `fit_predict` method and ensure `labels_` are stored after fitting.\n\nHere are the necessary changes:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n=======\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n        self.labels_ = self.predict(X)\n\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\nThese changes will ensure the mixture models have a `fit_predict` method and store the `labels_` of the training data, making them more consistent with the clustering interface.", "Here's how to align the mixture models with a clusterer-compatible interface based on your issue statement:\n\n1. Add `n_clusters` parameter to the `GaussianMixture` class.\n2. Implement the `fit_predict` method to get the predicted labels.\n3. Provide `labels_` as an attribute after fitting the model.\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    tol : float, defaults to 1e-3.\n=======\n    n_clusters : int, optional, defaults to None.\n        The number of mixture components. If provided, it will override\n        `n_components`.\n\n    tol : float, defaults to 1e-3.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        super(GaussianMixture, self).__init__(\n=======\n        if n_clusters is not None:\n            n_components = n_clusters\n        super(GaussianMixture, self).__init__(\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\nWithin the `fit` method, ensure that `self.labels_` is set after calling `self.predict(X)` to store the labels of the training data.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n>>>>>>> REPLACE\n```\n\nThis will make the mixture models more compatible with the clusterer interface.", "```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n=======\n    def __init__(self, n_clusters=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_clusters=n_clusters, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n        self.n_components = n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_clusters, tol, reg_covar,\n>>>>>>> REPLACE\n```", "```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _check_parameters(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def _check_parameters(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n=======\n    @property\n    def labels_(self):\n        \"\"\"Return the labels of the training data.\"\"\"\n        self._check_is_fitted()\n        return self.predict(self._X)\n\n    def predict(self, X):\n>>>>>>> REPLACE\n```", "To address the issue of making mixture models have a clusterer-compatible interface, we need to introduce the `fit_predict` method and `labels_` attribute to the mixture model classes. Here are the changes needed:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and then predict the labels for X.\n        \n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n        \n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def predict(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm and store the labels.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        super().fit(X, y)\n        self.labels_ = self.predict(X)\n        return self\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the variational inference algorithm and store the labels.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        super().fit(X, y)\n        self.labels_ = self.predict(X)\n        return self\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```", "The issue describes several discrepancies between the interface of mixture models and traditional clusterers. We can address these by making the following changes:\n\n1. Replace `n_components` with `n_clusters`.\n2. Add `labels_` attribute to store the labels of the training data.\n3. Implement a `fit_predict` method.\n\nLet's make these changes in the relevant files.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_clusters = n_components\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n=======\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n        self.labels_ = resp.argmax(axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n\n    def bic(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n=======\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.labels_ = None\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self._estimate_precisions(nk, xk, sk)\n=======\n        self._estimate_precisions(nk, xk, sk)\n        self.labels_ = resp.argmax(axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n>>>>>>> REPLACE\n```\n\nThese changes ensure that the mixture models now have a `clusterer`-compatible interface by:\n- Renaming `n_components` to `n_clusters`.\n- Adding `labels_` attribute.\n- Implementing `fit_predict` method.", "To address the issue of making mixture models have a clusterer-compatible interface, we need to make the following changes:\n\n1. Change the `n_components` parameter to `n_clusters`.\n2. Add the `labels_` attribute to store the labels of the training data.\n3. Implement the `fit_predict` method.\n\nHere are the required *SEARCH/REPLACE* edits to fix the issue:\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n=======\n        self.weights_ = weights if self.weights_init is None else self.weights_init\n        self.means_ = means if self.means_init is None else self.means_init\n        self.labels_ = np.argmax(resp, axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n=======\n        self.weights_, self.means_, self.covariances_ = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type\n        )\n        self.labels_ = np.argmax(log_resp, axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_clusters, tol, reg_covar,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_clusters = n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n=======\n        if self.n_clusters < 1:\n            raise ValueError(\"Invalid value for 'n_clusters': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_clusters)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n=======\n        X = _check_X(X, self.n_clusters, ensure_min_samples=2)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n=======\n            label = cluster.KMeans(n_clusters=self.n_clusters, n_init=1,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n=======\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self.covariances_ = np.empty((self.n_components, n_features,\n=======\n        self.covariances_ = np.empty((self.n_clusters, n_features,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n=======\n            self", "The issue mentioned is about making mixture models have a clusterer-compatible interface. The changes required are:\n\n1. Adding `n_clusters` as an alias for `n_components`.\n2. Storing the `labels_` attribute.\n3. Implementing the `fit_predict` method.\n\nLet's proceed with the necessary modifications.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_components=None, n_clusters=None, tol, reg_covar,\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_components = n_clusters if n_clusters is not None else n_components\n        self.n_clusters = self.n_components\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _check_is_fitted(self):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model using X and then predict the labels for the data samples in X.\n        \n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def _check_is_fitted(self):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_, self.means_, self.covariances_ = (\n=======\n        self.weights_, self.means_, self.covariances_ = ( \n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n=======\n        labels = self._estimate_weighted_log_prob(X).argmax(axis=1)\n        self.labels_ = labels\n        return labels\n>>>>>>> REPLACE\n```\n\nThis should address the issue by:\n1. Allowing `n_clusters` to be used instead of `n_components`.\n2. Storing the labels of the training data in the `labels_` attribute.\n3. Adding the `fit_predict` method to align with the clusterer interface."]], "try_count": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "traj": [{"response": "To address the issue of making mixture models more like clusterers, we need to add the `labels_` attribute and the `fit_predict` method to the mixture models. Here are the necessary changes:\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n>>>>>>> REPLACE\n    def bic(self, X):\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n>>>>>>> REPLACE\n    def bic(self, X):\n```\n\nThese changes add the `fit_predict` method to both `GaussianMixture` and `BayesianGaussianMixture` classes, and ensure that the `labels_` attribute is set after fitting the model. This makes the mixture models more consistent with the clusterer interface.", "usage": {"completion_tokens": 428, "prompt_tokens": 13693}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue of making mixture models more like clusterers, we need to perform the following changes:\n\n1. Add a `fit_predict` method to the `BaseMixture` class.\n2. Ensure the `labels_` attribute is stored in the mixture models.\n3. Update the documentation to reflect these changes.\n4. Optionally, change `n_components` to `n_clusters` for consistency with other clusterer interfaces.\n\nBelow are the *SEARCH/REPLACE* edits to achieve these changes:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n=======\n    labels_ : array-like, shape (n_samples,)\n        Labels of each point indicating which mixture component it belongs to.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        self.labels_ = self.predict(X)\n        return self.labels_\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n=======\n    labels_ : array-like, shape (n_samples,)\n        Labels of each point indicating which mixture component it belongs to.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n>>>>>>> REPLACE\n```\n\nThese changes will add the missing `fit_predict` method, ensure `labels_` are stored, and update the documentation to reflect these changes. This should make the mixture models' API more consistent with that of clusterers.", "usage": {"completion_tokens": 5493, "prompt_tokens": 13693}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue of making mixture models more like clusterers by adding a `fit_predict` method and storing the `labels_` of the training data, we need to edit the `GaussianMixture` and `BayesianGaussianMixture` classes. We'll add a `fit_predict` method and ensure `labels_` are stored after fitting.\n\nHere are the necessary changes:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n=======\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n        self.labels_ = self.predict(X)\n\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and return the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\nThese changes will ensure the mixture models have a `fit_predict` method and store the `labels_` of the training data, making them more consistent with the clustering interface.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "Here's how to align the mixture models with a clusterer-compatible interface based on your issue statement:\n\n1. Add `n_clusters` parameter to the `GaussianMixture` class.\n2. Implement the `fit_predict` method to get the predicted labels.\n3. Provide `labels_` as an attribute after fitting the model.\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    tol : float, defaults to 1e-3.\n=======\n    n_clusters : int, optional, defaults to None.\n        The number of mixture components. If provided, it will override\n        `n_components`.\n\n    tol : float, defaults to 1e-3.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        super(GaussianMixture, self).__init__(\n=======\n        if n_clusters is not None:\n            n_components = n_clusters\n        super(GaussianMixture, self).__init__(\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.labels_\n>>>>>>> REPLACE\n```\n\nWithin the `fit` method, ensure that `self.labels_` is set after calling `self.predict(X)` to store the labels of the training data.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        return self\n=======\n        self.labels_ = self.predict(X)\n        return self\n>>>>>>> REPLACE\n```\n\nThis will make the mixture models more compatible with the clusterer interface.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n=======\n    def __init__(self, n_clusters=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_clusters=n_clusters, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n        self.n_components = n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_clusters, tol, reg_covar,\n>>>>>>> REPLACE\n```", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _check_parameters(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def _check_parameters(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n=======\n    @property\n    def labels_(self):\n        \"\"\"Return the labels of the training data.\"\"\"\n        self._check_is_fitted()\n        return self.predict(self._X)\n\n    def predict(self, X):\n>>>>>>> REPLACE\n```", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue of making mixture models have a clusterer-compatible interface, we need to introduce the `fit_predict` method and `labels_` attribute to the mixture model classes. Here are the changes needed:\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def predict(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model to X and then predict the labels for X.\n        \n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n        \n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def predict(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm and store the labels.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        super().fit(X, y)\n        self.labels_ = self.predict(X)\n        return self\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _initialize(self, X, resp):\n=======\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the variational inference algorithm and store the labels.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        super().fit(X, y)\n        self.labels_ = self.predict(X)\n        return self\n\n    def _initialize(self, X, resp):\n>>>>>>> REPLACE\n```", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "The issue describes several discrepancies between the interface of mixture models and traditional clusterers. We can address these by making the following changes:\n\n1. Replace `n_components` with `n_clusters`.\n2. Add `labels_` attribute to store the labels of the training data.\n3. Implement a `fit_predict` method.\n\nLet's make these changes in the relevant files.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_clusters = n_components\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n=======\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n        self.labels_ = resp.argmax(axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n\n    def bic(self, X):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n=======\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.labels_ = None\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self._estimate_precisions(nk, xk, sk)\n=======\n        self._estimate_precisions(nk, xk, sk)\n        self.labels_ = resp.argmax(axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X)\n        return self.predict(X)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n>>>>>>> REPLACE\n```\n\nThese changes ensure that the mixture models now have a `clusterer`-compatible interface by:\n- Renaming `n_components` to `n_clusters`.\n- Adding `labels_` attribute.\n- Implementing `fit_predict` method.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "To address the issue of making mixture models have a clusterer-compatible interface, we need to make the following changes:\n\n1. Change the `n_components` parameter to `n_clusters`.\n2. Add the `labels_` attribute to store the labels of the training data.\n3. Implement the `fit_predict` method.\n\nHere are the required *SEARCH/REPLACE* edits to fix the issue:\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n=======\n        self.weights_ = weights if self.weights_init is None else self.weights_init\n        self.means_ = means if self.means_init is None else self.means_init\n        self.labels_ = np.argmax(resp, axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n=======\n        self.weights_, self.means_, self.covariances_ = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type\n        )\n        self.labels_ = np.argmax(log_resp, axis=1)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def bic(self, X):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model and predict the labels for the data samples in X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.labels_\n\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_clusters, tol, reg_covar,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_clusters = n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n=======\n        if self.n_clusters < 1:\n            raise ValueError(\"Invalid value for 'n_clusters': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_clusters)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n=======\n        X = _check_X(X, self.n_clusters, ensure_min_samples=2)\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n=======\n            label = cluster.KMeans(n_clusters=self.n_clusters, n_init=1,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n    n_components : int, defaults to 1.\n=======\n    n_clusters : int, defaults to 1.\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n=======\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_clusters\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n        self.covariances_ = np.empty((self.n_components, n_features,\n=======\n        self.covariances_ = np.empty((self.n_clusters, n_features,\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/bayesian_mixture.py\n<<<<<<< SEARCH\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n=======\n            self", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}, {"response": "The issue mentioned is about making mixture models have a clusterer-compatible interface. The changes required are:\n\n1. Adding `n_clusters` as an alias for `n_components`.\n2. Storing the `labels_` attribute.\n3. Implementing the `fit_predict` method.\n\nLet's proceed with the necessary modifications.\n\n```python\n### sklearn/mixture/base.py\n<<<<<<< SEARCH\n    def __init__(self, n_components, tol, reg_covar,\n=======\n    def __init__(self, n_components=None, n_clusters=None, tol, reg_covar,\n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        self.n_components = n_components\n=======\n        self.n_components = n_clusters if n_clusters is not None else n_components\n        self.n_clusters = self.n_components\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n    def _check_is_fitted(self):\n=======\n    def fit_predict(self, X, y=None):\n        \"\"\"Fit the model using X and then predict the labels for the data samples in X.\n        \n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self.fit(X, y)\n        return self.predict(X)\n\n    def _check_is_fitted(self):\n>>>>>>> REPLACE\n```\n\n```python\n### sklearn/mixture/gaussian_mixture.py\n<<<<<<< SEARCH\n        self.weights_, self.means_, self.covariances_ = (\n=======\n        self.weights_, self.means_, self.covariances_ = ( \n>>>>>>> REPLACE\n\n<<<<<<< SEARCH\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n=======\n        labels = self._estimate_weighted_log_prob(X).argmax(axis=1)\n        self.labels_ = labels\n        return labels\n>>>>>>> REPLACE\n```\n\nThis should address the issue by:\n1. Allowing `n_clusters` to be used instead of `n_components`.\n2. Storing the labels of the training data in the `labels_` attribute.\n3. Adding the `fit_predict` method to align with the clusterer interface.", "usage": {"completion_tokens": 0, "prompt_tokens": 0}, "prompt": "We are currently solving the following issue within our repository. Here is the issue text:\n--- BEGIN ISSUE ---\nShould mixture models have a clusterer-compatible interface\nMixture models are currently a bit different. They are basically clusterers, except they are probabilistic, and are applied to inductive problems unlike many clusterers. But they are unlike clusterers in API:\r\n* they have an `n_components` parameter, with identical purpose to `n_clusters`\r\n* they do not store the `labels_` of the training data\r\n* they do not have a `fit_predict` method\r\n\r\nAnd they are almost entirely documented separately.\r\n\r\nShould we make the MMs more like clusterers?\n\n--- END ISSUE ---\n\n\n\n\nBelow are some code segments, each from a relevant file. One or more of these files may contain bugs.\n\n--- BEGIN FILE ---\n```\n### sklearn/mixture/gaussian_mixture.py\n...\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n...\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()\n\n\n### sklearn/mixture/base.py\n...\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))\n...\n\n\n### sklearn/mixture/bayesian_mixture.py\n...\n    log_wishart_norm : array-like, shape (n_components,)\n        The log normalization of the Wishart distribution.\n    \"\"\"\n    # To simplify the computation we have removed the np.log(np.pi) term\n    return -(degrees_of_freedom * log_det_precisions_chol +\n             degrees_of_freedom * n_features * .5 * math.log(2.) +\n             np.sum(gammaln(.5 * (degrees_of_freedom -\n                                  np.arange(n_features)[:, np.newaxis])), 0))\n\n\nclass BayesianGaussianMixture(BaseMixture):\n    \"\"\"Variational Bayesian estimation of a Gaussian mixture.\n\n    This class allows to infer an approximate posterior distribution over the\n    parameters of a Gaussian mixture distribution. The effective number of\n    components can be inferred from the data.\n\n    This class implements two types of prior for the weights distribution: a\n    finite mixture model with Dirichlet distribution and an infinite mixture\n    model with the Dirichlet Process. In practice Dirichlet Process inference\n    algorithm is approximated and uses a truncated distribution with a fixed\n    maximum number of components (called the Stick-breaking representation).\n    The number of components actually used almost always depends on the data.\n\n    .. versionadded:: 0.18\n\n    Read more in the :ref:`User Guide <bgmm>`.\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components. Depending on the data and the value\n        of the `weight_concentration_prior` the model can decide to not use\n        all the components by setting some component `weights_` to values very\n        close to zero. The number of effective components is therefore smaller\n        than n_components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}, defaults to 'full'\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain on the likelihood (of the training data with\n        respect to the model) is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The result with the highest\n        lower bound value on the likelihood is kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        covariances.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weight_concentration_prior_type : str, defaults to 'dirichlet_process'.\n        String describing the type of the weight concentration prior.\n        Must be one of::\n\n            'dirichlet_process' (using the Stick-breaking representation),\n            'dirichlet_distribution' (can favor more uniform weights).\n\n    weight_concentration_prior : float | None, optional.\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). This is commonly called gamma in the\n        literature. The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        mixture weights simplex. The value of the parameter must be greater\n        than 0. If it is None, it's set to ``1. / n_components``.\n\n    mean_precision_prior : float | None, optional.\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed. Smaller\n        values concentrate the means of each clusters around `mean_prior`.\n        The value of the parameter must be greater than 0.\n        If it is None, it's set to 1.\n\n    mean_prior : array-like, shape (n_features,), optional\n        The prior on the mean distribution (Gaussian).\n        If it is None, it's set to the mean of X.\n\n    degrees_of_freedom_prior : float | None, optional.\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart). If it is None, it's set to `n_features`.\n\n    covariance_prior : float or array-like, optional\n        The prior on the covariance distribution (Wishart).\n        If it is None, the emiprical covariance prior is initialized using the\n        covariance of X. The shape depends on `covariance_type`::\n\n                (n_features, n_features) if 'full',\n                (n_features, n_features) if 'tied',\n                (n_features)             if 'diag',\n                float                    if 'spherical'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on ``covariance_type``::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of inference to reach the\n        convergence.\n\n    lower_bound_ : float\n        Lower bound value on the likelihood (of the training data with\n        respect to the model) of the best fit of inference.\n\n    weight_concentration_prior_ : tuple or float\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet). The type depends on\n        ``weight_concentration_prior_type``::\n\n            (float, float) if 'dirichlet_process' (Beta parameters),\n            float          if 'dirichlet_distribution' (Dirichlet parameters).\n\n        The higher concentration puts more mass in\n        the center and will lead to more components being active, while a lower\n        concentration parameter will lead to more mass at the edge of the\n        simplex.\n\n    weight_concentration_ : array-like, shape (n_components,)\n        The dirichlet concentration of each component on the weight\n        distribution (Dirichlet).\n\n    mean_precision_prior : float\n        The precision prior on the mean distribution (Gaussian).\n        Controls the extend to where means can be placed.\n        Smaller values concentrate the means of each clusters around\n        `mean_prior`.\n\n    mean_precision_ : array-like, shape (n_components,)\n        The precision of each components on the mean distribution (Gaussian).\n\n    means_prior_ : array-like, shape (n_features,)\n        The prior on the mean distribution (Gaussian).\n\n    degrees_of_freedom_prior_ : float\n        The prior of the number of degrees of freedom on the covariance\n        distributions (Wishart).\n\n    degrees_of_freedom_ : array-like, shape (n_components,)\n        The number of degrees of freedom of each components in the model.\n\n    covariance_prior_ : float or array-like\n        The prior on the covariance distribution (Wishart).\n        The shape depends on `covariance_type`::\n\n            (n_features, n_features) if 'full',\n            (n_features, n_features) if 'tied',\n            (n_features)             if 'diag',\n            float                    if 'spherical'\n\n    See Also\n    --------\n    GaussianMixture : Finite Gaussian mixture fit with EM.\n\n    References\n    ----------\n\n    .. [1] `Bishop, Christopher M. (2006). \"Pattern recognition and machine\n       learning\". Vol. 4 No. 4. New York: Springer.\n       <http://www.springer.com/kr/book/9780387310732>`_\n\n    .. [2] `Hagai Attias. (2000). \"A Variational Bayesian Framework for\n       Graphical Models\". In Advances in Neural Information Processing\n       Systems 12.\n       <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.36.2841&rep=rep1&type=pdf>`_\n\n    .. [3] `Blei, David M. and Michael I. Jordan. (2006). \"Variational\n       inference for Dirichlet process mixtures\". Bayesian analysis 1.1\n       <http://www.cs.princeton.edu/courses/archive/fall11/cos597C/reading/BleiJordan2005.pdf>`_\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weight_concentration_prior_type='dirichlet_process',\n                 weight_concentration_prior=None,\n                 mean_precision_prior=None, mean_prior=None,\n                 degrees_of_freedom_prior=None, covariance_prior=None,\n                 random_state=None, warm_start=False, verbose=0,\n                 verbose_interval=10):\n        super(BayesianGaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weight_concentration_prior_type = weight_concentration_prior_type\n        self.weight_concentration_prior = weight_concentration_prior\n        self.mean_precision_prior = mean_precision_prior\n        self.mean_prior = mean_prior\n        self.degrees_of_freedom_prior = degrees_of_freedom_prior\n        self.covariance_prior = covariance_prior\n\n    def _check_parameters(self, X):\n        \"\"\"Check that the parameters are well defined.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if (self.weight_concentration_prior_type not in\n                ['dirichlet_process', 'dirichlet_distribution']):\n            raise ValueError(\n                \"Invalid value for 'weight_concentration_prior_type': %s \"\n                \"'weight_concentration_prior_type' should be in \"\n                \"['dirichlet_process', 'dirichlet_distribution']\"\n                % self.weight_concentration_prior_type)\n\n        self._check_weights_parameters()\n        self._check_means_parameters(X)\n        self._check_precision_parameters(X)\n        self._checkcovariance_prior_parameter(X)\n\n    def _check_weights_parameters(self):\n        \"\"\"Check the parameter of the Dirichlet distribution.\"\"\"\n        if self.weight_concentration_prior is None:\n            self.weight_concentration_prior_ = 1. / self.n_components\n        elif self.weight_concentration_prior > 0.:\n            self.weight_concentration_prior_ = (\n                self.weight_concentration_prior)\n        else:\n            raise ValueError(\"The parameter 'weight_concentration_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.weight_concentration_prior)\n\n    def _check_means_parameters(self, X):\n        \"\"\"Check the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.mean_precision_prior is None:\n            self.mean_precision_prior_ = 1.\n        elif self.mean_precision_prior > 0.:\n            self.mean_precision_prior_ = self.mean_precision_prior\n        else:\n            raise ValueError(\"The parameter 'mean_precision_prior' should be \"\n                             \"greater than 0., but got %.3f.\"\n                             % self.mean_precision_prior)\n\n        if self.mean_prior is None:\n            self.mean_prior_ = X.mean(axis=0)\n        else:\n            self.mean_prior_ = check_array(self.mean_prior,\n                                           dtype=[np.float64, np.float32],\n                                           ensure_2d=False)\n            _check_shape(self.mean_prior_, (n_features, ), 'means')\n\n    def _check_precision_parameters(self, X):\n        \"\"\"Check the prior parameters of the precision distribution.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.degrees_of_freedom_prior is None:\n            self.degrees_of_freedom_prior_ = n_features\n        elif self.degrees_of_freedom_prior > n_features - 1.:\n            self.degrees_of_freedom_prior_ = self.degrees_of_freedom_prior\n        else:\n            raise ValueError(\"The parameter 'degrees_of_freedom_prior' \"\n                             \"should be greater than %d, but got %.3f.\"\n                             % (n_features - 1, self.degrees_of_freedom_prior))\n\n    def _checkcovariance_prior_parameter(self, X):\n        \"\"\"Check the `covariance_prior_`.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        _, n_features = X.shape\n\n        if self.covariance_prior is None:\n            self.covariance_prior_ = {\n                'full': np.atleast_2d(np.cov(X.T)),\n                'tied': np.atleast_2d(np.cov(X.T)),\n                'diag': np.var(X, axis=0, ddof=1),\n                'spherical': np.var(X, axis=0, ddof=1).mean()\n            }[self.covariance_type]\n\n        elif self.covariance_type in ['full', 'tied']:\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features, n_features),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_matrix(self.covariance_prior_,\n                                    self.covariance_type)\n        elif self.covariance_type == 'diag':\n            self.covariance_prior_ = check_array(\n                self.covariance_prior, dtype=[np.float64, np.float32],\n                ensure_2d=False)\n            _check_shape(self.covariance_prior_, (n_features,),\n                         '%s covariance_prior' % self.covariance_type)\n            _check_precision_positivity(self.covariance_prior_,\n                                        self.covariance_type)\n        # spherical case\n        elif self.covariance_prior > 0.:\n            self.covariance_prior_ = self.covariance_prior\n        else:\n            raise ValueError(\"The parameter 'spherical covariance_prior' \"\n                             \"should be greater than 0., but got %.3f.\"\n                             % self.covariance_prior)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        nk, xk, sk = _estimate_gaussian_parameters(X, resp, self.reg_covar,\n                                                   self.covariance_type)\n\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_weights(self, nk):\n        \"\"\"Estimate the parameters of the Dirichlet distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n        \"\"\"\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            # For dirichlet process weight_concentration will be a tuple\n            # containing the two parameters of the beta distribution\n            self.weight_concentration_ = (\n                1. + nk,\n                (self.weight_concentration_prior_ +\n                 np.hstack((np.cumsum(nk[::-1])[-2::-1], 0))))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            self.weight_concentration_ = self.weight_concentration_prior_ + nk\n\n    def _estimate_means(self, nk, xk):\n        \"\"\"Estimate the parameters of the Gaussian distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n        \"\"\"\n        self.mean_precision_ = self.mean_precision_prior_ + nk\n        self.means_ = ((self.mean_precision_prior_ * self.mean_prior_ +\n                        nk[:, np.newaxis] * xk) /\n                       self.mean_precision_[:, np.newaxis])\n\n    def _estimate_precisions(self, nk, xk, sk):\n        \"\"\"Estimate the precisions parameters of the precision distribution.\n\n        Parameters\n        ----------\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like\n            The shape depends of `covariance_type`:\n            'full' : (n_components, n_features, n_features)\n            'tied' : (n_features, n_features)\n            'diag' : (n_components, n_features)\n            'spherical' : (n_components,)\n        \"\"\"\n        {\"full\": self._estimate_wishart_full,\n         \"tied\": self._estimate_wishart_tied,\n         \"diag\": self._estimate_wishart_diag,\n         \"spherical\": self._estimate_wishart_spherical\n         }[self.covariance_type](nk, xk, sk)\n\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_wishart_full(self, nk, xk, sk):\n        \"\"\"Estimate the full Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk` is\n        # the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        self.covariances_ = np.empty((self.n_components, n_features,\n                                      n_features))\n\n        for k in range(self.n_components):\n            diff = xk[k] - self.mean_prior_\n            self.covariances_[k] = (self.covariance_prior_ + nk[k] * sk[k] +\n                                    nk[k] * self.mean_precision_prior_ /\n                                    self.mean_precision_[k] * np.outer(diff,\n                                                                       diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= (\n            self.degrees_of_freedom_[:, np.newaxis, np.newaxis])\n\n    def _estimate_wishart_tied(self, nk, xk, sk):\n        \"\"\"Estimate the tied Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_features, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = (\n            self.degrees_of_freedom_prior_ + nk.sum() / self.n_components)\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + sk * nk.sum() / self.n_components +\n            self.mean_precision_prior_ / self.n_components * np.dot(\n                (nk / self.mean_precision_) * diff.T, diff))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _estimate_wishart_diag(self, nk, xk, sk):\n        \"\"\"Estimate the diag Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components, n_features)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk[:, np.newaxis] * (\n                sk + (self.mean_precision_prior_ /\n                      self.mean_precision_)[:, np.newaxis] * np.square(diff)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_[:, np.newaxis]\n\n    def _estimate_wishart_spherical(self, nk, xk, sk):\n        \"\"\"Estimate the spherical Wishart distribution parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        nk : array-like, shape (n_components,)\n\n        xk : array-like, shape (n_components, n_features)\n\n        sk : array-like, shape (n_components,)\n        \"\"\"\n        _, n_features = xk.shape\n\n        # Warning : in some Bishop book, there is a typo on the formula 10.63\n        # `degrees_of_freedom_k = degrees_of_freedom_0 + Nk`\n        # is the correct formula\n        self.degrees_of_freedom_ = self.degrees_of_freedom_prior_ + nk\n\n        diff = xk - self.mean_prior_\n        self.covariances_ = (\n            self.covariance_prior_ + nk * (\n                sk + self.mean_precision_prior_ / self.mean_precision_ *\n                np.mean(np.square(diff), 1)))\n\n        # Contrary to the original bishop book, we normalize the covariances\n        self.covariances_ /= self.degrees_of_freedom_\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weight_concentration_', 'mean_precision_',\n                               'means_', 'degrees_of_freedom_',\n                               'covariances_', 'precisions_',\n                               'precisions_cholesky_'])\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        nk, xk, sk = _estimate_gaussian_parameters(\n            X, np.exp(log_resp), self.reg_covar, self.covariance_type)\n        self._estimate_weights(nk)\n        self._estimate_means(nk, xk)\n        self._estimate_precisions(nk, xk, sk)\n\n    def _estimate_log_weights(self):\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            digamma_sum = digamma(self.weight_concentration_[0] +\n                                  self.weight_concentration_[1])\n            digamma_a = digamma(self.weight_concentration_[0])\n            digamma_b = digamma(self.weight_concentration_[1])\n            return (digamma_a - digamma_sum +\n                    np.hstack((0, np.cumsum(digamma_b - digamma_sum)[:-1])))\n        else:\n            # case Variationnal Gaussian mixture with dirichlet distribution\n            return (digamma(self.weight_concentration_) -\n                    digamma(np.sum(self.weight_concentration_)))\n\n    def _estimate_log_prob(self, X):\n        _, n_features = X.shape\n        # We remove `n_features * np.log(self.degrees_of_freedom_)` because\n        # the precision matrix is normalized\n        log_gauss = (_estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        log_lambda = n_features * np.log(2.) + np.sum(digamma(\n            .5 * (self.degrees_of_freedom_ -\n                  np.arange(0, n_features)[:, np.newaxis])), 0)\n\n        return log_gauss + .5 * (log_lambda -\n                                 n_features / self.mean_precision_)\n\n    def _compute_lower_bound(self, log_resp, log_prob_norm):\n        \"\"\"Estimate the lower bound of the model.\n\n        The lower bound on the likelihood (of the training data with respect to\n        the model) is used to detect the convergence and has to decrease at\n        each iteration.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n\n        log_prob_norm : float\n            Logarithm of the probability of each sample in X.\n\n        Returns\n        -------\n        lower_bound : float\n        \"\"\"\n        # Contrary to the original formula, we have done some simplification\n        # and removed all the constant terms.\n        n_features, = self.mean_prior_.shape\n\n        # We removed `.5 * n_features * np.log(self.degrees_of_freedom_)`\n        # because the precision matrix is normalized.\n        log_det_precisions_chol = (_compute_log_det_cholesky(\n            self.precisions_cholesky_, self.covariance_type, n_features) -\n            .5 * n_features * np.log(self.degrees_of_freedom_))\n\n        if self.covariance_type == 'tied':\n            log_wishart = self.n_components * np.float64(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n        else:\n            log_wishart = np.sum(_log_wishart_norm(\n                self.degrees_of_freedom_, log_det_precisions_chol, n_features))\n\n        if self.weight_concentration_prior_type == 'dirichlet_process':\n            log_norm_weight = -np.sum(betaln(self.weight_concentration_[0],\n                                             self.weight_concentration_[1]))\n        else:\n            log_norm_weight = _log_dirichlet_norm(self.weight_concentration_)\n\n        return (-np.sum(np.exp(log_resp) * log_resp) -\n                log_wishart - log_norm_weight -\n                0.5 * n_features * np.sum(np.log(self.mean_precision_)))\n\n    def _get_parameters(self):\n        return (self.weight_concentration_,\n                self.mean_precision_, self.means_,\n                self.degrees_of_freedom_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weight_concentration_, self.mean_precision_, self.means_,\n         self.degrees_of_freedom_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Weights computation\n        if self.weight_concentration_prior_type == \"dirichlet_process\":\n            weight_dirichlet_sum = (self.weight_concentration_[0] +\n                                    self.weight_concentration_[1])\n            tmp = self.weight_concentration_[1] / weight_dirichlet_sum\n            self.weights_ = (\n                self.weight_concentration_[0] / weight_dirichlet_sum *\n                np.hstack((1, np.cumprod(tmp[:-1]))))\n            self.weights_ /= np.sum(self.weights_)\n        else:\n            self. weights_ = (self.weight_concentration_ /\n                              np.sum(self.weight_concentration_))\n\n        # Precisions matrices computation\n        if self.covariance_type == 'full':\n            self.precisions_ = np.array([\n                np.dot(prec_chol, prec_chol.T)\n                for prec_chol in self.precisions_cholesky_])\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n```\n--- END FILE ---\n\nPlease first localize the bug based on the issue statement, and then generate *SEARCH/REPLACE* edits to fix the issue.\n\nEvery *SEARCH/REPLACE* edit must use this format:\n1. The file path\n2. The start of search block: <<<<<<< SEARCH\n3. A contiguous chunk of lines to search for in the existing source code\n4. The dividing line: =======\n5. The lines to replace into the source code\n6. The end of the replace block: >>>>>>> REPLACE\n\nHere is an example:\n\n```python\n### mathweb/flask/app.py\n<<<<<<< SEARCH\nfrom flask import Flask\n=======\nimport math\nfrom flask import Flask\n>>>>>>> REPLACE\n```\n\nPlease note that the *SEARCH/REPLACE* edit REQUIRES PROPER INDENTATION. If you would like to add the line '        print(x)', you must fully write that out, with all those spaces before the code!\nWrap the *SEARCH/REPLACE* edit in blocks ```python...```."}], "prev_content": [["\"\"\"Gaussian Mixture Model.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nimport numpy as np\n\nfrom scipy import linalg\n\nfrom .base import BaseMixture, _check_shape\nfrom ..externals.six.moves import zip\nfrom ..utils import check_array\nfrom ..utils.validation import check_is_fitted\nfrom ..utils.extmath import row_norms\n\n\n###############################################################################\n# Gaussian mixture shape checkers used by the GaussianMixture class\n\ndef _check_weights(weights, n_components):\n    \"\"\"Check the user provided 'weights'.\n\n    Parameters\n    ----------\n    weights : array-like, shape (n_components,)\n        The proportions of components of each mixture.\n\n    n_components : int\n        Number of components.\n\n    Returns\n    -------\n    weights : array, shape (n_components,)\n    \"\"\"\n    weights = check_array(weights, dtype=[np.float64, np.float32],\n                          ensure_2d=False)\n    _check_shape(weights, (n_components,), 'weights')\n\n    # check range\n    if (any(np.less(weights, 0.)) or\n            any(np.greater(weights, 1.))):\n        raise ValueError(\"The parameter 'weights' should be in the range \"\n                         \"[0, 1], but got max value %.5f, min value %.5f\"\n                         % (np.min(weights), np.max(weights)))\n\n    # check normalization\n    if not np.allclose(np.abs(1. - np.sum(weights)), 0.):\n        raise ValueError(\"The parameter 'weights' should be normalized, \"\n                         \"but got sum(weights) = %.5f\" % np.sum(weights))\n    return weights\n\n\ndef _check_means(means, n_components, n_features):\n    \"\"\"Validate the provided 'means'.\n\n    Parameters\n    ----------\n    means : array-like, shape (n_components, n_features)\n        The centers of the current components.\n\n    n_components : int\n        Number of components.\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    means : array, (n_components, n_features)\n    \"\"\"\n    means = check_array(means, dtype=[np.float64, np.float32], ensure_2d=False)\n    _check_shape(means, (n_components, n_features), 'means')\n    return means\n\n\ndef _check_precision_positivity(precision, covariance_type):\n    \"\"\"Check a precision vector is positive-definite.\"\"\"\n    if np.any(np.less_equal(precision, 0.0)):\n        raise ValueError(\"'%s precision' should be \"\n                         \"positive\" % covariance_type)\n\n\ndef _check_precision_matrix(precision, covariance_type):\n    \"\"\"Check a precision matrix is symmetric and positive-definite.\"\"\"\n    if not (np.allclose(precision, precision.T) and\n            np.all(linalg.eigvalsh(precision) > 0.)):\n        raise ValueError(\"'%s precision' should be symmetric, \"\n                         \"positive-definite\" % covariance_type)\n\n\ndef _check_precisions_full(precisions, covariance_type):\n    \"\"\"Check the precision matrices are symmetric and positive-definite.\"\"\"\n    for prec in precisions:\n        _check_precision_matrix(prec, covariance_type)\n\n\ndef _check_precisions(precisions, covariance_type, n_components, n_features):\n    \"\"\"Validate user provided precisions.\n\n    Parameters\n    ----------\n    precisions : array-like\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : string\n\n    n_components : int\n        Number of components.\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    precisions : array\n    \"\"\"\n    precisions = check_array(precisions, dtype=[np.float64, np.float32],\n                             ensure_2d=False,\n                             allow_nd=covariance_type == 'full')\n\n    precisions_shape = {'full': (n_components, n_features, n_features),\n                        'tied': (n_features, n_features),\n                        'diag': (n_components, n_features),\n                        'spherical': (n_components,)}\n    _check_shape(precisions, precisions_shape[covariance_type],\n                 '%s precision' % covariance_type)\n\n    _check_precisions = {'full': _check_precisions_full,\n                         'tied': _check_precision_matrix,\n                         'diag': _check_precision_positivity,\n                         'spherical': _check_precision_positivity}\n    _check_precisions[covariance_type](precisions, covariance_type)\n    return precisions\n\n\n###############################################################################\n# Gaussian mixture parameters estimators (used by the M-Step)\n\ndef _estimate_gaussian_covariances_full(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the full covariance matrices.\n\n    Parameters\n    ----------\n    resp : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariances : array, shape (n_components, n_features, n_features)\n        The covariance matrix of the current components.\n    \"\"\"\n    n_components, n_features = means.shape\n    covariances = np.empty((n_components, n_features, n_features))\n    for k in range(n_components):\n        diff = X - means[k]\n        covariances[k] = np.dot(resp[:, k] * diff.T, diff) / nk[k]\n        covariances[k].flat[::n_features + 1] += reg_covar\n    return covariances\n\n\ndef _estimate_gaussian_covariances_tied(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the tied covariance matrix.\n\n    Parameters\n    ----------\n    resp : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariance : array, shape (n_features, n_features)\n        The tied covariance matrix of the components.\n    \"\"\"\n    avg_X2 = np.dot(X.T, X)\n    avg_means2 = np.dot(nk * means.T, means)\n    covariance = avg_X2 - avg_means2\n    covariance /= nk.sum()\n    covariance.flat[::len(covariance) + 1] += reg_covar\n    return covariance\n\n\ndef _estimate_gaussian_covariances_diag(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the diagonal covariance vectors.\n\n    Parameters\n    ----------\n    responsibilities : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariances : array, shape (n_components, n_features)\n        The covariance vector of the current components.\n    \"\"\"\n    avg_X2 = np.dot(resp.T, X * X) / nk[:, np.newaxis]\n    avg_means2 = means ** 2\n    avg_X_means = means * np.dot(resp.T, X) / nk[:, np.newaxis]\n    return avg_X2 - 2 * avg_X_means + avg_means2 + reg_covar\n\n\ndef _estimate_gaussian_covariances_spherical(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the spherical variance values.\n\n    Parameters\n    ----------\n    responsibilities : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    variances : array, shape (n_components,)\n        The variance values of each components.\n    \"\"\"\n    return _estimate_gaussian_covariances_diag(resp, X, nk,\n                                               means, reg_covar).mean(1)\n\n\ndef _estimate_gaussian_parameters(X, resp, reg_covar, covariance_type):\n    \"\"\"Estimate the Gaussian distribution parameters.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        The input data array.\n\n    resp : array-like, shape (n_samples, n_components)\n        The responsibilities for each data sample in X.\n\n    reg_covar : float\n        The regularization added to the diagonal of the covariance matrices.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n        The type of precision matrices.\n\n    Returns\n    -------\n    nk : array-like, shape (n_components,)\n        The numbers of data samples in the current components.\n\n    means : array-like, shape (n_components, n_features)\n        The centers of the current components.\n\n    covariances : array-like\n        The covariance matrix of the current components.\n        The shape depends of the covariance_type.\n    \"\"\"\n    nk = resp.sum(axis=0) + 10 * np.finfo(resp.dtype).eps\n    means = np.dot(resp.T, X) / nk[:, np.newaxis]\n    covariances = {\"full\": _estimate_gaussian_covariances_full,\n                   \"tied\": _estimate_gaussian_covariances_tied,\n                   \"diag\": _estimate_gaussian_covariances_diag,\n                   \"spherical\": _estimate_gaussian_covariances_spherical\n                   }[covariance_type](resp, X, nk, means, reg_covar)\n    return nk, means, covariances\n\n\ndef _compute_precision_cholesky(covariances, covariance_type):\n    \"\"\"Compute the Cholesky decomposition of the precisions.\n\n    Parameters\n    ----------\n    covariances : array-like\n        The covariance matrix of the current components.\n        The shape depends of the covariance_type.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n        The type of precision matrices.\n\n    Returns\n    -------\n    precisions_cholesky : array-like\n        The cholesky decomposition of sample precisions of the current\n        components. The shape depends of the covariance_type.\n    \"\"\"\n    estimate_precision_error_message = (\n        \"Fitting the mixture model failed because some components have \"\n        \"ill-defined empirical covariance (for instance caused by singleton \"\n        \"or collapsed samples). Try to decrease the number of components, \"\n        \"or increase reg_covar.\")\n\n    if covariance_type in 'full':\n        n_components, n_features, _ = covariances.shape\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n    return precisions_chol\n\n\n###############################################################################\n# Gaussian mixture probability estimators\ndef _compute_log_det_cholesky(matrix_chol, covariance_type, n_features):\n    \"\"\"Compute the log-det of the cholesky decomposition of matrices.\n\n    Parameters\n    ----------\n    matrix_chol : array-like\n        Cholesky decompositions of the matrices.\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    log_det_precision_chol : array-like, shape (n_components,)\n        The determinant of the precision matrix for each component.\n    \"\"\"\n    if covariance_type == 'full':\n        n_components, _, _ = matrix_chol.shape\n        log_det_chol = (np.sum(np.log(\n            matrix_chol.reshape(\n                n_components, -1)[:, ::n_features + 1]), 1))\n\n    elif covariance_type == 'tied':\n        log_det_chol = (np.sum(np.log(np.diag(matrix_chol))))\n\n    elif covariance_type == 'diag':\n        log_det_chol = (np.sum(np.log(matrix_chol), axis=1))\n\n    else:\n        log_det_chol = n_features * (np.log(matrix_chol))\n\n    return log_det_chol\n\n\ndef _estimate_log_gaussian_prob(X, means, precisions_chol, covariance_type):\n    \"\"\"Estimate the log Gaussian probability.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    means : array-like, shape (n_components, n_features)\n\n    precisions_chol : array-like\n        Cholesky decompositions of the precision matrices.\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n\n    Returns\n    -------\n    log_prob : array, shape (n_samples, n_components)\n    \"\"\"\n    n_samples, n_features = X.shape\n    n_components, _ = means.shape\n    # det(precision_chol) is half of det(precision)\n    log_det = _compute_log_det_cholesky(\n        precisions_chol, covariance_type, n_features)\n\n    if covariance_type == 'full':\n        log_prob = np.empty((n_samples, n_components))\n        for k, (mu, prec_chol) in enumerate(zip(means, precisions_chol)):\n            y = np.dot(X, prec_chol) - np.dot(mu, prec_chol)\n            log_prob[:, k] = np.sum(np.square(y), axis=1)\n\n    elif covariance_type == 'tied':\n        log_prob = np.empty((n_samples, n_components))\n        for k, mu in enumerate(means):\n            y = np.dot(X, precisions_chol) - np.dot(mu, precisions_chol)\n            log_prob[:, k] = np.sum(np.square(y), axis=1)\n\n    elif covariance_type == 'diag':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum((means ** 2 * precisions), 1) -\n                    2. * np.dot(X, (means * precisions).T) +\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()", "\"\"\"Base class for mixture models.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nfrom __future__ import print_function\n\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom time import time\n\nimport numpy as np\n\nfrom .. import cluster\nfrom ..base import BaseEstimator\nfrom ..base import DensityMixin\nfrom ..externals import six\nfrom ..exceptions import ConvergenceWarning\nfrom ..utils import check_array, check_random_state\nfrom ..utils.fixes import logsumexp\n\n\ndef _check_shape(param, param_shape, name):\n    \"\"\"Validate the shape of the input parameter 'param'.\n\n    Parameters\n    ----------\n    param : array\n\n    param_shape : tuple\n\n    name : string\n    \"\"\"\n    param = np.array(param)\n    if param.shape != param_shape:\n        raise ValueError(\"The parameter '%s' should have the shape of %s, \"\n                         \"but got %s\" % (name, param_shape, param.shape))\n\n\ndef _check_X(X, n_components=None, n_features=None, ensure_min_samples=1):\n    \"\"\"Check the input data X.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    n_components : int\n\n    Returns\n    -------\n    X : array, shape (n_samples, n_features)\n    \"\"\"\n    X = check_array(X, dtype=[np.float64, np.float32],\n                    ensure_min_samples=ensure_min_samples)\n    if n_components is not None and X.shape[0] < n_components:\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))", "\"\"\"Base class for mixture models.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nfrom __future__ import print_function\n\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom time import time\n\nimport numpy as np\n\nfrom .. import cluster\nfrom ..base import BaseEstimator\nfrom ..base import DensityMixin\nfrom ..externals import six\nfrom ..exceptions import ConvergenceWarning\nfrom ..utils import check_array, check_random_state\nfrom ..utils.fixes import logsumexp\n\n\ndef _check_shape(param, param_shape, name):\n    \"\"\"Validate the shape of the input parameter 'param'.\n\n    Parameters\n    ----------\n    param : array\n\n    param_shape : tuple\n\n    name : string\n    \"\"\"\n    param = np.array(param)\n    if param.shape != param_shape:\n        raise ValueError(\"The parameter '%s' should have the shape of %s, \"\n                         \"but got %s\" % (name, param_shape, param.shape))\n\n\ndef _check_X(X, n_components=None, n_features=None, ensure_min_samples=1):\n    \"\"\"Check the input data X.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    n_components : int\n\n    Returns\n    -------\n    X : array, shape (n_samples, n_features)\n    \"\"\"\n    X = check_array(X, dtype=[np.float64, np.float32],\n                    ensure_min_samples=ensure_min_samples)\n    if n_components is not None and X.shape[0] < n_components:\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))", "\"\"\"Gaussian Mixture Model.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nimport numpy as np\n\nfrom scipy import linalg\n\nfrom .base import BaseMixture, _check_shape\nfrom ..externals.six.moves import zip\nfrom ..utils import check_array\nfrom ..utils.validation import check_is_fitted\nfrom ..utils.extmath import row_norms\n\n\n###############################################################################\n# Gaussian mixture shape checkers used by the GaussianMixture class\n\ndef _check_weights(weights, n_components):\n    \"\"\"Check the user provided 'weights'.\n\n    Parameters\n    ----------\n    weights : array-like, shape (n_components,)\n        The proportions of components of each mixture.\n\n    n_components : int\n        Number of components.\n\n    Returns\n    -------\n    weights : array, shape (n_components,)\n    \"\"\"\n    weights = check_array(weights, dtype=[np.float64, np.float32],\n                          ensure_2d=False)\n    _check_shape(weights, (n_components,), 'weights')\n\n    # check range\n    if (any(np.less(weights, 0.)) or\n            any(np.greater(weights, 1.))):\n        raise ValueError(\"The parameter 'weights' should be in the range \"\n                         \"[0, 1], but got max value %.5f, min value %.5f\"\n                         % (np.min(weights), np.max(weights)))\n\n    # check normalization\n    if not np.allclose(np.abs(1. - np.sum(weights)), 0.):\n        raise ValueError(\"The parameter 'weights' should be normalized, \"\n                         \"but got sum(weights) = %.5f\" % np.sum(weights))\n    return weights\n\n\ndef _check_means(means, n_components, n_features):\n    \"\"\"Validate the provided 'means'.\n\n    Parameters\n    ----------\n    means : array-like, shape (n_components, n_features)\n        The centers of the current components.\n\n    n_components : int\n        Number of components.\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    means : array, (n_components, n_features)\n    \"\"\"\n    means = check_array(means, dtype=[np.float64, np.float32], ensure_2d=False)\n    _check_shape(means, (n_components, n_features), 'means')\n    return means\n\n\ndef _check_precision_positivity(precision, covariance_type):\n    \"\"\"Check a precision vector is positive-definite.\"\"\"\n    if np.any(np.less_equal(precision, 0.0)):\n        raise ValueError(\"'%s precision' should be \"\n                         \"positive\" % covariance_type)\n\n\ndef _check_precision_matrix(precision, covariance_type):\n    \"\"\"Check a precision matrix is symmetric and positive-definite.\"\"\"\n    if not (np.allclose(precision, precision.T) and\n            np.all(linalg.eigvalsh(precision) > 0.)):\n        raise ValueError(\"'%s precision' should be symmetric, \"\n                         \"positive-definite\" % covariance_type)\n\n\ndef _check_precisions_full(precisions, covariance_type):\n    \"\"\"Check the precision matrices are symmetric and positive-definite.\"\"\"\n    for prec in precisions:\n        _check_precision_matrix(prec, covariance_type)\n\n\ndef _check_precisions(precisions, covariance_type, n_components, n_features):\n    \"\"\"Validate user provided precisions.\n\n    Parameters\n    ----------\n    precisions : array-like\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : string\n\n    n_components : int\n        Number of components.\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    precisions : array\n    \"\"\"\n    precisions = check_array(precisions, dtype=[np.float64, np.float32],\n                             ensure_2d=False,\n                             allow_nd=covariance_type == 'full')\n\n    precisions_shape = {'full': (n_components, n_features, n_features),\n                        'tied': (n_features, n_features),\n                        'diag': (n_components, n_features),\n                        'spherical': (n_components,)}\n    _check_shape(precisions, precisions_shape[covariance_type],\n                 '%s precision' % covariance_type)\n\n    _check_precisions = {'full': _check_precisions_full,\n                         'tied': _check_precision_matrix,\n                         'diag': _check_precision_positivity,\n                         'spherical': _check_precision_positivity}\n    _check_precisions[covariance_type](precisions, covariance_type)\n    return precisions\n\n\n###############################################################################\n# Gaussian mixture parameters estimators (used by the M-Step)\n\ndef _estimate_gaussian_covariances_full(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the full covariance matrices.\n\n    Parameters\n    ----------\n    resp : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariances : array, shape (n_components, n_features, n_features)\n        The covariance matrix of the current components.\n    \"\"\"\n    n_components, n_features = means.shape\n    covariances = np.empty((n_components, n_features, n_features))\n    for k in range(n_components):\n        diff = X - means[k]\n        covariances[k] = np.dot(resp[:, k] * diff.T, diff) / nk[k]\n        covariances[k].flat[::n_features + 1] += reg_covar\n    return covariances\n\n\ndef _estimate_gaussian_covariances_tied(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the tied covariance matrix.\n\n    Parameters\n    ----------\n    resp : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariance : array, shape (n_features, n_features)\n        The tied covariance matrix of the components.\n    \"\"\"\n    avg_X2 = np.dot(X.T, X)\n    avg_means2 = np.dot(nk * means.T, means)\n    covariance = avg_X2 - avg_means2\n    covariance /= nk.sum()\n    covariance.flat[::len(covariance) + 1] += reg_covar\n    return covariance\n\n\ndef _estimate_gaussian_covariances_diag(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the diagonal covariance vectors.\n\n    Parameters\n    ----------\n    responsibilities : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariances : array, shape (n_components, n_features)\n        The covariance vector of the current components.\n    \"\"\"\n    avg_X2 = np.dot(resp.T, X * X) / nk[:, np.newaxis]\n    avg_means2 = means ** 2\n    avg_X_means = means * np.dot(resp.T, X) / nk[:, np.newaxis]\n    return avg_X2 - 2 * avg_X_means + avg_means2 + reg_covar\n\n\ndef _estimate_gaussian_covariances_spherical(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the spherical variance values.\n\n    Parameters\n    ----------\n    responsibilities : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    variances : array, shape (n_components,)\n        The variance values of each components.\n    \"\"\"\n    return _estimate_gaussian_covariances_diag(resp, X, nk,\n                                               means, reg_covar).mean(1)\n\n\ndef _estimate_gaussian_parameters(X, resp, reg_covar, covariance_type):\n    \"\"\"Estimate the Gaussian distribution parameters.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        The input data array.\n\n    resp : array-like, shape (n_samples, n_components)\n        The responsibilities for each data sample in X.\n\n    reg_covar : float\n        The regularization added to the diagonal of the covariance matrices.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n        The type of precision matrices.\n\n    Returns\n    -------\n    nk : array-like, shape (n_components,)\n        The numbers of data samples in the current components.\n\n    means : array-like, shape (n_components, n_features)\n        The centers of the current components.\n\n    covariances : array-like\n        The covariance matrix of the current components.\n        The shape depends of the covariance_type.\n    \"\"\"\n    nk = resp.sum(axis=0) + 10 * np.finfo(resp.dtype).eps\n    means = np.dot(resp.T, X) / nk[:, np.newaxis]\n    covariances = {\"full\": _estimate_gaussian_covariances_full,\n                   \"tied\": _estimate_gaussian_covariances_tied,\n                   \"diag\": _estimate_gaussian_covariances_diag,\n                   \"spherical\": _estimate_gaussian_covariances_spherical\n                   }[covariance_type](resp, X, nk, means, reg_covar)\n    return nk, means, covariances\n\n\ndef _compute_precision_cholesky(covariances, covariance_type):\n    \"\"\"Compute the Cholesky decomposition of the precisions.\n\n    Parameters\n    ----------\n    covariances : array-like\n        The covariance matrix of the current components.\n        The shape depends of the covariance_type.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n        The type of precision matrices.\n\n    Returns\n    -------\n    precisions_cholesky : array-like\n        The cholesky decomposition of sample precisions of the current\n        components. The shape depends of the covariance_type.\n    \"\"\"\n    estimate_precision_error_message = (\n        \"Fitting the mixture model failed because some components have \"\n        \"ill-defined empirical covariance (for instance caused by singleton \"\n        \"or collapsed samples). Try to decrease the number of components, \"\n        \"or increase reg_covar.\")\n\n    if covariance_type in 'full':\n        n_components, n_features, _ = covariances.shape\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n    return precisions_chol\n\n\n###############################################################################\n# Gaussian mixture probability estimators\ndef _compute_log_det_cholesky(matrix_chol, covariance_type, n_features):\n    \"\"\"Compute the log-det of the cholesky decomposition of matrices.\n\n    Parameters\n    ----------\n    matrix_chol : array-like\n        Cholesky decompositions of the matrices.\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    log_det_precision_chol : array-like, shape (n_components,)\n        The determinant of the precision matrix for each component.\n    \"\"\"\n    if covariance_type == 'full':\n        n_components, _, _ = matrix_chol.shape\n        log_det_chol = (np.sum(np.log(\n            matrix_chol.reshape(\n                n_components, -1)[:, ::n_features + 1]), 1))\n\n    elif covariance_type == 'tied':\n        log_det_chol = (np.sum(np.log(np.diag(matrix_chol))))\n\n    elif covariance_type == 'diag':\n        log_det_chol = (np.sum(np.log(matrix_chol), axis=1))\n\n    else:\n        log_det_chol = n_features * (np.log(matrix_chol))\n\n    return log_det_chol\n\n\ndef _estimate_log_gaussian_prob(X, means, precisions_chol, covariance_type):\n    \"\"\"Estimate the log Gaussian probability.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    means : array-like, shape (n_components, n_features)\n\n    precisions_chol : array-like\n        Cholesky decompositions of the precision matrices.\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n\n    Returns\n    -------\n    log_prob : array, shape (n_samples, n_components)\n    \"\"\"\n    n_samples, n_features = X.shape\n    n_components, _ = means.shape\n    # det(precision_chol) is half of det(precision)\n    log_det = _compute_log_det_cholesky(\n        precisions_chol, covariance_type, n_features)\n\n    if covariance_type == 'full':\n        log_prob = np.empty((n_samples, n_components))\n        for k, (mu, prec_chol) in enumerate(zip(means, precisions_chol)):\n            y = np.dot(X, prec_chol) - np.dot(mu, prec_chol)\n            log_prob[:, k] = np.sum(np.square(y), axis=1)\n\n    elif covariance_type == 'tied':\n        log_prob = np.empty((n_samples, n_components))\n        for k, mu in enumerate(means):\n            y = np.dot(X, precisions_chol) - np.dot(mu, precisions_chol)\n            log_prob[:, k] = np.sum(np.square(y), axis=1)\n\n    elif covariance_type == 'diag':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum((means ** 2 * precisions), 1) -\n                    2. * np.dot(X, (means * precisions).T) +\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()", "\"\"\"Base class for mixture models.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nfrom __future__ import print_function\n\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom time import time\n\nimport numpy as np\n\nfrom .. import cluster\nfrom ..base import BaseEstimator\nfrom ..base import DensityMixin\nfrom ..externals import six\nfrom ..exceptions import ConvergenceWarning\nfrom ..utils import check_array, check_random_state\nfrom ..utils.fixes import logsumexp\n\n\ndef _check_shape(param, param_shape, name):\n    \"\"\"Validate the shape of the input parameter 'param'.\n\n    Parameters\n    ----------\n    param : array\n\n    param_shape : tuple\n\n    name : string\n    \"\"\"\n    param = np.array(param)\n    if param.shape != param_shape:\n        raise ValueError(\"The parameter '%s' should have the shape of %s, \"\n                         \"but got %s\" % (name, param_shape, param.shape))\n\n\ndef _check_X(X, n_components=None, n_features=None, ensure_min_samples=1):\n    \"\"\"Check the input data X.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    n_components : int\n\n    Returns\n    -------\n    X : array, shape (n_samples, n_features)\n    \"\"\"\n    X = check_array(X, dtype=[np.float64, np.float32],\n                    ensure_min_samples=ensure_min_samples)\n    if n_components is not None and X.shape[0] < n_components:\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))", "\"\"\"Gaussian Mixture Model.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nimport numpy as np\n\nfrom scipy import linalg\n\nfrom .base import BaseMixture, _check_shape\nfrom ..externals.six.moves import zip\nfrom ..utils import check_array\nfrom ..utils.validation import check_is_fitted\nfrom ..utils.extmath import row_norms\n\n\n###############################################################################\n# Gaussian mixture shape checkers used by the GaussianMixture class\n\ndef _check_weights(weights, n_components):\n    \"\"\"Check the user provided 'weights'.\n\n    Parameters\n    ----------\n    weights : array-like, shape (n_components,)\n        The proportions of components of each mixture.\n\n    n_components : int\n        Number of components.\n\n    Returns\n    -------\n    weights : array, shape (n_components,)\n    \"\"\"\n    weights = check_array(weights, dtype=[np.float64, np.float32],\n                          ensure_2d=False)\n    _check_shape(weights, (n_components,), 'weights')\n\n    # check range\n    if (any(np.less(weights, 0.)) or\n            any(np.greater(weights, 1.))):\n        raise ValueError(\"The parameter 'weights' should be in the range \"\n                         \"[0, 1], but got max value %.5f, min value %.5f\"\n                         % (np.min(weights), np.max(weights)))\n\n    # check normalization\n    if not np.allclose(np.abs(1. - np.sum(weights)), 0.):\n        raise ValueError(\"The parameter 'weights' should be normalized, \"\n                         \"but got sum(weights) = %.5f\" % np.sum(weights))\n    return weights\n\n\ndef _check_means(means, n_components, n_features):\n    \"\"\"Validate the provided 'means'.\n\n    Parameters\n    ----------\n    means : array-like, shape (n_components, n_features)\n        The centers of the current components.\n\n    n_components : int\n        Number of components.\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    means : array, (n_components, n_features)\n    \"\"\"\n    means = check_array(means, dtype=[np.float64, np.float32], ensure_2d=False)\n    _check_shape(means, (n_components, n_features), 'means')\n    return means\n\n\ndef _check_precision_positivity(precision, covariance_type):\n    \"\"\"Check a precision vector is positive-definite.\"\"\"\n    if np.any(np.less_equal(precision, 0.0)):\n        raise ValueError(\"'%s precision' should be \"\n                         \"positive\" % covariance_type)\n\n\ndef _check_precision_matrix(precision, covariance_type):\n    \"\"\"Check a precision matrix is symmetric and positive-definite.\"\"\"\n    if not (np.allclose(precision, precision.T) and\n            np.all(linalg.eigvalsh(precision) > 0.)):\n        raise ValueError(\"'%s precision' should be symmetric, \"\n                         \"positive-definite\" % covariance_type)\n\n\ndef _check_precisions_full(precisions, covariance_type):\n    \"\"\"Check the precision matrices are symmetric and positive-definite.\"\"\"\n    for prec in precisions:\n        _check_precision_matrix(prec, covariance_type)\n\n\ndef _check_precisions(precisions, covariance_type, n_components, n_features):\n    \"\"\"Validate user provided precisions.\n\n    Parameters\n    ----------\n    precisions : array-like\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : string\n\n    n_components : int\n        Number of components.\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    precisions : array\n    \"\"\"\n    precisions = check_array(precisions, dtype=[np.float64, np.float32],\n                             ensure_2d=False,\n                             allow_nd=covariance_type == 'full')\n\n    precisions_shape = {'full': (n_components, n_features, n_features),\n                        'tied': (n_features, n_features),\n                        'diag': (n_components, n_features),\n                        'spherical': (n_components,)}\n    _check_shape(precisions, precisions_shape[covariance_type],\n                 '%s precision' % covariance_type)\n\n    _check_precisions = {'full': _check_precisions_full,\n                         'tied': _check_precision_matrix,\n                         'diag': _check_precision_positivity,\n                         'spherical': _check_precision_positivity}\n    _check_precisions[covariance_type](precisions, covariance_type)\n    return precisions\n\n\n###############################################################################\n# Gaussian mixture parameters estimators (used by the M-Step)\n\ndef _estimate_gaussian_covariances_full(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the full covariance matrices.\n\n    Parameters\n    ----------\n    resp : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariances : array, shape (n_components, n_features, n_features)\n        The covariance matrix of the current components.\n    \"\"\"\n    n_components, n_features = means.shape\n    covariances = np.empty((n_components, n_features, n_features))\n    for k in range(n_components):\n        diff = X - means[k]\n        covariances[k] = np.dot(resp[:, k] * diff.T, diff) / nk[k]\n        covariances[k].flat[::n_features + 1] += reg_covar\n    return covariances\n\n\ndef _estimate_gaussian_covariances_tied(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the tied covariance matrix.\n\n    Parameters\n    ----------\n    resp : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariance : array, shape (n_features, n_features)\n        The tied covariance matrix of the components.\n    \"\"\"\n    avg_X2 = np.dot(X.T, X)\n    avg_means2 = np.dot(nk * means.T, means)\n    covariance = avg_X2 - avg_means2\n    covariance /= nk.sum()\n    covariance.flat[::len(covariance) + 1] += reg_covar\n    return covariance\n\n\ndef _estimate_gaussian_covariances_diag(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the diagonal covariance vectors.\n\n    Parameters\n    ----------\n    responsibilities : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariances : array, shape (n_components, n_features)\n        The covariance vector of the current components.\n    \"\"\"\n    avg_X2 = np.dot(resp.T, X * X) / nk[:, np.newaxis]\n    avg_means2 = means ** 2\n    avg_X_means = means * np.dot(resp.T, X) / nk[:, np.newaxis]\n    return avg_X2 - 2 * avg_X_means + avg_means2 + reg_covar\n\n\ndef _estimate_gaussian_covariances_spherical(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the spherical variance values.\n\n    Parameters\n    ----------\n    responsibilities : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    variances : array, shape (n_components,)\n        The variance values of each components.\n    \"\"\"\n    return _estimate_gaussian_covariances_diag(resp, X, nk,\n                                               means, reg_covar).mean(1)\n\n\ndef _estimate_gaussian_parameters(X, resp, reg_covar, covariance_type):\n    \"\"\"Estimate the Gaussian distribution parameters.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        The input data array.\n\n    resp : array-like, shape (n_samples, n_components)\n        The responsibilities for each data sample in X.\n\n    reg_covar : float\n        The regularization added to the diagonal of the covariance matrices.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n        The type of precision matrices.\n\n    Returns\n    -------\n    nk : array-like, shape (n_components,)\n        The numbers of data samples in the current components.\n\n    means : array-like, shape (n_components, n_features)\n        The centers of the current components.\n\n    covariances : array-like\n        The covariance matrix of the current components.\n        The shape depends of the covariance_type.\n    \"\"\"\n    nk = resp.sum(axis=0) + 10 * np.finfo(resp.dtype).eps\n    means = np.dot(resp.T, X) / nk[:, np.newaxis]\n    covariances = {\"full\": _estimate_gaussian_covariances_full,\n                   \"tied\": _estimate_gaussian_covariances_tied,\n                   \"diag\": _estimate_gaussian_covariances_diag,\n                   \"spherical\": _estimate_gaussian_covariances_spherical\n                   }[covariance_type](resp, X, nk, means, reg_covar)\n    return nk, means, covariances\n\n\ndef _compute_precision_cholesky(covariances, covariance_type):\n    \"\"\"Compute the Cholesky decomposition of the precisions.\n\n    Parameters\n    ----------\n    covariances : array-like\n        The covariance matrix of the current components.\n        The shape depends of the covariance_type.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n        The type of precision matrices.\n\n    Returns\n    -------\n    precisions_cholesky : array-like\n        The cholesky decomposition of sample precisions of the current\n        components. The shape depends of the covariance_type.\n    \"\"\"\n    estimate_precision_error_message = (\n        \"Fitting the mixture model failed because some components have \"\n        \"ill-defined empirical covariance (for instance caused by singleton \"\n        \"or collapsed samples). Try to decrease the number of components, \"\n        \"or increase reg_covar.\")\n\n    if covariance_type in 'full':\n        n_components, n_features, _ = covariances.shape\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n    return precisions_chol\n\n\n###############################################################################\n# Gaussian mixture probability estimators\ndef _compute_log_det_cholesky(matrix_chol, covariance_type, n_features):\n    \"\"\"Compute the log-det of the cholesky decomposition of matrices.\n\n    Parameters\n    ----------\n    matrix_chol : array-like\n        Cholesky decompositions of the matrices.\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    log_det_precision_chol : array-like, shape (n_components,)\n        The determinant of the precision matrix for each component.\n    \"\"\"\n    if covariance_type == 'full':\n        n_components, _, _ = matrix_chol.shape\n        log_det_chol = (np.sum(np.log(\n            matrix_chol.reshape(\n                n_components, -1)[:, ::n_features + 1]), 1))\n\n    elif covariance_type == 'tied':\n        log_det_chol = (np.sum(np.log(np.diag(matrix_chol))))\n\n    elif covariance_type == 'diag':\n        log_det_chol = (np.sum(np.log(matrix_chol), axis=1))\n\n    else:\n        log_det_chol = n_features * (np.log(matrix_chol))\n\n    return log_det_chol\n\n\ndef _estimate_log_gaussian_prob(X, means, precisions_chol, covariance_type):\n    \"\"\"Estimate the log Gaussian probability.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    means : array-like, shape (n_components, n_features)\n\n    precisions_chol : array-like\n        Cholesky decompositions of the precision matrices.\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n\n    Returns\n    -------\n    log_prob : array, shape (n_samples, n_components)\n    \"\"\"\n    n_samples, n_features = X.shape\n    n_components, _ = means.shape\n    # det(precision_chol) is half of det(precision)\n    log_det = _compute_log_det_cholesky(\n        precisions_chol, covariance_type, n_features)\n\n    if covariance_type == 'full':\n        log_prob = np.empty((n_samples, n_components))\n        for k, (mu, prec_chol) in enumerate(zip(means, precisions_chol)):\n            y = np.dot(X, prec_chol) - np.dot(mu, prec_chol)\n            log_prob[:, k] = np.sum(np.square(y), axis=1)\n\n    elif covariance_type == 'tied':\n        log_prob = np.empty((n_samples, n_components))\n        for k, mu in enumerate(means):\n            y = np.dot(X, precisions_chol) - np.dot(mu, precisions_chol)\n            log_prob[:, k] = np.sum(np.square(y), axis=1)\n\n    elif covariance_type == 'diag':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum((means ** 2 * precisions), 1) -\n                    2. * np.dot(X, (means * precisions).T) +\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()", "\"\"\"Base class for mixture models.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nfrom __future__ import print_function\n\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom time import time\n\nimport numpy as np\n\nfrom .. import cluster\nfrom ..base import BaseEstimator\nfrom ..base import DensityMixin\nfrom ..externals import six\nfrom ..exceptions import ConvergenceWarning\nfrom ..utils import check_array, check_random_state\nfrom ..utils.fixes import logsumexp\n\n\ndef _check_shape(param, param_shape, name):\n    \"\"\"Validate the shape of the input parameter 'param'.\n\n    Parameters\n    ----------\n    param : array\n\n    param_shape : tuple\n\n    name : string\n    \"\"\"\n    param = np.array(param)\n    if param.shape != param_shape:\n        raise ValueError(\"The parameter '%s' should have the shape of %s, \"\n                         \"but got %s\" % (name, param_shape, param.shape))\n\n\ndef _check_X(X, n_components=None, n_features=None, ensure_min_samples=1):\n    \"\"\"Check the input data X.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    n_components : int\n\n    Returns\n    -------\n    X : array, shape (n_samples, n_features)\n    \"\"\"\n    X = check_array(X, dtype=[np.float64, np.float32],\n                    ensure_min_samples=ensure_min_samples)\n    if n_components is not None and X.shape[0] < n_components:\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))", "\"\"\"Base class for mixture models.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nfrom __future__ import print_function\n\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom time import time\n\nimport numpy as np\n\nfrom .. import cluster\nfrom ..base import BaseEstimator\nfrom ..base import DensityMixin\nfrom ..externals import six\nfrom ..exceptions import ConvergenceWarning\nfrom ..utils import check_array, check_random_state\nfrom ..utils.fixes import logsumexp\n\n\ndef _check_shape(param, param_shape, name):\n    \"\"\"Validate the shape of the input parameter 'param'.\n\n    Parameters\n    ----------\n    param : array\n\n    param_shape : tuple\n\n    name : string\n    \"\"\"\n    param = np.array(param)\n    if param.shape != param_shape:\n        raise ValueError(\"The parameter '%s' should have the shape of %s, \"\n                         \"but got %s\" % (name, param_shape, param.shape))\n\n\ndef _check_X(X, n_components=None, n_features=None, ensure_min_samples=1):\n    \"\"\"Check the input data X.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    n_components : int\n\n    Returns\n    -------\n    X : array, shape (n_samples, n_features)\n    \"\"\"\n    X = check_array(X, dtype=[np.float64, np.float32],\n                    ensure_min_samples=ensure_min_samples)\n    if n_components is not None and X.shape[0] < n_components:\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))", "\"\"\"Gaussian Mixture Model.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nimport numpy as np\n\nfrom scipy import linalg\n\nfrom .base import BaseMixture, _check_shape\nfrom ..externals.six.moves import zip\nfrom ..utils import check_array\nfrom ..utils.validation import check_is_fitted\nfrom ..utils.extmath import row_norms\n\n\n###############################################################################\n# Gaussian mixture shape checkers used by the GaussianMixture class\n\ndef _check_weights(weights, n_components):\n    \"\"\"Check the user provided 'weights'.\n\n    Parameters\n    ----------\n    weights : array-like, shape (n_components,)\n        The proportions of components of each mixture.\n\n    n_components : int\n        Number of components.\n\n    Returns\n    -------\n    weights : array, shape (n_components,)\n    \"\"\"\n    weights = check_array(weights, dtype=[np.float64, np.float32],\n                          ensure_2d=False)\n    _check_shape(weights, (n_components,), 'weights')\n\n    # check range\n    if (any(np.less(weights, 0.)) or\n            any(np.greater(weights, 1.))):\n        raise ValueError(\"The parameter 'weights' should be in the range \"\n                         \"[0, 1], but got max value %.5f, min value %.5f\"\n                         % (np.min(weights), np.max(weights)))\n\n    # check normalization\n    if not np.allclose(np.abs(1. - np.sum(weights)), 0.):\n        raise ValueError(\"The parameter 'weights' should be normalized, \"\n                         \"but got sum(weights) = %.5f\" % np.sum(weights))\n    return weights\n\n\ndef _check_means(means, n_components, n_features):\n    \"\"\"Validate the provided 'means'.\n\n    Parameters\n    ----------\n    means : array-like, shape (n_components, n_features)\n        The centers of the current components.\n\n    n_components : int\n        Number of components.\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    means : array, (n_components, n_features)\n    \"\"\"\n    means = check_array(means, dtype=[np.float64, np.float32], ensure_2d=False)\n    _check_shape(means, (n_components, n_features), 'means')\n    return means\n\n\ndef _check_precision_positivity(precision, covariance_type):\n    \"\"\"Check a precision vector is positive-definite.\"\"\"\n    if np.any(np.less_equal(precision, 0.0)):\n        raise ValueError(\"'%s precision' should be \"\n                         \"positive\" % covariance_type)\n\n\ndef _check_precision_matrix(precision, covariance_type):\n    \"\"\"Check a precision matrix is symmetric and positive-definite.\"\"\"\n    if not (np.allclose(precision, precision.T) and\n            np.all(linalg.eigvalsh(precision) > 0.)):\n        raise ValueError(\"'%s precision' should be symmetric, \"\n                         \"positive-definite\" % covariance_type)\n\n\ndef _check_precisions_full(precisions, covariance_type):\n    \"\"\"Check the precision matrices are symmetric and positive-definite.\"\"\"\n    for prec in precisions:\n        _check_precision_matrix(prec, covariance_type)\n\n\ndef _check_precisions(precisions, covariance_type, n_components, n_features):\n    \"\"\"Validate user provided precisions.\n\n    Parameters\n    ----------\n    precisions : array-like\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : string\n\n    n_components : int\n        Number of components.\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    precisions : array\n    \"\"\"\n    precisions = check_array(precisions, dtype=[np.float64, np.float32],\n                             ensure_2d=False,\n                             allow_nd=covariance_type == 'full')\n\n    precisions_shape = {'full': (n_components, n_features, n_features),\n                        'tied': (n_features, n_features),\n                        'diag': (n_components, n_features),\n                        'spherical': (n_components,)}\n    _check_shape(precisions, precisions_shape[covariance_type],\n                 '%s precision' % covariance_type)\n\n    _check_precisions = {'full': _check_precisions_full,\n                         'tied': _check_precision_matrix,\n                         'diag': _check_precision_positivity,\n                         'spherical': _check_precision_positivity}\n    _check_precisions[covariance_type](precisions, covariance_type)\n    return precisions\n\n\n###############################################################################\n# Gaussian mixture parameters estimators (used by the M-Step)\n\ndef _estimate_gaussian_covariances_full(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the full covariance matrices.\n\n    Parameters\n    ----------\n    resp : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariances : array, shape (n_components, n_features, n_features)\n        The covariance matrix of the current components.\n    \"\"\"\n    n_components, n_features = means.shape\n    covariances = np.empty((n_components, n_features, n_features))\n    for k in range(n_components):\n        diff = X - means[k]\n        covariances[k] = np.dot(resp[:, k] * diff.T, diff) / nk[k]\n        covariances[k].flat[::n_features + 1] += reg_covar\n    return covariances\n\n\ndef _estimate_gaussian_covariances_tied(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the tied covariance matrix.\n\n    Parameters\n    ----------\n    resp : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariance : array, shape (n_features, n_features)\n        The tied covariance matrix of the components.\n    \"\"\"\n    avg_X2 = np.dot(X.T, X)\n    avg_means2 = np.dot(nk * means.T, means)\n    covariance = avg_X2 - avg_means2\n    covariance /= nk.sum()\n    covariance.flat[::len(covariance) + 1] += reg_covar\n    return covariance\n\n\ndef _estimate_gaussian_covariances_diag(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the diagonal covariance vectors.\n\n    Parameters\n    ----------\n    responsibilities : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    covariances : array, shape (n_components, n_features)\n        The covariance vector of the current components.\n    \"\"\"\n    avg_X2 = np.dot(resp.T, X * X) / nk[:, np.newaxis]\n    avg_means2 = means ** 2\n    avg_X_means = means * np.dot(resp.T, X) / nk[:, np.newaxis]\n    return avg_X2 - 2 * avg_X_means + avg_means2 + reg_covar\n\n\ndef _estimate_gaussian_covariances_spherical(resp, X, nk, means, reg_covar):\n    \"\"\"Estimate the spherical variance values.\n\n    Parameters\n    ----------\n    responsibilities : array-like, shape (n_samples, n_components)\n\n    X : array-like, shape (n_samples, n_features)\n\n    nk : array-like, shape (n_components,)\n\n    means : array-like, shape (n_components, n_features)\n\n    reg_covar : float\n\n    Returns\n    -------\n    variances : array, shape (n_components,)\n        The variance values of each components.\n    \"\"\"\n    return _estimate_gaussian_covariances_diag(resp, X, nk,\n                                               means, reg_covar).mean(1)\n\n\ndef _estimate_gaussian_parameters(X, resp, reg_covar, covariance_type):\n    \"\"\"Estimate the Gaussian distribution parameters.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n        The input data array.\n\n    resp : array-like, shape (n_samples, n_components)\n        The responsibilities for each data sample in X.\n\n    reg_covar : float\n        The regularization added to the diagonal of the covariance matrices.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n        The type of precision matrices.\n\n    Returns\n    -------\n    nk : array-like, shape (n_components,)\n        The numbers of data samples in the current components.\n\n    means : array-like, shape (n_components, n_features)\n        The centers of the current components.\n\n    covariances : array-like\n        The covariance matrix of the current components.\n        The shape depends of the covariance_type.\n    \"\"\"\n    nk = resp.sum(axis=0) + 10 * np.finfo(resp.dtype).eps\n    means = np.dot(resp.T, X) / nk[:, np.newaxis]\n    covariances = {\"full\": _estimate_gaussian_covariances_full,\n                   \"tied\": _estimate_gaussian_covariances_tied,\n                   \"diag\": _estimate_gaussian_covariances_diag,\n                   \"spherical\": _estimate_gaussian_covariances_spherical\n                   }[covariance_type](resp, X, nk, means, reg_covar)\n    return nk, means, covariances\n\n\ndef _compute_precision_cholesky(covariances, covariance_type):\n    \"\"\"Compute the Cholesky decomposition of the precisions.\n\n    Parameters\n    ----------\n    covariances : array-like\n        The covariance matrix of the current components.\n        The shape depends of the covariance_type.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n        The type of precision matrices.\n\n    Returns\n    -------\n    precisions_cholesky : array-like\n        The cholesky decomposition of sample precisions of the current\n        components. The shape depends of the covariance_type.\n    \"\"\"\n    estimate_precision_error_message = (\n        \"Fitting the mixture model failed because some components have \"\n        \"ill-defined empirical covariance (for instance caused by singleton \"\n        \"or collapsed samples). Try to decrease the number of components, \"\n        \"or increase reg_covar.\")\n\n    if covariance_type in 'full':\n        n_components, n_features, _ = covariances.shape\n        precisions_chol = np.empty((n_components, n_features, n_features))\n        for k, covariance in enumerate(covariances):\n            try:\n                cov_chol = linalg.cholesky(covariance, lower=True)\n            except linalg.LinAlgError:\n                raise ValueError(estimate_precision_error_message)\n            precisions_chol[k] = linalg.solve_triangular(cov_chol,\n                                                         np.eye(n_features),\n                                                         lower=True).T\n    elif covariance_type == 'tied':\n        _, n_features = covariances.shape\n        try:\n            cov_chol = linalg.cholesky(covariances, lower=True)\n        except linalg.LinAlgError:\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = linalg.solve_triangular(cov_chol, np.eye(n_features),\n                                                  lower=True).T\n    else:\n        if np.any(np.less_equal(covariances, 0.0)):\n            raise ValueError(estimate_precision_error_message)\n        precisions_chol = 1. / np.sqrt(covariances)\n    return precisions_chol\n\n\n###############################################################################\n# Gaussian mixture probability estimators\ndef _compute_log_det_cholesky(matrix_chol, covariance_type, n_features):\n    \"\"\"Compute the log-det of the cholesky decomposition of matrices.\n\n    Parameters\n    ----------\n    matrix_chol : array-like\n        Cholesky decompositions of the matrices.\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n\n    n_features : int\n        Number of features.\n\n    Returns\n    -------\n    log_det_precision_chol : array-like, shape (n_components,)\n        The determinant of the precision matrix for each component.\n    \"\"\"\n    if covariance_type == 'full':\n        n_components, _, _ = matrix_chol.shape\n        log_det_chol = (np.sum(np.log(\n            matrix_chol.reshape(\n                n_components, -1)[:, ::n_features + 1]), 1))\n\n    elif covariance_type == 'tied':\n        log_det_chol = (np.sum(np.log(np.diag(matrix_chol))))\n\n    elif covariance_type == 'diag':\n        log_det_chol = (np.sum(np.log(matrix_chol), axis=1))\n\n    else:\n        log_det_chol = n_features * (np.log(matrix_chol))\n\n    return log_det_chol\n\n\ndef _estimate_log_gaussian_prob(X, means, precisions_chol, covariance_type):\n    \"\"\"Estimate the log Gaussian probability.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    means : array-like, shape (n_components, n_features)\n\n    precisions_chol : array-like\n        Cholesky decompositions of the precision matrices.\n        'full' : shape of (n_components, n_features, n_features)\n        'tied' : shape of (n_features, n_features)\n        'diag' : shape of (n_components, n_features)\n        'spherical' : shape of (n_components,)\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'}\n\n    Returns\n    -------\n    log_prob : array, shape (n_samples, n_components)\n    \"\"\"\n    n_samples, n_features = X.shape\n    n_components, _ = means.shape\n    # det(precision_chol) is half of det(precision)\n    log_det = _compute_log_det_cholesky(\n        precisions_chol, covariance_type, n_features)\n\n    if covariance_type == 'full':\n        log_prob = np.empty((n_samples, n_components))\n        for k, (mu, prec_chol) in enumerate(zip(means, precisions_chol)):\n            y = np.dot(X, prec_chol) - np.dot(mu, prec_chol)\n            log_prob[:, k] = np.sum(np.square(y), axis=1)\n\n    elif covariance_type == 'tied':\n        log_prob = np.empty((n_samples, n_components))\n        for k, mu in enumerate(means):\n            y = np.dot(X, precisions_chol) - np.dot(mu, precisions_chol)\n            log_prob[:, k] = np.sum(np.square(y), axis=1)\n\n    elif covariance_type == 'diag':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum((means ** 2 * precisions), 1) -\n                    2. * np.dot(X, (means * precisions).T) +\n                    np.dot(X ** 2, precisions.T))\n\n    elif covariance_type == 'spherical':\n        precisions = precisions_chol ** 2\n        log_prob = (np.sum(means ** 2, 1) * precisions -\n                    2 * np.dot(X, means.T * precisions) +\n                    np.outer(row_norms(X, squared=True), precisions))\n    return -.5 * (n_features * np.log(2 * np.pi) + log_prob) + log_det\n\n\nclass GaussianMixture(BaseMixture):\n    \"\"\"Gaussian Mixture.\n\n    Representation of a Gaussian mixture model probability distribution.\n    This class allows to estimate the parameters of a Gaussian mixture\n    distribution.\n\n    Read more in the :ref:`User Guide <gmm>`.\n\n    .. versionadded:: 0.18\n\n    Parameters\n    ----------\n    n_components : int, defaults to 1.\n        The number of mixture components.\n\n    covariance_type : {'full', 'tied', 'diag', 'spherical'},\n            defaults to 'full'.\n        String describing the type of covariance parameters to use.\n        Must be one of::\n\n            'full' (each component has its own general covariance matrix),\n            'tied' (all components share the same general covariance matrix),\n            'diag' (each component has its own diagonal covariance matrix),\n            'spherical' (each component has its own single variance).\n\n    tol : float, defaults to 1e-3.\n        The convergence threshold. EM iterations will stop when the\n        lower bound average gain is below this threshold.\n\n    reg_covar : float, defaults to 1e-6.\n        Non-negative regularization added to the diagonal of covariance.\n        Allows to assure that the covariance matrices are all positive.\n\n    max_iter : int, defaults to 100.\n        The number of EM iterations to perform.\n\n    n_init : int, defaults to 1.\n        The number of initializations to perform. The best results are kept.\n\n    init_params : {'kmeans', 'random'}, defaults to 'kmeans'.\n        The method used to initialize the weights, the means and the\n        precisions.\n        Must be one of::\n\n            'kmeans' : responsibilities are initialized using kmeans.\n            'random' : responsibilities are initialized randomly.\n\n    weights_init : array-like, shape (n_components, ), optional\n        The user-provided initial weights, defaults to None.\n        If it None, weights are initialized using the `init_params` method.\n\n    means_init : array-like, shape (n_components, n_features), optional\n        The user-provided initial means, defaults to None,\n        If it None, means are initialized using the `init_params` method.\n\n    precisions_init : array-like, optional.\n        The user-provided initial precisions (inverse of the covariance\n        matrices), defaults to None.\n        If it None, precisions are initialized using the 'init_params' method.\n        The shape depends on 'covariance_type'::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    random_state : int, RandomState instance or None, optional (default=None)\n        If int, random_state is the seed used by the random number generator;\n        If RandomState instance, random_state is the random number generator;\n        If None, the random number generator is the RandomState instance used\n        by `np.random`.\n\n    warm_start : bool, default to False.\n        If 'warm_start' is True, the solution of the last fitting is used as\n        initialization for the next call of fit(). This can speed up\n        convergence when fit is called several times on similar problems.\n        See :term:`the Glossary <warm_start>`.\n\n    verbose : int, default to 0.\n        Enable verbose output. If 1 then it prints the current\n        initialization and each iteration step. If greater than 1 then\n        it prints also the log probability and the time needed\n        for each step.\n\n    verbose_interval : int, default to 10.\n        Number of iteration done before the next print.\n\n    Attributes\n    ----------\n    weights_ : array-like, shape (n_components,)\n        The weights of each mixture components.\n\n    means_ : array-like, shape (n_components, n_features)\n        The mean of each mixture component.\n\n    covariances_ : array-like\n        The covariance of each mixture component.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_ : array-like\n        The precision matrices for each component in the mixture. A precision\n        matrix is the inverse of a covariance matrix. A covariance matrix is\n        symmetric positive definite so the mixture of Gaussian can be\n        equivalently parameterized by the precision matrices. Storing the\n        precision matrices instead of the covariance matrices makes it more\n        efficient to compute the log-likelihood of new samples at test time.\n        The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    precisions_cholesky_ : array-like\n        The cholesky decomposition of the precision matrices of each mixture\n        component. A precision matrix is the inverse of a covariance matrix.\n        A covariance matrix is symmetric positive definite so the mixture of\n        Gaussian can be equivalently parameterized by the precision matrices.\n        Storing the precision matrices instead of the covariance matrices makes\n        it more efficient to compute the log-likelihood of new samples at test\n        time. The shape depends on `covariance_type`::\n\n            (n_components,)                        if 'spherical',\n            (n_features, n_features)               if 'tied',\n            (n_components, n_features)             if 'diag',\n            (n_components, n_features, n_features) if 'full'\n\n    converged_ : bool\n        True when convergence was reached in fit(), False otherwise.\n\n    n_iter_ : int\n        Number of step used by the best fit of EM to reach the convergence.\n\n    lower_bound_ : float\n        Log-likelihood of the best fit of EM.\n\n    See Also\n    --------\n    BayesianGaussianMixture : Gaussian mixture model fit with a variational\n        inference.\n    \"\"\"\n\n    def __init__(self, n_components=1, covariance_type='full', tol=1e-3,\n                 reg_covar=1e-6, max_iter=100, n_init=1, init_params='kmeans',\n                 weights_init=None, means_init=None, precisions_init=None,\n                 random_state=None, warm_start=False,\n                 verbose=0, verbose_interval=10):\n        super(GaussianMixture, self).__init__(\n            n_components=n_components, tol=tol, reg_covar=reg_covar,\n            max_iter=max_iter, n_init=n_init, init_params=init_params,\n            random_state=random_state, warm_start=warm_start,\n            verbose=verbose, verbose_interval=verbose_interval)\n\n        self.covariance_type = covariance_type\n        self.weights_init = weights_init\n        self.means_init = means_init\n        self.precisions_init = precisions_init\n\n    def _check_parameters(self, X):\n        \"\"\"Check the Gaussian mixture parameters are well defined.\"\"\"\n        _, n_features = X.shape\n        if self.covariance_type not in ['spherical', 'tied', 'diag', 'full']:\n            raise ValueError(\"Invalid value for 'covariance_type': %s \"\n                             \"'covariance_type' should be in \"\n                             \"['spherical', 'tied', 'diag', 'full']\"\n                             % self.covariance_type)\n\n        if self.weights_init is not None:\n            self.weights_init = _check_weights(self.weights_init,\n                                               self.n_components)\n\n        if self.means_init is not None:\n            self.means_init = _check_means(self.means_init,\n                                           self.n_components, n_features)\n\n        if self.precisions_init is not None:\n            self.precisions_init = _check_precisions(self.precisions_init,\n                                                     self.covariance_type,\n                                                     self.n_components,\n                                                     n_features)\n\n    def _initialize(self, X, resp):\n        \"\"\"Initialization of the Gaussian mixture parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        n_samples, _ = X.shape\n\n        weights, means, covariances = _estimate_gaussian_parameters(\n            X, resp, self.reg_covar, self.covariance_type)\n        weights /= n_samples\n\n        self.weights_ = (weights if self.weights_init is None\n                         else self.weights_init)\n        self.means_ = means if self.means_init is None else self.means_init\n\n        if self.precisions_init is None:\n            self.covariances_ = covariances\n            self.precisions_cholesky_ = _compute_precision_cholesky(\n                covariances, self.covariance_type)\n        elif self.covariance_type == 'full':\n            self.precisions_cholesky_ = np.array(\n                [linalg.cholesky(prec_init, lower=True)\n                 for prec_init in self.precisions_init])\n        elif self.covariance_type == 'tied':\n            self.precisions_cholesky_ = linalg.cholesky(self.precisions_init,\n                                                        lower=True)\n        else:\n            self.precisions_cholesky_ = self.precisions_init\n\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        n_samples, _ = X.shape\n        self.weights_, self.means_, self.covariances_ = (\n            _estimate_gaussian_parameters(X, np.exp(log_resp), self.reg_covar,\n                                          self.covariance_type))\n        self.weights_ /= n_samples\n        self.precisions_cholesky_ = _compute_precision_cholesky(\n            self.covariances_, self.covariance_type)\n\n    def _estimate_log_prob(self, X):\n        return _estimate_log_gaussian_prob(\n            X, self.means_, self.precisions_cholesky_, self.covariance_type)\n\n    def _estimate_log_weights(self):\n        return np.log(self.weights_)\n\n    def _compute_lower_bound(self, _, log_prob_norm):\n        return log_prob_norm\n\n    def _check_is_fitted(self):\n        check_is_fitted(self, ['weights_', 'means_', 'precisions_cholesky_'])\n\n    def _get_parameters(self):\n        return (self.weights_, self.means_, self.covariances_,\n                self.precisions_cholesky_)\n\n    def _set_parameters(self, params):\n        (self.weights_, self.means_, self.covariances_,\n         self.precisions_cholesky_) = params\n\n        # Attributes computation\n        _, n_features = self.means_.shape\n\n        if self.covariance_type == 'full':\n            self.precisions_ = np.empty(self.precisions_cholesky_.shape)\n            for k, prec_chol in enumerate(self.precisions_cholesky_):\n                self.precisions_[k] = np.dot(prec_chol, prec_chol.T)\n\n        elif self.covariance_type == 'tied':\n            self.precisions_ = np.dot(self.precisions_cholesky_,\n                                      self.precisions_cholesky_.T)\n        else:\n            self.precisions_ = self.precisions_cholesky_ ** 2\n\n    def _n_parameters(self):\n        \"\"\"Return the number of free parameters in the model.\"\"\"\n        _, n_features = self.means_.shape\n        if self.covariance_type == 'full':\n            cov_params = self.n_components * n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'diag':\n            cov_params = self.n_components * n_features\n        elif self.covariance_type == 'tied':\n            cov_params = n_features * (n_features + 1) / 2.\n        elif self.covariance_type == 'spherical':\n            cov_params = self.n_components\n        mean_params = n_features * self.n_components\n        return int(cov_params + mean_params + self.n_components - 1)\n\n    def bic(self, X):\n        \"\"\"Bayesian information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        bic : float\n            The lower the better.\n        \"\"\"\n        return (-2 * self.score(X) * X.shape[0] +\n                self._n_parameters() * np.log(X.shape[0]))\n\n    def aic(self, X):\n        \"\"\"Akaike information criterion for the current model on the input X.\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_dimensions)\n\n        Returns\n        -------\n        aic : float\n            The lower the better.\n        \"\"\"\n        return -2 * self.score(X) * X.shape[0] + 2 * self._n_parameters()", "\"\"\"Base class for mixture models.\"\"\"\n\n# Author: Wei Xue <xuewei4d@gmail.com>\n# Modified by Thierry Guillemot <thierry.guillemot.work@gmail.com>\n# License: BSD 3 clause\n\nfrom __future__ import print_function\n\nimport warnings\nfrom abc import ABCMeta, abstractmethod\nfrom time import time\n\nimport numpy as np\n\nfrom .. import cluster\nfrom ..base import BaseEstimator\nfrom ..base import DensityMixin\nfrom ..externals import six\nfrom ..exceptions import ConvergenceWarning\nfrom ..utils import check_array, check_random_state\nfrom ..utils.fixes import logsumexp\n\n\ndef _check_shape(param, param_shape, name):\n    \"\"\"Validate the shape of the input parameter 'param'.\n\n    Parameters\n    ----------\n    param : array\n\n    param_shape : tuple\n\n    name : string\n    \"\"\"\n    param = np.array(param)\n    if param.shape != param_shape:\n        raise ValueError(\"The parameter '%s' should have the shape of %s, \"\n                         \"but got %s\" % (name, param_shape, param.shape))\n\n\ndef _check_X(X, n_components=None, n_features=None, ensure_min_samples=1):\n    \"\"\"Check the input data X.\n\n    Parameters\n    ----------\n    X : array-like, shape (n_samples, n_features)\n\n    n_components : int\n\n    Returns\n    -------\n    X : array, shape (n_samples, n_features)\n    \"\"\"\n    X = check_array(X, dtype=[np.float64, np.float32],\n                    ensure_min_samples=ensure_min_samples)\n    if n_components is not None and X.shape[0] < n_components:\n        raise ValueError('Expected n_samples >= n_components '\n                         'but got n_components = %d, n_samples = %d'\n                         % (n_components, X.shape[0]))\n    if n_features is not None and X.shape[1] != n_features:\n        raise ValueError(\"Expected the input data X have %d features, \"\n                         \"but got %d features\"\n                         % (n_features, X.shape[1]))\n    return X\n\n\nclass BaseMixture(six.with_metaclass(ABCMeta, DensityMixin, BaseEstimator)):\n    \"\"\"Base class for mixture models.\n\n    This abstract class specifies an interface for all mixture classes and\n    provides basic common methods for mixture models.\n    \"\"\"\n\n    def __init__(self, n_components, tol, reg_covar,\n                 max_iter, n_init, init_params, random_state, warm_start,\n                 verbose, verbose_interval):\n        self.n_components = n_components\n        self.tol = tol\n        self.reg_covar = reg_covar\n        self.max_iter = max_iter\n        self.n_init = n_init\n        self.init_params = init_params\n        self.random_state = random_state\n        self.warm_start = warm_start\n        self.verbose = verbose\n        self.verbose_interval = verbose_interval\n\n    def _check_initial_parameters(self, X):\n        \"\"\"Check values of the basic parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n        \"\"\"\n        if self.n_components < 1:\n            raise ValueError(\"Invalid value for 'n_components': %d \"\n                             \"Estimation requires at least one component\"\n                             % self.n_components)\n\n        if self.tol < 0.:\n            raise ValueError(\"Invalid value for 'tol': %.5f \"\n                             \"Tolerance used by the EM must be non-negative\"\n                             % self.tol)\n\n        if self.n_init < 1:\n            raise ValueError(\"Invalid value for 'n_init': %d \"\n                             \"Estimation requires at least one run\"\n                             % self.n_init)\n\n        if self.max_iter < 1:\n            raise ValueError(\"Invalid value for 'max_iter': %d \"\n                             \"Estimation requires at least one iteration\"\n                             % self.max_iter)\n\n        if self.reg_covar < 0.:\n            raise ValueError(\"Invalid value for 'reg_covar': %.5f \"\n                             \"regularization on covariance must be \"\n                             \"non-negative\"\n                             % self.reg_covar)\n\n        # Check all the parameters values of the derived class\n        self._check_parameters(X)\n\n    @abstractmethod\n    def _check_parameters(self, X):\n        \"\"\"Check initial parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n        \"\"\"\n        pass\n\n    def _initialize_parameters(self, X, random_state):\n        \"\"\"Initialize the model parameters.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        random_state : RandomState\n            A random number generator instance.\n        \"\"\"\n        n_samples, _ = X.shape\n\n        if self.init_params == 'kmeans':\n            resp = np.zeros((n_samples, self.n_components))\n            label = cluster.KMeans(n_clusters=self.n_components, n_init=1,\n                                   random_state=random_state).fit(X).labels_\n            resp[np.arange(n_samples), label] = 1\n        elif self.init_params == 'random':\n            resp = random_state.rand(n_samples, self.n_components)\n            resp /= resp.sum(axis=1)[:, np.newaxis]\n        else:\n            raise ValueError(\"Unimplemented initialization method '%s'\"\n                             % self.init_params)\n\n        self._initialize(X, resp)\n\n    @abstractmethod\n    def _initialize(self, X, resp):\n        \"\"\"Initialize the model parameters of the derived class.\n\n        Parameters\n        ----------\n        X : array-like, shape  (n_samples, n_features)\n\n        resp : array-like, shape (n_samples, n_components)\n        \"\"\"\n        pass\n\n    def fit(self, X, y=None):\n        \"\"\"Estimate model parameters with the EM algorithm.\n\n        The method fit the model `n_init` times and set the parameters with\n        which the model has the largest likelihood or lower bound. Within each\n        trial, the method iterates between E-step and M-step for `max_iter`\n        times until the change of likelihood or lower bound is less than\n        `tol`, otherwise, a `ConvergenceWarning` is raised.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        X = _check_X(X, self.n_components, ensure_min_samples=2)\n        self._check_initial_parameters(X)\n\n        # if we enable warm_start, we will have a unique initialisation\n        do_init = not(self.warm_start and hasattr(self, 'converged_'))\n        n_init = self.n_init if do_init else 1\n\n        max_lower_bound = -np.infty\n        self.converged_ = False\n\n        random_state = check_random_state(self.random_state)\n\n        n_samples, _ = X.shape\n        for init in range(n_init):\n            self._print_verbose_msg_init_beg(init)\n\n            if do_init:\n                self._initialize_parameters(X, random_state)\n                self.lower_bound_ = -np.infty\n\n            for n_iter in range(1, self.max_iter + 1):\n                prev_lower_bound = self.lower_bound_\n\n                log_prob_norm, log_resp = self._e_step(X)\n                self._m_step(X, log_resp)\n                self.lower_bound_ = self._compute_lower_bound(\n                    log_resp, log_prob_norm)\n\n                change = self.lower_bound_ - prev_lower_bound\n                self._print_verbose_msg_iter_end(n_iter, change)\n\n                if abs(change) < self.tol:\n                    self.converged_ = True\n                    break\n\n            self._print_verbose_msg_init_end(self.lower_bound_)\n\n            if self.lower_bound_ > max_lower_bound:\n                max_lower_bound = self.lower_bound_\n                best_params = self._get_parameters()\n                best_n_iter = n_iter\n\n        if not self.converged_:\n            warnings.warn('Initialization %d did not converge. '\n                          'Try different init parameters, '\n                          'or increase max_iter, tol '\n                          'or check for degenerate data.'\n                          % (init + 1), ConvergenceWarning)\n\n        self._set_parameters(best_params)\n        self.n_iter_ = best_n_iter\n\n        return self\n\n    def _e_step(self, X):\n        \"\"\"E step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : float\n            Mean of the logarithms of the probabilities of each sample in X\n\n        log_responsibility : array, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        log_prob_norm, log_resp = self._estimate_log_prob_resp(X)\n        return np.mean(log_prob_norm), log_resp\n\n    @abstractmethod\n    def _m_step(self, X, log_resp):\n        \"\"\"M step.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        log_resp : array-like, shape (n_samples, n_components)\n            Logarithm of the posterior probabilities (or responsibilities) of\n            the point of each sample in X.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _check_is_fitted(self):\n        pass\n\n    @abstractmethod\n    def _get_parameters(self):\n        pass\n\n    @abstractmethod\n    def _set_parameters(self, params):\n        pass\n\n    def score_samples(self, X):\n        \"\"\"Compute the weighted log probabilities for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples,)\n            Log probabilities of each data point in X.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n\n        return logsumexp(self._estimate_weighted_log_prob(X), axis=1)\n\n    def score(self, X, y=None):\n        \"\"\"Compute the per-sample average log-likelihood of the given data X.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_dimensions)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        log_likelihood : float\n            Log likelihood of the Gaussian mixture given X.\n        \"\"\"\n        return self.score_samples(X).mean()\n\n    def predict(self, X):\n        \"\"\"Predict the labels for the data samples in X using trained model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        labels : array, shape (n_samples,)\n            Component labels.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        return self._estimate_weighted_log_prob(X).argmax(axis=1)\n\n    def predict_proba(self, X):\n        \"\"\"Predict posterior probability of each component given the data.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n            List of n_features-dimensional data points. Each row\n            corresponds to a single data point.\n\n        Returns\n        -------\n        resp : array, shape (n_samples, n_components)\n            Returns the probability each Gaussian (state) in\n            the model given each sample.\n        \"\"\"\n        self._check_is_fitted()\n        X = _check_X(X, None, self.means_.shape[1])\n        _, log_resp = self._estimate_log_prob_resp(X)\n        return np.exp(log_resp)\n\n    def sample(self, n_samples=1):\n        \"\"\"Generate random samples from the fitted Gaussian distribution.\n\n        Parameters\n        ----------\n        n_samples : int, optional\n            Number of samples to generate. Defaults to 1.\n\n        Returns\n        -------\n        X : array, shape (n_samples, n_features)\n            Randomly generated sample\n\n        y : array, shape (nsamples,)\n            Component labels\n\n        \"\"\"\n        self._check_is_fitted()\n\n        if n_samples < 1:\n            raise ValueError(\n                \"Invalid value for 'n_samples': %d . The sampling requires at \"\n                \"least one sample.\" % (self.n_components))\n\n        _, n_features = self.means_.shape\n        rng = check_random_state(self.random_state)\n        n_samples_comp = rng.multinomial(n_samples, self.weights_)\n\n        if self.covariance_type == 'full':\n            X = np.vstack([\n                rng.multivariate_normal(mean, covariance, int(sample))\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n        elif self.covariance_type == \"tied\":\n            X = np.vstack([\n                rng.multivariate_normal(mean, self.covariances_, int(sample))\n                for (mean, sample) in zip(\n                    self.means_, n_samples_comp)])\n        else:\n            X = np.vstack([\n                mean + rng.randn(sample, n_features) * np.sqrt(covariance)\n                for (mean, covariance, sample) in zip(\n                    self.means_, self.covariances_, n_samples_comp)])\n\n        y = np.concatenate([j * np.ones(sample, dtype=int)\n                           for j, sample in enumerate(n_samples_comp)])\n\n        return (X, y)\n\n    def _estimate_weighted_log_prob(self, X):\n        \"\"\"Estimate the weighted log-probabilities, log P(X | Z) + log weights.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        weighted_log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        return self._estimate_log_prob(X) + self._estimate_log_weights()\n\n    @abstractmethod\n    def _estimate_log_weights(self):\n        \"\"\"Estimate log-weights in EM algorithm, E[ log pi ] in VB algorithm.\n\n        Returns\n        -------\n        log_weight : array, shape (n_components, )\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _estimate_log_prob(self, X):\n        \"\"\"Estimate the log-probabilities log P(X | Z).\n\n        Compute the log-probabilities per each component for each sample.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob : array, shape (n_samples, n_component)\n        \"\"\"\n        pass\n\n    def _estimate_log_prob_resp(self, X):\n        \"\"\"Estimate log probabilities and responsibilities for each sample.\n\n        Compute the log probabilities, weighted log probabilities per\n        component and responsibilities for each sample in X with respect to\n        the current state of the model.\n\n        Parameters\n        ----------\n        X : array-like, shape (n_samples, n_features)\n\n        Returns\n        -------\n        log_prob_norm : array, shape (n_samples,)\n            log p(X)\n\n        log_responsibilities : array, shape (n_samples, n_components)\n            logarithm of the responsibilities\n        \"\"\"\n        weighted_log_prob = self._estimate_weighted_log_prob(X)\n        log_prob_norm = logsumexp(weighted_log_prob, axis=1)\n        with np.errstate(under='ignore'):\n            # ignore underflow\n            log_resp = weighted_log_prob - log_prob_norm[:, np.newaxis]\n        return log_prob_norm, log_resp\n\n    def _print_verbose_msg_init_beg(self, n_init):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization %d\" % n_init)\n        elif self.verbose >= 2:\n            print(\"Initialization %d\" % n_init)\n            self._init_prev_time = time()\n            self._iter_prev_time = self._init_prev_time\n\n    def _print_verbose_msg_iter_end(self, n_iter, diff_ll):\n        \"\"\"Print verbose message on initialization.\"\"\"\n        if n_iter % self.verbose_interval == 0:\n            if self.verbose == 1:\n                print(\"  Iteration %d\" % n_iter)\n            elif self.verbose >= 2:\n                cur_time = time()\n                print(\"  Iteration %d\\t time lapse %.5fs\\t ll change %.5f\" % (\n                    n_iter, cur_time - self._iter_prev_time, diff_ll))\n                self._iter_prev_time = cur_time\n\n    def _print_verbose_msg_init_end(self, ll):\n        \"\"\"Print verbose message on the end of iteration.\"\"\"\n        if self.verbose == 1:\n            print(\"Initialization converged: %s\" % self.converged_)\n        elif self.verbose >= 2:\n            print(\"Initialization converged: %s\\t time lapse %.5fs\\t ll %.5f\" %\n                  (self.converged_, time() - self._init_prev_time, ll))"]], "file_names": [["sklearn/mixture/gaussian_mixture.py", "sklearn/mixture/base.py", "sklearn/mixture/base.py", "sklearn/mixture/gaussian_mixture.py", "sklearn/mixture/base.py", "sklearn/mixture/gaussian_mixture.py", "sklearn/mixture/base.py", "sklearn/mixture/base.py", "sklearn/mixture/gaussian_mixture.py", "sklearn/mixture/base.py"]]}
