{"instance_id": "sphinx-doc__sphinx-8435", "found_files": ["sphinx/ext/autodoc/typehints.py", "sphinx/ext/autodoc/directive.py", "sphinx/ext/autodoc/__init__.py", "sphinx/config.py", "sphinx/application.py"], "additional_artifact_loc_file": {"raw_output_files": "```\nsphinx/ext/autodoc/typehints.py\nsphinx/ext/autodoc/directive.py\nsphinx/ext/autodoc/__init__.py\nsphinx/config.py\nsphinx/application.py\n```"}, "file_traj": {"response": "```\nsphinx/ext/autodoc/typehints.py\nsphinx/ext/autodoc/directive.py\nsphinx/ext/autodoc/__init__.py\nsphinx/config.py\nsphinx/application.py\n```", "usage": {"completion_tokens": 45, "prompt_tokens": 1329}, "prompt": "Please look through the following GitHub problem description, and Repository structure and provide a list of files that one would need to edit to fix the problem.\n\n### GitHub Problem Description ###\nautodoc_type_aliases does not effect to variables and attributes\n**Describe the bug**\r\nautodoc_type_aliases does not effect to variables and attributes\r\n\r\n**To Reproduce**\r\n\r\n```\r\n# example.py\r\nfrom __future__ import annotations\r\n\r\n\r\n#: blah blah blah\r\nvar: String\r\n\r\n\r\nclass MyString:\r\n    \"mystring\"\r\n\r\n    #: blah blah blah\r\n    var: String\r\n```\r\n```\r\n# index.rst\r\n.. automodule:: example\r\n   :members:\r\n   :undoc-members:\r\n```\r\n```\r\n# conf.py\r\nautodoc_type_aliases = {\r\n    'String': 'example.MyString'\r\n}\r\n```\r\n\r\n**Expected behavior**\r\n`autodoc_type_aliases` should be applied to `example.var` and `example.MyString.var`.\r\n\r\n**Your project**\r\nN/A\r\n\r\n**Screenshots**\r\nN/A\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.9.0\r\n- Sphinx version: HEAD of 3.x branch\r\n- Sphinx extensions: sphinx.ext.autodoc\r\n- Extra tools: Nothing\r\n\r\n**Additional context**\r\nN/A\n\n\n###\n\n\n\n### Repository Structure ###\nsphinx/\n    setup.py\n    events.py\n    addnodes.py\n    parsers.py\n    versioning.py\n    jinja2glue.py\n    project.py\n    extension.py\n    highlighting.py\n    setup_command.py\n    io.py\n    deprecation.py\n    pygments_styles.py\n    roles.py\n    errors.py\n    config.py\n    registry.py\n    theming.py\n    application.py\n    __init__.py\n    __main__.py\n    transforms/\n        i18n.py\n        references.py\n        compact_bullet_list.py\n        __init__.py\n        post_transforms/\n            code.py\n            images.py\n            __init__.py\n    domains/\n        index.py\n        python.py\n        javascript.py\n        changeset.py\n        citation.py\n        std.py\n        cpp.py\n        math.py\n        rst.py\n        c.py\n        __init__.py\n    ext/\n        graphviz.py\n        imgconverter.py\n        imgmath.py\n        githubpages.py\n        intersphinx.py\n        inheritance_diagram.py\n        linkcode.py\n        viewcode.py\n        ifconfig.py\n        todo.py\n        mathjax.py\n        jsmath.py\n        apidoc.py\n        coverage.py\n        autosectionlabel.py\n        extlinks.py\n        __init__.py\n        doctest.py\n        duration.py\n        napoleon/\n            iterators.py\n            docstring.py\n            __init__.py\n        autosummary/\n            generate.py\n            __init__.py\n        autodoc/\n            typehints.py\n            importer.py\n            mock.py\n            directive.py\n            type_comment.py\n            __init__.py\n    writers/\n        html5.py\n        manpage.py\n        latex.py\n        html.py\n        texinfo.py\n        xml.py\n        __init__.py\n        text.py\n    pycode/\n        ast.py\n        parser.py\n        __init__.py\n    cmd/\n        build.py\n        quickstart.py\n        make_mode.py\n        __init__.py\n    directives/\n        code.py\n        other.py\n        patches.py\n        __init__.py\n    util/\n        requests.py\n        smartypants.py\n        typing.py\n        template.py\n        i18n.py\n        matching.py\n        texescape.py\n        jsdump.py\n        images.py\n        compat.py\n        inventory.py\n        fileutil.py\n        console.py\n        inspect.py\n        jsonimpl.py\n        pycompat.py\n        nodes.py\n        cfamily.py\n        math.py\n        docfields.py\n        rst.py\n        logging.py\n        docstrings.py\n        osutil.py\n        build_phase.py\n        docutils.py\n        png.py\n        __init__.py\n        tags.py\n        parallel.py\n        stemmer/\n            porter.py\n            __init__.py\n    environment/\n        __init__.py\n        collectors/\n            asset.py\n            indexentries.py\n            title.py\n            dependencies.py\n            toctree.py\n            metadata.py\n            __init__.py\n        adapters/\n            asset.py\n            indexentries.py\n            toctree.py\n            __init__.py\n    search/\n        es.py\n        hu.py\n        ru.py\n        zh.py\n        sv.py\n        jssplitter.py\n        ja.py\n        ro.py\n        en.py\n        da.py\n        pt.py\n        tr.py\n        fr.py\n        de.py\n        it.py\n        nl.py\n        fi.py\n        __init__.py\n        no.py\n    locale/\n        __init__.py\n    builders/\n        singlehtml.py\n        manpage.py\n        applehelp.py\n        linkcheck.py\n        gettext.py\n        epub3.py\n        changes.py\n        _epub_base.py\n        htmlhelp.py\n        devhelp.py\n        texinfo.py\n        dirhtml.py\n        dummy.py\n        xml.py\n        qthelp.py\n        __init__.py\n        text.py\n        latex/\n            transforms.py\n            constants.py\n            nodes.py\n            theming.py\n            util.py\n            __init__.py\n        html/\n            transforms.py\n            __init__.py\ndoc/\n    conf.py\n    usage/\n        extensions/\n            example_google.py\n            example_numpy.py\n    development/\n        tutorials/\n            examples/\n                recipe.py\n                todo.py\n                helloworld.py\nutils/\n    checks.py\n    bump_version.py\n    doclinter.py\n    __init__.py\n    jssplitter_generator.py\n\n###\n\nPlease only provide the full path and return at most 5 files.\nThe returned files should be separated by new lines ordered by most to least important and wrapped with ```\nFor example:\n```\nfile1.py\nfile2.py\n```"}, "found_related_locs": [["function: record_typehints\nfunction: merge_typehints\nfunction: insert_field_list\nfunction: modify_field_list\nfunction: setup"], ["class: AutodocDirective\nfunction: process_documenter_options\nfunction: parse_generated_content"], ["class: Documenter\nclass: DataDocumenter\nclass: AttributeDocumenter\nclass: InstanceAttributeDocumenter\nclass: SlotsAttributeDocumenter\nfunction: get_documenters\nfunction: autodoc_attrgetter\nfunction: migrate_autodoc_member_order\nfunction: setup"]], "additional_artifact_loc_related": [{"raw_output_loc": "```\nsphinx/ext/autodoc/typehints.py\nfunction: record_typehints\nfunction: merge_typehints\nfunction: insert_field_list\nfunction: modify_field_list\nfunction: setup\n\nsphinx/ext/autodoc/directive.py\nclass: AutodocDirective\nfunction: process_documenter_options\nfunction: parse_generated_content\n\nsphinx/ext/autodoc/__init__.py\nclass: Documenter\nclass: DataDocumenter\nclass: AttributeDocumenter\nclass: InstanceAttributeDocumenter\nclass: SlotsAttributeDocumenter\nfunction: get_documenters\nfunction: autodoc_attrgetter\nfunction: migrate_autodoc_member_order\nfunction: setup\n```"}], "related_loc_traj": {"response": "```\nsphinx/ext/autodoc/typehints.py\nfunction: record_typehints\nfunction: merge_typehints\nfunction: insert_field_list\nfunction: modify_field_list\nfunction: setup\n\nsphinx/ext/autodoc/directive.py\nclass: AutodocDirective\nfunction: process_documenter_options\nfunction: parse_generated_content\n\nsphinx/ext/autodoc/__init__.py\nclass: Documenter\nclass: DataDocumenter\nclass: AttributeDocumenter\nclass: InstanceAttributeDocumenter\nclass: SlotsAttributeDocumenter\nfunction: get_documenters\nfunction: autodoc_attrgetter\nfunction: migrate_autodoc_member_order\nfunction: setup\n```", "usage": {"completion_tokens": 142, "prompt_tokens": 4932}, "prompt": "\nPlease look through the following GitHub Problem Description, and the Skeleton of Relevant Files.\nIdentify all locations that need inspection or editing to fix the problem, including directly related areas as well as any potentially related global variables, functions, and classes.\nFor each location you provide, either give the name of the class, the name of a method in a class, the name of a function, or the name of a global variable.\n\n### GitHub Problem Description ###\nautodoc_type_aliases does not effect to variables and attributes\n**Describe the bug**\r\nautodoc_type_aliases does not effect to variables and attributes\r\n\r\n**To Reproduce**\r\n\r\n```\r\n# example.py\r\nfrom __future__ import annotations\r\n\r\n\r\n#: blah blah blah\r\nvar: String\r\n\r\n\r\nclass MyString:\r\n    \"mystring\"\r\n\r\n    #: blah blah blah\r\n    var: String\r\n```\r\n```\r\n# index.rst\r\n.. automodule:: example\r\n   :members:\r\n   :undoc-members:\r\n```\r\n```\r\n# conf.py\r\nautodoc_type_aliases = {\r\n    'String': 'example.MyString'\r\n}\r\n```\r\n\r\n**Expected behavior**\r\n`autodoc_type_aliases` should be applied to `example.var` and `example.MyString.var`.\r\n\r\n**Your project**\r\nN/A\r\n\r\n**Screenshots**\r\nN/A\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.9.0\r\n- Sphinx version: HEAD of 3.x branch\r\n- Sphinx extensions: sphinx.ext.autodoc\r\n- Extra tools: Nothing\r\n\r\n**Additional context**\r\nN/A\n\n\n###\n\n\n\n### Skeleton of Relevant Files ###\n\n### File: sphinx/ext/autodoc/typehints.py ###\n```python\n\n\ndef record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n                     options: Dict, args: str, retann: str) -> None:\n...\n\ndef merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n...\n\ndef insert_field_list(node: Element) -> nodes.field_list:\n...\n\ndef modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n...\n\ndef setup(app: Sphinx) -> Dict[str, Any]:\n\n```\n\n### File: sphinx/ext/autodoc/directive.py ###\n```python\n\n\nlogger = logging.getLogger(__name__)\n\n\n# common option names for autodoc directives\nAUTODOC_DEFAULT_OPTIONS = ['members', 'undoc-members', 'inherited-members',\n                           'show-inheritance', 'private-members', 'special-members',\n                           'ignore-module-all', 'exclude-members', 'member-order',\n                           'imported-members']\n\n\nclass DummyOptionSpec(dict):\n\n    def __bool__(self) -> bool:\n...\n    def __getitem__(self, key: str) -> Callable[[str], str]:\n...\n\nclass DocumenterBridge:\n\n    def __init__(self, env: BuildEnvironment, reporter: Reporter, options: Options,\n                 lineno: int, state: Any = None) -> None:\n...\n    def warn(self, msg: str) -> None:\n...\n\ndef process_documenter_options(documenter: \"Type[Documenter]\", config: Config, options: Dict\n                               ) -> Options:\n...\n\ndef parse_generated_content(state: RSTState, content: StringList, documenter: Documenter\n                            ) -> List[Node]:\n...\n\nclass AutodocDirective(SphinxDirective):\n    option_spec = DummyOptionSpec()\n    has_content = True\n    required_arguments = 1\n    optional_arguments = 0\n    final_argument_whitespace = True\n\n    def run(self) -> List[Node]:\n\n```\n\n### File: sphinx/ext/autodoc/__init__.py ###\n```python\n\n\nlogger = logging.getLogger(__name__)\n\n\n# This type isn't exposed directly in any modules, but can be found\n# here in most Python versions\nMethodDescriptorType = type(type.__subclasses__)\n\n\n#: extended signature RE: with explicit module name separated by ::\npy_ext_sig_re = re.compile(\n    r'''^ ([\\w.]+::)?            # explicit module name\n          ([\\w.]+\\.)?            # module and/or class name(s)\n          (\\w+)  \\s*             # thing name\n          (?: \\((.*)\\)           # optional: arguments\n           (?:\\s* -> \\s* (.*))?  #           return annotation\n          )? $                   # and nothing more\n          ''', re.VERBOSE)\nspecial_member_re = re.compile(r'^__\\S+__$')\n\n\ndef identity(x: Any) -> Any:\n...\n\nclass _All:\n\n    def __contains__(self, item: Any) -> bool:\n...\n\nclass _Empty:\n\n    def __contains__(self, item: Any) -> bool:\n...\n\nALL = _All()\nEMPTY = _Empty()\nUNINITIALIZED_ATTR = object()\nINSTANCEATTR = object()\nSLOTSATTR = object()\n\n\ndef members_option(arg: Any) -> Union[object, List[str]]:\n...\n\ndef members_set_option(arg: Any) -> Union[object, Set[str]]:\n...\n\ndef exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n...\n\ndef inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n...\n\ndef member_order_option(arg: Any) -> Optional[str]:\n...\n\nSUPPRESS = object()\n\n\ndef annotation_option(arg: Any) -> Any:\n...\n\ndef bool_option(arg: Any) -> bool:\n...\n\ndef merge_special_members_option(options: Dict) -> None:\n...\n\ndef merge_members_option(options: Dict) -> None:\n...\n\n# Some useful event listener factories for autodoc-process-docstring.\n\ndef cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n...\n\ndef between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n            exclude: bool = False) -> Callable:\n...\n\n# This class is used only in ``sphinx.ext.autodoc.directive``,\n# But we define this class here to keep compatibility (see #4538)\nclass Options(dict):\n    def __getattr__(self, name: str) -> Any:\n...\n\nclass ObjectMember(tuple):\n\n    def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:\n...\n    def __init__(self, name: str, obj: Any, skipped: bool = False) -> None:\n...\n\nObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n\n\nclass Documenter:\n    #: name by which the directive is called (auto...) and the default\n    #: generated directive name\n    objtype = 'object'\n    #: indentation by which to indent the directive content\n    content_indent = '   '\n    #: priority if multiple documenters return True from can_document_member\n    priority = 0\n    #: order if autodoc_member_order is set to 'groupwise'\n    member_order = 0\n    #: true if the generated content may contain titles\n    titles_allowed = False\n\n    option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n\n    def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n...\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n...\n    @property\n    def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n...\n    def add_line(self, line: str, source: str, *lineno: int) -> None:\n...\n    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n                     ) -> Tuple[str, List[str]]:\n...\n    def parse_name(self) -> bool:\n...\n    def import_object(self, raiseerror: bool = False) -> bool:\n...\n    def get_real_modname(self) -> str:\n...\n    def check_module(self) -> bool:\n...\n    def format_args(self, **kwargs: Any) -> str:\n...\n    def format_name(self) -> str:\n...\n    def _call_format_args(self, **kwargs: Any) -> str:\n...\n    def format_signature(self, **kwargs: Any) -> str:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n...\n    def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n...\n    def get_sourcename(self) -> str:\n...\n    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n...\n    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n...\n    def filter_members(self, members: ObjectMembers, want_all: bool\n                       ) -> List[Tuple[str, Any, bool]]:\n...\n    def document_members(self, all_members: bool = False) -> None:\n...\n    def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n                     order: str) -> List[Tuple[\"Documenter\", bool]]:\n...\n    def generate(self, more_content: Any = None, real_modname: str = None,\n                 check_module: bool = False, all_members: bool = False) -> None:\n...\n\nclass ModuleDocumenter(Documenter):\n    objtype = 'module'\n    content_indent = ''\n    titles_allowed = True\n\n    option_spec = {\n        'members': members_option, 'undoc-members': bool_option,\n        'noindex': bool_option, 'inherited-members': inherited_members_option,\n        'show-inheritance': bool_option, 'synopsis': identity,\n        'platform': identity, 'deprecated': bool_option,\n        'member-order': member_order_option, 'exclude-members': exclude_members_option,\n        'private-members': members_option, 'special-members': members_option,\n        'imported-members': bool_option, 'ignore-module-all': bool_option\n    }  # type: Dict[str, Callable]\n\n    def __init__(self, *args: Any) -> None:\n...\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n                     ) -> Tuple[str, List[str]]:\n...\n    def parse_name(self) -> bool:\n...\n    def import_object(self, raiseerror: bool = False) -> bool:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n...\n    def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n                     order: str) -> List[Tuple[\"Documenter\", bool]]:\n...\n\nclass ModuleLevelDocumenter(Documenter):\n    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n                     ) -> Tuple[str, List[str]]:\n...\n\nclass ClassLevelDocumenter(Documenter):\n    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n                     ) -> Tuple[str, List[str]]:\n...\n\nclass DocstringSignatureMixin:\n    _new_docstrings = None  # type: List[List[str]]\n    _signatures = None      # type: List[str]\n\n    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n...\n    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n...\n    def format_signature(self, **kwargs: Any) -> str:\n...\n\nclass DocstringStripSignatureMixin(DocstringSignatureMixin):\n    def format_signature(self, **kwargs: Any) -> str:\n...\n\nclass FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):\n    objtype = 'function'\n    member_order = 30\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def format_args(self, **kwargs: Any) -> str:\n...\n    def document_members(self, all_members: bool = False) -> None:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def format_signature(self, **kwargs: Any) -> str:\n...\n    def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n...\n\nclass SingledispatchFunctionDocumenter(FunctionDocumenter):\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n...\n\nclass DecoratorDocumenter(FunctionDocumenter):\n    objtype = 'decorator'\n\n    # must be lower than FunctionDocumenter\n    priority = -1\n\n    def format_args(self, **kwargs: Any) -> Any:\n...\n\n# Types which have confusing metaclass signatures it would be best not to show.\n# These are listed by name, rather than storing the objects themselves, to avoid\n# needing to import the modules.\n_METACLASS_CALL_BLACKLIST = [\n    'enum.EnumMeta.__call__',\n]\n\n\n# Types whose __new__ signature is a pass-thru.\n_CLASS_NEW_BLACKLIST = [\n    'typing.Generic.__new__',\n]\n\n\nclass ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):\n    objtype = 'class'\n    member_order = 20\n    option_spec = {\n        'members': members_option, 'undoc-members': bool_option,\n        'noindex': bool_option, 'inherited-members': inherited_members_option,\n        'show-inheritance': bool_option, 'member-order': member_order_option,\n        'exclude-members': exclude_members_option,\n        'private-members': members_option, 'special-members': members_option,\n    }  # type: Dict[str, Callable]\n\n    _signature_class = None  # type: Any\n    _signature_method_name = None  # type: str\n\n    def __init__(self, *args: Any) -> None:\n...\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def import_object(self, raiseerror: bool = False) -> bool:\n...\n    def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n...\n    def format_args(self, **kwargs: Any) -> str:\n...\n    def format_signature(self, **kwargs: Any) -> str:\n...\n    def get_overloaded_signatures(self) -> List[Signature]:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n...\n    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n...\n    def document_members(self, all_members: bool = False) -> None:\n...\n    def generate(self, more_content: Any = None, real_modname: str = None,\n                 check_module: bool = False, all_members: bool = False) -> None:\n...\n\nclass ExceptionDocumenter(ClassDocumenter):\n    objtype = 'exception'\n    member_order = 10\n\n    # needs a higher priority than ClassDocumenter\n    priority = 10\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n\nclass DataDocumenter(ModuleLevelDocumenter):\n    objtype = 'data'\n    member_order = 40\n    priority = -10\n    option_spec = dict(ModuleLevelDocumenter.option_spec)\n    option_spec[\"annotation\"] = annotation_option\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def document_members(self, all_members: bool = False) -> None:\n...\n    def get_real_modname(self) -> str:\n...\n\nclass DataDeclarationDocumenter(DataDocumenter):\n    objtype = 'datadecl'\n    directivetype = 'data'\n    member_order = 60\n\n    # must be higher than AttributeDocumenter\n    priority = 11\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def import_object(self, raiseerror: bool = False) -> bool:\n...\n    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n...\n\nclass GenericAliasDocumenter(DataDocumenter):\n\n    objtype = 'genericalias'\n    directivetype = 'data'\n    priority = DataDocumenter.priority + 1\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n...\n\nclass TypeVarDocumenter(DataDocumenter):\n\n    objtype = 'typevar'\n    directivetype = 'data'\n    priority = DataDocumenter.priority + 1\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n...\n    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n...\n\nclass MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):\n    objtype = 'method'\n    directivetype = 'method'\n    member_order = 50\n    priority = 1  # must be more than FunctionDocumenter\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def import_object(self, raiseerror: bool = False) -> bool:\n...\n    def format_args(self, **kwargs: Any) -> str:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def document_members(self, all_members: bool = False) -> None:\n...\n    def format_signature(self, **kwargs: Any) -> str:\n...\n    def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n...\n\nclass SingledispatchMethodDocumenter(MethodDocumenter):\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n...\n\nclass AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):\n    objtype = 'attribute'\n    member_order = 60\n    option_spec = dict(ModuleLevelDocumenter.option_spec)\n    option_spec[\"annotation\"] = annotation_option\n\n    # must be higher than the MethodDocumenter, else it will recognize\n    # some non-data descriptors as methods\n    priority = 10\n\n    @staticmethod\n    def is_function_or_method(obj: Any) -> bool:\n...\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def document_members(self, all_members: bool = False) -> None:\n...\n    def isinstanceattribute(self) -> bool:\n...\n    def import_object(self, raiseerror: bool = False) -> bool:\n...\n    def get_real_modname(self) -> str:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n...\n    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n...\n\nclass PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):\n    objtype = 'property'\n    directivetype = 'method'\n    member_order = 60\n\n    # before AttributeDocumenter\n    priority = AttributeDocumenter.priority + 1\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def document_members(self, all_members: bool = False) -> None:\n...\n    def get_real_modname(self) -> str:\n...\n    def add_directive_header(self, sig: str) -> None:\n...\n\nclass InstanceAttributeDocumenter(AttributeDocumenter):\n    objtype = 'instanceattribute'\n    directivetype = 'attribute'\n    member_order = 60\n\n    # must be higher than AttributeDocumenter\n    priority = 11\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def import_parent(self) -> Any:\n...\n    def import_object(self, raiseerror: bool = False) -> bool:\n...\n    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n...\n\nclass SlotsAttributeDocumenter(AttributeDocumenter):\n    objtype = 'slotsattribute'\n    directivetype = 'attribute'\n    member_order = 60\n\n    # must be higher than AttributeDocumenter\n    priority = 11\n\n    @classmethod\n    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n                            ) -> bool:\n...\n    def import_object(self, raiseerror: bool = False) -> bool:\n...\n    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n...\n\ndef get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n...\n\ndef autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n...\n\ndef migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n...\n\ndef setup(app: Sphinx) -> Dict[str, Any]:\n\n```\n\n\n###\n\nPlease provide the complete set of locations as either a class name, a function name, or a variable name.\nNote that if you include a class, you do not need to list its specific methods.\nYou can include either the entire class or don't include the class name and instead include specific methods in the class.\n### Examples:\n```\nfull_path1/file1.py\nfunction: my_function_1\nclass: MyClass1\nfunction: MyClass2.my_method\n\nfull_path2/file2.py\nvariable: my_var\nfunction: MyClass3.my_method\n\nfull_path3/file3.py\nfunction: my_function_2\nfunction: my_function_3\nfunction: MyClass4.my_method_1\nclass: MyClass5\n```\n\nReturn just the locations.\n"}, "found_edit_locs": ["function: record_typehints\nline: 23\nfunction: record_typehints\nline: 23\nfunction: merge_typehints\nline: 40", "line: 78\nfunction: AutodocDirective.run\nline: 121\nfunction: process_documenter_options\nline: 78", "class: DataDocumenter\nfunction: DataDocumenter.add_directive_header\nline: 1699\nclass: AttributeDocumenter\nfunction: AttributeDocumenter.add_directive_header\nline: 2090\nclass: AttributeDocumenter\nline: 2016\nclass: DataDocumenter\nline: 1684"], "additional_artifact_loc_edit_location": [{"raw_output_loc": ["```\nsphinx/ext/autodoc/typehints.py\nfunction: record_typehints\nline: 23\n\nsphinx/ext/autodoc/directive.py\nline: 78\n\nsphinx/ext/autodoc/directive.py\nfunction: AutodocDirective.run\nline: 121\n\nsphinx/ext/autodoc/__init__.py\nclass: DataDocumenter\nfunction: DataDocumenter.add_directive_header\nline: 1699\n\nsphinx/ext/autodoc/__init__.py\nclass: AttributeDocumenter\nfunction: AttributeDocumenter.add_directive_header\nline: 2090\n```", "```\nsphinx/ext/autodoc/typehints.py\nfunction: record_typehints\nline: 23\n\nsphinx/ext/autodoc/typehints.py\nfunction: merge_typehints\nline: 40\n\nsphinx/ext/autodoc/directive.py\nfunction: process_documenter_options\nline: 78\n\nsphinx/ext/autodoc/__init__.py\nclass: AttributeDocumenter\nline: 2016\n\nsphinx/ext/autodoc/__init__.py\nclass: DataDocumenter\nline: 1684\n```", "```\nsphinx/ext/autodoc/typehints.py\nfunction: modify_field_list\nline: 99\nline: 103\nline: 104\n\nsphinx/ext/autodoc/directive.py\nfunction: process_documenter_options\nline: 89\n\nsphinx/ext/autodoc/__init__.py\nclass: AttributeDocumenter\nfunction: add_directive_header\nline: 2091\nline: 2111\nline: 2115\n\nclass: DataDocumenter\nfunction: add_directive_header\nline: 1699\nline: 1718\nline: 1724\n```", "```\nsphinx/ext/autodoc/typehints.py\nfunction: merge_typehints\nline: 40\nline: 66\n\nsphinx/ext/autodoc/directive.py\nfunction: AutodocDirective.run\nline: 121\nline: 137\n```"]}], "edit_loc_traj": {"prompt": "\nPlease review the following GitHub problem description, and relevant files, and provide a set of locations that need to be edited to fix the issue.\nThe locations can be specified as class names, function or method names, or exact line numbers that require modification.\n\n### GitHub Problem Description ###\nautodoc_type_aliases does not effect to variables and attributes\n**Describe the bug**\r\nautodoc_type_aliases does not effect to variables and attributes\r\n\r\n**To Reproduce**\r\n\r\n```\r\n# example.py\r\nfrom __future__ import annotations\r\n\r\n\r\n#: blah blah blah\r\nvar: String\r\n\r\n\r\nclass MyString:\r\n    \"mystring\"\r\n\r\n    #: blah blah blah\r\n    var: String\r\n```\r\n```\r\n# index.rst\r\n.. automodule:: example\r\n   :members:\r\n   :undoc-members:\r\n```\r\n```\r\n# conf.py\r\nautodoc_type_aliases = {\r\n    'String': 'example.MyString'\r\n}\r\n```\r\n\r\n**Expected behavior**\r\n`autodoc_type_aliases` should be applied to `example.var` and `example.MyString.var`.\r\n\r\n**Your project**\r\nN/A\r\n\r\n**Screenshots**\r\nN/A\r\n\r\n**Environment info**\r\n- OS: Mac\r\n- Python version: 3.9.0\r\n- Sphinx version: HEAD of 3.x branch\r\n- Sphinx extensions: sphinx.ext.autodoc\r\n- Extra tools: Nothing\r\n\r\n**Additional context**\r\nN/A\n\n\n###\n\n\n\n### sphinx/ext/autodoc/typehints.py\n...\n13|from typing import Any, Dict, Iterable, cast\n14|\n15|from docutils import nodes\n16|from docutils.nodes import Element\n17|\n18|from sphinx import addnodes\n19|from sphinx.application import Sphinx\n20|from sphinx.util import inspect, typing\n21|\n22|\n23|def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n24|                     options: Dict, args: str, retann: str) -> None:\n25|    \"\"\"Record type hints to env object.\"\"\"\n26|    try:\n27|        if callable(obj):\n28|            annotations = app.env.temp_data.setdefault('annotations', {})\n29|            annotation = annotations.setdefault(name, OrderedDict())\n30|            sig = inspect.signature(obj)\n31|            for param in sig.parameters.values():\n32|                if param.annotation is not param.empty:\n33|                    annotation[param.name] = typing.stringify(param.annotation)\n34|            if sig.return_annotation is not sig.empty:\n35|                annotation['return'] = typing.stringify(sig.return_annotation)\n36|    except (TypeError, ValueError):\n37|        pass\n38|\n39|\n40|def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n41|    if domain != 'py':\n42|        return\n43|    if app.config.autodoc_typehints != 'description':\n44|        return\n45|    if objtype == 'class' and app.config.autoclass_content not in ('init', 'both'):\n46|        return\n47|\n48|    try:\n49|        signature = cast(addnodes.desc_signature, contentnode.parent[0])\n50|        if signature['module']:\n51|            fullname = '.'.join([signature['module'], signature['fullname']])\n52|        else:\n53|            fullname = signature['fullname']\n54|    except KeyError:\n55|        # signature node does not have valid context info for the target object\n56|        return\n57|\n58|    annotations = app.env.temp_data.get('annotations', {})\n59|    if annotations.get(fullname, {}):\n60|        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n61|        if field_lists == []:\n62|            field_list = insert_field_list(contentnode)\n63|            field_lists.append(field_list)\n64|\n65|        for field_list in field_lists:\n66|            modify_field_list(field_list, annotations[fullname])\n67|\n68|\n69|def insert_field_list(node: Element) -> nodes.field_list:\n70|    field_list = nodes.field_list()\n71|    desc = [n for n in node if isinstance(n, addnodes.desc)]\n72|    if desc:\n73|        # insert just before sub object descriptions (ex. methods, nested classes, etc.)\n74|        index = node.index(desc[0])\n75|        node.insert(index - 1, [field_list])\n76|    else:\n77|        node += field_list\n78|\n79|    return field_list\n80|\n81|\n82|def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n83|    arguments = {}  # type: Dict[str, Dict[str, bool]]\n84|    fields = cast(Iterable[nodes.field], node)\n85|    for field in fields:\n86|        field_name = field[0].astext()\n87|        parts = re.split(' +', field_name)\n88|        if parts[0] == 'param':\n89|            if len(parts) == 2:\n90|                # :param xxx:\n91|                arg = arguments.setdefault(parts[1], {})\n92|                arg['param'] = True\n93|            elif len(parts) > 2:\n94|                # :param xxx yyy:\n95|                name = ' '.join(parts[2:])\n96|                arg = arguments.setdefault(name, {})\n97|                arg['param'] = True\n98|                arg['type'] = True\n99|        elif parts[0] == 'type':\n100|            name = ' '.join(parts[1:])\n101|            arg = arguments.setdefault(name, {})\n102|            arg['type'] = True\n103|        elif parts[0] == 'rtype':\n104|            arguments['return'] = {'type': True}\n105|\n106|    for name, annotation in annotations.items():\n107|        if name == 'return':\n108|            continue\n109|\n110|        arg = arguments.get(name, {})\n111|        if not arg.get('type'):\n112|            field = nodes.field()\n113|            field += nodes.field_name('', 'type ' + name)\n114|            field += nodes.field_body('', nodes.paragraph('', annotation))\n115|            node += field\n116|        if not arg.get('param'):\n117|            field = nodes.field()\n118|            field += nodes.field_name('', 'param ' + name)\n119|            field += nodes.field_body('', nodes.paragraph('', ''))\n120|            node += field\n121|\n122|    if 'return' in annotations and 'return' not in arguments:\n123|        field = nodes.field()\n124|        field += nodes.field_name('', 'rtype')\n125|        field += nodes.field_body('', nodes.paragraph('', annotation))\n126|        node += field\n127|\n128|\n129|def setup(app: Sphinx) -> Dict[str, Any]:\n130|    app.connect('autodoc-process-signature', record_typehints)\n131|    app.connect('object-description-transform', merge_typehints)\n132|\n133|    return {\n134|        'version': 'builtin',\n135|        'parallel_read_safe': True,\n136|        'parallel_write_safe': True,\n137|    }\n\n\n### sphinx/ext/autodoc/directive.py\n...\n68|            warnings.warn('DocumenterBridge requires a state object on instantiation.',\n69|                          RemovedInSphinx40Warning, stacklevel=2)\n70|            settings = Struct(tab_width=8)\n71|            document = Struct(settings=settings)\n72|            self.state = Struct(document=document)\n73|\n74|    def warn(self, msg: str) -> None:\n75|        logger.warning(msg, location=(self.env.docname, self.lineno))\n76|\n77|\n78|def process_documenter_options(documenter: \"Type[Documenter]\", config: Config, options: Dict\n79|                               ) -> Options:\n80|    \"\"\"Recognize options of Documenter from user input.\"\"\"\n81|    for name in AUTODOC_DEFAULT_OPTIONS:\n82|        if name not in documenter.option_spec:\n83|            continue\n84|        else:\n85|            negated = options.pop('no-' + name, True) is None\n86|            if name in config.autodoc_default_options and not negated:\n87|                options[name] = config.autodoc_default_options[name]\n88|\n89|    return Options(assemble_option_dict(options.items(), documenter.option_spec))\n90|\n91|\n92|def parse_generated_content(state: RSTState, content: StringList, documenter: Documenter\n93|                            ) -> List[Node]:\n94|    \"\"\"Parse a generated content by Documenter.\"\"\"\n95|    with switch_source_input(state, content):\n96|        if documenter.titles_allowed:\n97|            node = nodes.section()  # type: Element\n98|            # necessary so that the child nodes get the right source/line set\n99|            node.document = state.document\n100|            nested_parse_with_titles(state, content, node)\n101|        else:\n102|            node = nodes.paragraph()\n103|            node.document = state.document\n104|            state.nested_parse(content, 0, node)\n105|\n106|        return node.children\n107|\n108|\n109|class AutodocDirective(SphinxDirective):\n110|    \"\"\"A directive class for all autodoc directives. It works as a dispatcher of Documenters.\n111|\n112|    It invokes a Documenter on running. After the processing, it parses and returns\n113|    the generated content by Documenter.\n114|    \"\"\"\n115|    option_spec = DummyOptionSpec()\n116|    has_content = True\n117|    required_arguments = 1\n118|    optional_arguments = 0\n119|    final_argument_whitespace = True\n120|\n121|    def run(self) -> List[Node]:\n122|        reporter = self.state.document.reporter\n123|\n124|        try:\n125|            source, lineno = reporter.get_source_and_line(self.lineno)  # type: ignore\n126|        except AttributeError:\n127|            source, lineno = (None, None)\n128|        logger.debug('[autodoc] %s:%s: input:\\n%s', source, lineno, self.block_text)\n129|\n130|        # look up target Documenter\n131|        objtype = self.name[4:]  # strip prefix (auto-).\n132|        doccls = self.env.app.registry.documenters[objtype]\n133|\n134|        # process the options with the selected documenter's option_spec\n135|        try:\n136|            documenter_options = process_documenter_options(doccls, self.config, self.options)\n137|        except (KeyError, ValueError, TypeError) as exc:\n138|            # an option is either unknown or has a wrong type\n139|            logger.error('An option to %s is either unknown or has an invalid value: %s' %\n140|                         (self.name, exc), location=(self.env.docname, lineno))\n141|            return []\n142|\n143|        # generate the output\n144|        params = DocumenterBridge(self.env, reporter, documenter_options, lineno, self.state)\n145|        documenter = doccls(params, self.arguments[0])\n146|        documenter.generate(more_content=self.content)\n147|        if not params.result:\n148|            return []\n149|\n150|        logger.debug('[autodoc] output:\\n%s', '\\n'.join(params.result))\n151|\n152|        # record all filenames as dependencies -- this will at least\n153|        # partially make automatic invalidation possible\n154|        for fn in params.filename_set:\n155|            self.state.document.settings.record_dependencies.add(fn)\n156|\n157|        result = parse_generated_content(self.state, params.result, documenter)\n158|        return result\n\n\n### sphinx/ext/autodoc/__init__.py\n...\n275|\n276|    def __init__(self, name: str, obj: Any, skipped: bool = False) -> None:\n277|        self.__name__ = name\n278|        self.object = obj\n279|        self.skipped = skipped\n280|\n281|\n282|ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n283|\n284|\n285|class Documenter:\n286|    \"\"\"\n287|    A Documenter knows how to autodocument a single object type.  When\n288|    registered with the AutoDirective, it will be used to document objects\n289|    of that type when needed by autodoc.\n290|\n291|    Its *objtype* attribute selects what auto directive it is assigned to\n292|    (the directive name is 'auto' + objtype), and what directive it generates\n293|    by default, though that can be overridden by an attribute called\n294|    *directivetype*.\n295|\n296|    A Documenter has an *option_spec* that works like a docutils directive's;\n297|    in fact, it will be used to parse an auto directive's options that matches\n298|    the documenter.\n299|    \"\"\"\n300|    #: name by which the directive is called (auto...) and the default\n301|    #: generated directive name\n302|    objtype = 'object'\n303|    #: indentation by which to indent the directive content\n304|    content_indent = '   '\n305|    #: priority if multiple documenters return True from can_document_member\n306|    priority = 0\n307|    #: order if autodoc_member_order is set to 'groupwise'\n308|    member_order = 0\n309|    #: true if the generated content may contain titles\n310|    titles_allowed = False\n311|\n312|    option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n313|\n314|    def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n315|        \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n316|        return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n317|\n318|    @classmethod\n319|    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n320|                            ) -> bool:\n321|        \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n322|        raise NotImplementedError('must be implemented in subclasses')\n323|\n324|    def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n325|        self.directive = directive\n326|        self.config = directive.env.config\n327|        self.env = directive.env    # type: BuildEnvironment\n328|        self.options = directive.genopt\n329|        self.name = name\n330|        self.indent = indent\n331|        # the module and object path within the module, and the fully\n332|        # qualified name (all set after resolve_name succeeds)\n333|        self.modname = None         # type: str\n334|        self.module = None          # type: ModuleType\n335|        self.objpath = None         # type: List[str]\n336|        self.fullname = None        # type: str\n337|        # extra signature items (arguments and return annotation,\n338|        # also set after resolve_name succeeds)\n339|        self.args = None            # type: str\n340|        self.retann = None          # type: str\n341|        # the object to document (set after import_object succeeds)\n342|        self.object = None          # type: Any\n343|        self.object_name = None     # type: str\n344|        # the parent/owner of the object to document\n345|        self.parent = None          # type: Any\n346|        # the module analyzer to get at attribute docs, or None\n347|        self.analyzer = None        # type: ModuleAnalyzer\n348|\n349|    @property\n350|    def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n351|        \"\"\"Returns registered Documenter classes\"\"\"\n352|        return self.env.app.registry.documenters\n353|\n354|    def add_line(self, line: str, source: str, *lineno: int) -> None:\n355|        \"\"\"Append one line of generated reST to the output.\"\"\"\n356|        if line.strip():  # not a blank line\n357|            self.directive.result.append(self.indent + line, source, *lineno)\n358|        else:\n359|            self.directive.result.append('', source, *lineno)\n360|\n361|    def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n362|                     ) -> Tuple[str, List[str]]:\n363|        \"\"\"Resolve the module and name of the object to document given by the\n364|        arguments and the current module/class.\n365|\n366|        Must return a pair of the module name and a chain of attributes; for\n367|        example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n368|        ``zipfile.ZipFile.open`` method.\n369|        \"\"\"\n370|        raise NotImplementedError('must be implemented in subclasses')\n371|\n372|    def parse_name(self) -> bool:\n373|        \"\"\"Determine what module to import and what attribute to document.\n374|\n375|        Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n376|        *self.args* and *self.retann* if parsing and resolving was successful.\n377|        \"\"\"\n378|        # first, parse the definition -- auto directives for classes and\n379|        # functions can contain a signature which is then used instead of\n380|        # an autogenerated one\n381|        try:\n382|            explicit_modname, path, base, args, retann = \\\n383|                py_ext_sig_re.match(self.name).groups()\n384|        except AttributeError:\n385|            logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n386|                           type='autodoc')\n387|            return False\n388|\n389|        # support explicit module and class name separation via ::\n390|        if explicit_modname is not None:\n391|            modname = explicit_modname[:-2]\n392|            parents = path.rstrip('.').split('.') if path else []\n393|        else:\n394|            modname = None\n395|            parents = []\n396|\n397|        with mock(self.config.autodoc_mock_imports):\n398|            self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n399|\n400|        if not self.modname:\n401|            return False\n402|\n403|        self.args = args\n404|        self.retann = retann\n405|        self.fullname = (self.modname or '') + \\\n406|                        ('.' + '.'.join(self.objpath) if self.objpath else '')\n407|        return True\n408|\n409|    def import_object(self, raiseerror: bool = False) -> bool:\n410|        \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n411|        it as *self.object*.\n412|\n413|        Returns True if successful, False if an error occurred.\n414|        \"\"\"\n415|        with mock(self.config.autodoc_mock_imports):\n416|            try:\n417|                ret = import_object(self.modname, self.objpath, self.objtype,\n418|                                    attrgetter=self.get_attr,\n419|                                    warningiserror=self.config.autodoc_warningiserror)\n420|                self.module, self.parent, self.object_name, self.object = ret\n421|                return True\n422|            except ImportError as exc:\n423|                if raiseerror:\n424|                    raise\n425|                else:\n426|                    logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n427|                    self.env.note_reread()\n428|                    return False\n429|\n430|    def get_real_modname(self) -> str:\n431|        \"\"\"Get the real module name of an object to document.\n432|\n433|        It can differ from the name of the module through which the object was\n434|        imported.\n435|        \"\"\"\n436|        return self.get_attr(self.object, '__module__', None) or self.modname\n437|\n438|    def check_module(self) -> bool:\n439|        \"\"\"Check if *self.object* is really defined in the module given by\n440|        *self.modname*.\n441|        \"\"\"\n442|        if self.options.imported_members:\n443|            return True\n444|\n445|        subject = inspect.unpartial(self.object)\n446|        modname = self.get_attr(subject, '__module__', None)\n447|        if modname and modname != self.modname:\n448|            return False\n449|        return True\n450|\n451|    def format_args(self, **kwargs: Any) -> str:\n452|        \"\"\"Format the argument signature of *self.object*.\n453|\n454|        Should return None if the object does not have a signature.\n455|        \"\"\"\n456|        return None\n457|\n458|    def format_name(self) -> str:\n459|        \"\"\"Format the name of *self.object*.\n460|\n461|        This normally should be something that can be parsed by the generated\n462|        directive, but doesn't need to be (Sphinx will display it unparsed\n463|        then).\n464|        \"\"\"\n465|        # normally the name doesn't contain the module (except for module\n466|        # directives of course)\n467|        return '.'.join(self.objpath) or self.modname\n468|\n469|    def _call_format_args(self, **kwargs: Any) -> str:\n470|        if kwargs:\n471|            try:\n472|                return self.format_args(**kwargs)\n473|            except TypeError:\n474|                # avoid chaining exceptions, by putting nothing here\n475|                pass\n476|\n477|        # retry without arguments for old documenters\n478|        return self.format_args()\n479|\n480|    def format_signature(self, **kwargs: Any) -> str:\n481|        \"\"\"Format the signature (arguments and return annotation) of the object.\n482|\n483|        Let the user process it via the ``autodoc-process-signature`` event.\n484|        \"\"\"\n485|        if self.args is not None:\n486|            # signature given explicitly\n487|            args = \"(%s)\" % self.args\n488|            retann = self.retann\n489|        else:\n490|            # try to introspect the signature\n491|            try:\n492|                retann = None\n493|                args = self._call_format_args(**kwargs)\n494|                if args:\n495|                    matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n496|                    if matched:\n497|                        args = matched.group(1)\n498|                        retann = matched.group(2)\n499|            except Exception as exc:\n500|                logger.warning(__('error while formatting arguments for %s: %s'),\n501|                               self.fullname, exc, type='autodoc')\n502|                args = None\n503|\n504|        result = self.env.events.emit_firstresult('autodoc-process-signature',\n505|                                                  self.objtype, self.fullname,\n506|                                                  self.object, self.options, args, retann)\n507|        if result:\n508|            args, retann = result\n509|\n510|        if args is not None:\n511|            return args + ((' -> %s' % retann) if retann else '')\n512|        else:\n513|            return ''\n514|\n515|    def add_directive_header(self, sig: str) -> None:\n516|        \"\"\"Add the directive header and options to the generated content.\"\"\"\n517|        domain = getattr(self, 'domain', 'py')\n518|        directive = getattr(self, 'directivetype', self.objtype)\n519|        name = self.format_name()\n520|        sourcename = self.get_sourcename()\n521|\n522|        # one signature per line, indented by column\n523|        prefix = '.. %s:%s:: ' % (domain, directive)\n524|        for i, sig_line in enumerate(sig.split(\"\\n\")):\n525|            self.add_line('%s%s%s' % (prefix, name, sig_line),\n526|                          sourcename)\n527|            if i == 0:\n528|                prefix = \" \" * len(prefix)\n529|\n530|        if self.options.noindex:\n531|            self.add_line('   :noindex:', sourcename)\n532|        if self.objpath:\n533|            # Be explicit about the module, this is necessary since .. class::\n534|            # etc. don't support a prepended module name\n535|            self.add_line('   :module: %s' % self.modname, sourcename)\n536|\n537|    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n538|        \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n539|        if encoding is not None:\n540|            warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n541|                          % self.__class__.__name__,\n542|                          RemovedInSphinx40Warning, stacklevel=2)\n543|        if ignore is not None:\n544|            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n545|                          % self.__class__.__name__,\n546|                          RemovedInSphinx50Warning, stacklevel=2)\n547|        docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n548|                           self.parent, self.object_name)\n549|        if docstring:\n550|            tab_width = self.directive.state.document.settings.tab_width\n551|            return [prepare_docstring(docstring, ignore, tab_width)]\n552|        return []\n553|\n554|    def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n555|        \"\"\"Let the user process the docstrings before adding them.\"\"\"\n556|        for docstringlines in docstrings:\n557|            if self.env.app:\n558|                # let extensions preprocess docstrings\n559|                self.env.app.emit('autodoc-process-docstring',\n560|                                  self.objtype, self.fullname, self.object,\n561|                                  self.options, docstringlines)\n562|\n563|                if docstringlines and docstringlines[-1] != '':\n564|                    # append a blank line to the end of the docstring\n565|                    docstringlines.append('')\n566|\n567|            yield from docstringlines\n568|\n569|    def get_sourcename(self) -> str:\n570|        if (getattr(self.object, '__module__', None) and\n571|                getattr(self.object, '__qualname__', None)):\n572|            # Get the correct location of docstring from self.object\n573|            # to support inherited methods\n574|            fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)\n575|        else:\n576|            fullname = self.fullname\n577|\n578|        if self.analyzer:\n579|            return '%s:docstring of %s' % (self.analyzer.srcname, fullname)\n580|        else:\n581|            return 'docstring of %s' % fullname\n582|\n583|    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n584|        \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n585|        # set sourcename and add content from attribute documentation\n586|        sourcename = self.get_sourcename()\n587|        if self.analyzer:\n588|            attr_docs = self.analyzer.find_attr_docs()\n589|            if self.objpath:\n590|                key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n591|                if key in attr_docs:\n592|                    no_docstring = True\n593|                    # make a copy of docstring for attributes to avoid cache\n594|                    # the change of autodoc-process-docstring event.\n595|                    docstrings = [list(attr_docs[key])]\n596|\n597|                    for i, line in enumerate(self.process_doc(docstrings)):\n598|                        self.add_line(line, sourcename, i)\n599|\n600|        # add content from docstrings\n601|        if not no_docstring:\n602|            docstrings = self.get_doc()\n603|            if not docstrings:\n604|                # append at least a dummy docstring, so that the event\n605|                # autodoc-process-docstring is fired and can add some\n606|                # content if desired\n607|                docstrings.append([])\n608|            for i, line in enumerate(self.process_doc(docstrings)):\n609|                self.add_line(line, sourcename, i)\n610|\n611|        # add additional content (e.g. from document), if present\n612|        if more_content:\n613|            for line, src in zip(more_content.data, more_content.items):\n614|                self.add_line(line, src[0], src[1])\n615|\n616|    def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n617|        \"\"\"Return `(members_check_module, members)` where `members` is a\n618|        list of `(membername, member)` pairs of the members of *self.object*.\n619|\n620|        If *want_all* is True, return all members.  Else, only return those\n621|        members given by *self.options.members* (which may also be none).\n622|        \"\"\"\n623|        members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n624|        if not want_all:\n625|            if not self.options.members:\n626|                return False, []  # type: ignore\n627|            # specific members given\n628|            selected = []\n629|            for name in self.options.members:  # type: str\n630|                if name in members:\n631|                    selected.append((name, members[name].value))\n632|                else:\n633|                    logger.warning(__('missing attribute %s in object %s') %\n634|                                   (name, self.fullname), type='autodoc')\n635|            return False, selected\n636|        elif self.options.inherited_members:\n637|            return False, [(m.name, m.value) for m in members.values()]\n638|        else:\n639|            return False, [(m.name, m.value) for m in members.values()\n640|                           if m.directly_defined]\n641|\n642|    def filter_members(self, members: ObjectMembers, want_all: bool\n643|                       ) -> List[Tuple[str, Any, bool]]:\n644|        \"\"\"Filter the given member list.\n645|\n646|        Members are skipped if\n647|\n648|        - they are private (except if given explicitly or the private-members\n649|          option is set)\n650|        - they are special methods (except if given explicitly or the\n651|          special-members option is set)\n652|        - they are undocumented (except if the undoc-members option is set)\n653|\n654|        The user can override the skipping decision by connecting to the\n655|        ``autodoc-skip-member`` event.\n656|        \"\"\"\n657|        def is_filtered_inherited_member(name: str) -> bool:\n658|            if inspect.isclass(self.object):\n659|                for cls in self.object.__mro__:\n660|                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n661|                        # given member is a member of specified *super class*\n662|                        return True\n663|                    elif name in cls.__dict__:\n664|                        return False\n665|                    elif name in self.get_attr(cls, '__annotations__', {}):\n666|                        return False\n667|\n668|            return False\n669|\n670|        ret = []\n671|\n672|        # search for members in source code too\n673|        namespace = '.'.join(self.objpath)  # will be empty for modules\n674|\n675|        if self.analyzer:\n676|            attr_docs = self.analyzer.find_attr_docs()\n677|        else:\n678|            attr_docs = {}\n679|\n680|        # process members and determine which to skip\n681|        for obj in members:\n682|            membername, member = obj\n683|            # if isattr is True, the member is documented as an attribute\n684|            if member is INSTANCEATTR:\n685|                isattr = True\n686|            else:\n687|                isattr = False\n688|\n689|            doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n690|                         self.parent, self.object_name)\n691|            if not isinstance(doc, str):\n692|                # Ignore non-string __doc__\n693|                doc = None\n694|\n695|            # if the member __doc__ is the same as self's __doc__, it's just\n696|            # inherited and therefore not the member's doc\n697|            cls = self.get_attr(member, '__class__', None)\n698|            if cls:\n699|                cls_doc = self.get_attr(cls, '__doc__', None)\n700|                if cls_doc == doc:\n701|                    doc = None\n702|            has_doc = bool(doc)\n703|\n704|            metadata = extract_metadata(doc)\n705|            if 'private' in metadata:\n706|                # consider a member private if docstring has \"private\" metadata\n707|                isprivate = True\n708|            elif 'public' in metadata:\n709|                # consider a member public if docstring has \"public\" metadata\n710|                isprivate = False\n711|            else:\n712|                isprivate = membername.startswith('_')\n713|\n714|            keep = False\n715|            if safe_getattr(member, '__sphinx_mock__', False):\n716|                # mocked module or object\n717|                pass\n718|            elif self.options.exclude_members and membername in self.options.exclude_members:\n719|                # remove members given by exclude-members\n720|                keep = False\n721|            elif want_all and special_member_re.match(membername):\n722|                # special __methods__\n723|                if self.options.special_members and membername in self.options.special_members:\n724|                    if membername == '__doc__':\n725|                        keep = False\n726|                    elif is_filtered_inherited_member(membername):\n727|                        keep = False\n728|                    else:\n729|                        keep = has_doc or self.options.undoc_members\n730|                else:\n731|                    keep = False\n732|            elif (namespace, membername) in attr_docs:\n733|                if want_all and isprivate:\n734|                    if self.options.private_members is None:\n735|                        keep = False\n736|                    else:\n737|                        keep = membername in self.options.private_members\n738|                else:\n739|                    # keep documented attributes\n740|                    keep = True\n741|                isattr = True\n742|            elif want_all and isprivate:\n743|                if has_doc or self.options.undoc_members:\n744|                    if self.options.private_members is None:\n745|                        keep = False\n746|                    elif is_filtered_inherited_member(membername):\n747|                        keep = False\n748|                    else:\n749|                        keep = membername in self.options.private_members\n750|                else:\n751|                    keep = False\n752|            else:\n753|                if self.options.members is ALL and is_filtered_inherited_member(membername):\n754|                    keep = False\n755|                else:\n756|                    # ignore undocumented members if :undoc-members: is not given\n757|                    keep = has_doc or self.options.undoc_members\n758|\n759|            if isinstance(obj, ObjectMember) and obj.skipped:\n760|                # forcedly skipped member (ex. a module attribute not defined in __all__)\n761|                keep = False\n762|\n763|            # give the user a chance to decide whether this member\n764|            # should be skipped\n765|            if self.env.app:\n766|                # let extensions preprocess docstrings\n767|                try:\n768|                    skip_user = self.env.app.emit_firstresult(\n769|                        'autodoc-skip-member', self.objtype, membername, member,\n770|                        not keep, self.options)\n771|                    if skip_user is not None:\n772|                        keep = not skip_user\n773|                except Exception as exc:\n774|                    logger.warning(__('autodoc: failed to determine %r to be documented, '\n775|                                      'the following exception was raised:\\n%s'),\n776|                                   member, exc, type='autodoc')\n777|                    keep = False\n778|\n779|            if keep:\n780|                ret.append((membername, member, isattr))\n781|\n782|        return ret\n783|\n784|    def document_members(self, all_members: bool = False) -> None:\n785|        \"\"\"Generate reST for member documentation.\n786|\n787|        If *all_members* is True, do all members, else those given by\n788|        *self.options.members*.\n789|        \"\"\"\n790|        # set current namespace for finding members\n791|        self.env.temp_data['autodoc:module'] = self.modname\n792|        if self.objpath:\n793|            self.env.temp_data['autodoc:class'] = self.objpath[0]\n794|\n795|        want_all = all_members or self.options.inherited_members or \\\n796|            self.options.members is ALL\n797|        # find out which members are documentable\n798|        members_check_module, members = self.get_object_members(want_all)\n799|\n800|        # document non-skipped members\n801|        memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n802|        for (mname, member, isattr) in self.filter_members(members, want_all):\n803|            classes = [cls for cls in self.documenters.values()\n804|                       if cls.can_document_member(member, mname, isattr, self)]\n805|            if not classes:\n806|                # don't know how to document this member\n807|                continue\n808|            # prefer the documenter with the highest priority\n809|            classes.sort(key=lambda cls: cls.priority)\n810|            # give explicitly separated module name, so that members\n811|            # of inner classes can be documented\n812|            full_mname = self.modname + '::' + \\\n813|                '.'.join(self.objpath + [mname])\n814|            documenter = classes[-1](self.directive, full_mname, self.indent)\n815|            memberdocumenters.append((documenter, isattr))\n816|\n817|        member_order = self.options.member_order or self.config.autodoc_member_order\n818|        memberdocumenters = self.sort_members(memberdocumenters, member_order)\n819|\n820|        for documenter, isattr in memberdocumenters:\n821|            documenter.generate(\n822|                all_members=True, real_modname=self.real_modname,\n823|                check_module=members_check_module and not isattr)\n824|\n825|        # reset current objects\n826|        self.env.temp_data['autodoc:module'] = None\n827|        self.env.temp_data['autodoc:class'] = None\n828|\n829|    def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n830|                     order: str) -> List[Tuple[\"Documenter\", bool]]:\n831|        \"\"\"Sort the given member list.\"\"\"\n832|        if order == 'groupwise':\n833|            # sort by group; alphabetically within groups\n834|            documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n835|        elif order == 'bysource':\n836|            if self.analyzer:\n837|                # sort by source order, by virtue of the module analyzer\n838|                tagorder = self.analyzer.tagorder\n839|\n840|                def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n841|                    fullname = entry[0].name.split('::')[1]\n842|                    return tagorder.get(fullname, len(tagorder))\n843|                documenters.sort(key=keyfunc)\n844|            else:\n845|                # Assume that member discovery order matches source order.\n846|                # This is a reasonable assumption in Python 3.6 and up, where\n847|                # module.__dict__ is insertion-ordered.\n848|                pass\n849|        else:  # alphabetical\n850|            documenters.sort(key=lambda e: e[0].name)\n851|\n852|        return documenters\n853|\n854|    def generate(self, more_content: Any = None, real_modname: str = None,\n855|                 check_module: bool = False, all_members: bool = False) -> None:\n856|        \"\"\"Generate reST for the object given by *self.name*, and possibly for\n857|        its members.\n858|\n859|        If *more_content* is given, include that content. If *real_modname* is\n860|        given, use that module name to find attribute docs. If *check_module* is\n861|        True, only generate if the object is defined in the module name it is\n862|        imported from. If *all_members* is True, document all members.\n863|        \"\"\"\n864|        if not self.parse_name():\n865|            # need a module to import\n866|            logger.warning(\n867|                __('don\\'t know which module to import for autodocumenting '\n868|                   '%r (try placing a \"module\" or \"currentmodule\" directive '\n869|                   'in the document, or giving an explicit module name)') %\n870|                self.name, type='autodoc')\n871|            return\n872|\n873|        # now, import the module and get object to document\n874|        if not self.import_object():\n875|            return\n876|\n877|        # If there is no real module defined, figure out which to use.\n878|        # The real module is used in the module analyzer to look up the module\n879|        # where the attribute documentation would actually be found in.\n880|        # This is used for situations where you have a module that collects the\n881|        # functions and classes of internal submodules.\n882|        guess_modname = self.get_real_modname()\n883|        self.real_modname = real_modname or guess_modname\n884|\n885|        # try to also get a source code analyzer for attribute docs\n886|        try:\n887|            self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n888|            # parse right now, to get PycodeErrors on parsing (results will\n889|            # be cached anyway)\n890|            self.analyzer.find_attr_docs()\n891|        except PycodeError as exc:\n892|            logger.debug('[autodoc] module analyzer failed: %s', exc)\n893|            # no source file -- e.g. for builtin and C modules\n894|            self.analyzer = None\n895|            # at least add the module.__file__ as a dependency\n896|            if hasattr(self.module, '__file__') and self.module.__file__:\n897|                self.directive.filename_set.add(self.module.__file__)\n898|        else:\n899|            self.directive.filename_set.add(self.analyzer.srcname)\n900|\n901|        if self.real_modname != guess_modname:\n902|            # Add module to dependency list if target object is defined in other module.\n903|            try:\n904|                analyzer = ModuleAnalyzer.for_module(guess_modname)\n905|                self.directive.filename_set.add(analyzer.srcname)\n906|            except PycodeError:\n907|                pass\n908|\n909|        # check __module__ of object (for members not given explicitly)\n910|        if check_module:\n911|            if not self.check_module():\n912|                return\n913|\n914|        sourcename = self.get_sourcename()\n915|\n916|        # make sure that the result starts with an empty line.  This is\n917|        # necessary for some situations where another directive preprocesses\n918|        # reST and no starting newline is present\n919|        self.add_line('', sourcename)\n920|\n921|        # format the object's signature, if any\n922|        try:\n923|            sig = self.format_signature()\n924|        except Exception as exc:\n925|            logger.warning(__('error while formatting signature for %s: %s'),\n926|                           self.fullname, exc, type='autodoc')\n927|            return\n928|\n929|        # generate the directive header and options, if applicable\n930|        self.add_directive_header(sig)\n931|        self.add_line('', sourcename)\n932|\n933|        # e.g. the module directive doesn't have content\n934|        self.indent += self.content_indent\n935|\n936|        # add all content (from docstrings, attribute docs etc.)\n937|        self.add_content(more_content)\n938|\n939|        # document members, if possible\n940|        self.document_members(all_members)\n941|\n942|\n943|class ModuleDocumenter(Documenter):\n944|    \"\"\"\n945|    Specialized Documenter subclass for modules.\n946|    \"\"\"\n947|    objtype = 'module'\n948|    content_indent = ''\n949|    titles_allowed = True\n950|\n...\n1674|\n1675|    # needs a higher priority than ClassDocumenter\n1676|    priority = 10\n1677|\n1678|    @classmethod\n1679|    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1680|                            ) -> bool:\n1681|        return isinstance(member, type) and issubclass(member, BaseException)\n1682|\n1683|\n1684|class DataDocumenter(ModuleLevelDocumenter):\n1685|    \"\"\"\n1686|    Specialized Documenter subclass for data items.\n1687|    \"\"\"\n1688|    objtype = 'data'\n1689|    member_order = 40\n1690|    priority = -10\n1691|    option_spec = dict(ModuleLevelDocumenter.option_spec)\n1692|    option_spec[\"annotation\"] = annotation_option\n1693|\n1694|    @classmethod\n1695|    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1696|                            ) -> bool:\n1697|        return isinstance(parent, ModuleDocumenter) and isattr\n1698|\n1699|    def add_directive_header(self, sig: str) -> None:\n1700|        super().add_directive_header(sig)\n1701|        sourcename = self.get_sourcename()\n1702|        if not self.options.annotation:\n1703|            # obtain annotation for this data\n1704|            try:\n1705|                annotations = get_type_hints(self.parent)\n1706|            except NameError:\n1707|                # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n1708|                annotations = safe_getattr(self.parent, '__annotations__', {})\n1709|            except TypeError:\n1710|                annotations = {}\n1711|            except KeyError:\n1712|                # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)\n1713|                annotations = {}\n1714|            except AttributeError:\n1715|                # AttributeError is raised on 3.5.2 (fixed by 3.5.3)\n1716|                annotations = {}\n1717|\n1718|            if self.objpath[-1] in annotations:\n1719|                objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1720|                self.add_line('   :type: ' + objrepr, sourcename)\n1721|            else:\n1722|                key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1723|                if self.analyzer and key in self.analyzer.annotations:\n1724|                    self.add_line('   :type: ' + self.analyzer.annotations[key],\n1725|                                  sourcename)\n1726|\n1727|            try:\n1728|                if self.object is UNINITIALIZED_ATTR:\n1729|                    pass\n1730|                else:\n1731|                    objrepr = object_description(self.object)\n1732|                    self.add_line('   :value: ' + objrepr, sourcename)\n1733|            except ValueError:\n1734|                pass\n1735|        elif self.options.annotation is SUPPRESS:\n1736|            pass\n1737|        else:\n1738|            self.add_line('   :annotation: %s' % self.options.annotation,\n1739|                          sourcename)\n1740|\n1741|    def document_members(self, all_members: bool = False) -> None:\n1742|        pass\n1743|\n1744|    def get_real_modname(self) -> str:\n1745|        return self.get_attr(self.parent or self.object, '__module__', None) \\\n1746|            or self.modname\n1747|\n1748|\n1749|class DataDeclarationDocumenter(DataDocumenter):\n1750|    \"\"\"\n1751|    Specialized Documenter subclass for data that cannot be imported\n1752|    because they are declared without initial value (refs: PEP-526).\n1753|    \"\"\"\n1754|    objtype = 'datadecl'\n1755|    directivetype = 'data'\n1756|    member_order = 60\n...\n2006|\n2007|    Retained for backwards compatibility, now does the same as the MethodDocumenter\n2008|    \"\"\"\n2009|\n2010|    def __init__(self, *args: Any, **kwargs: Any) -> None:\n2011|        warnings.warn(\"%s is deprecated.\" % self.__class__.__name__,\n2012|                      RemovedInSphinx50Warning, stacklevel=2)\n2013|        super().__init__(*args, **kwargs)\n2014|\n2015|\n2016|class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2017|    \"\"\"\n2018|    Specialized Documenter subclass for attributes.\n2019|    \"\"\"\n2020|    objtype = 'attribute'\n2021|    member_order = 60\n2022|    option_spec = dict(ModuleLevelDocumenter.option_spec)\n2023|    option_spec[\"annotation\"] = annotation_option\n2024|\n2025|    # must be higher than the MethodDocumenter, else it will recognize\n2026|    # some non-data descriptors as methods\n2027|    priority = 10\n2028|\n2029|    @staticmethod\n2030|    def is_function_or_method(obj: Any) -> bool:\n2031|        return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n2032|\n2033|    @classmethod\n2034|    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2035|                            ) -> bool:\n2036|        if inspect.isattributedescriptor(member):\n2037|            return True\n2038|        elif (not isinstance(parent, ModuleDocumenter) and\n2039|              not inspect.isroutine(member) and\n2040|              not isinstance(member, type)):\n2041|            return True\n2042|        else:\n2043|            return False\n2044|\n2045|    def document_members(self, all_members: bool = False) -> None:\n2046|        pass\n2047|\n2048|    def isinstanceattribute(self) -> bool:\n2049|        \"\"\"Check the subject is an instance attribute.\"\"\"\n2050|        try:\n2051|            analyzer = ModuleAnalyzer.for_module(self.modname)\n2052|            attr_docs = analyzer.find_attr_docs()\n2053|            if self.objpath:\n2054|                key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n2055|                if key in attr_docs:\n2056|                    return True\n2057|\n2058|            return False\n2059|        except PycodeError:\n2060|            return False\n2061|\n2062|    def import_object(self, raiseerror: bool = False) -> bool:\n2063|        try:\n2064|            ret = super().import_object(raiseerror=True)\n2065|            if inspect.isenumattribute(self.object):\n2066|                self.object = self.object.value\n2067|            if inspect.isattributedescriptor(self.object):\n2068|                self._datadescriptor = True\n2069|            else:\n2070|                # if it's not a data descriptor\n2071|                self._datadescriptor = False\n2072|        except ImportError as exc:\n2073|            if self.isinstanceattribute():\n2074|                self.object = INSTANCEATTR\n2075|                self._datadescriptor = False\n2076|                ret = True\n2077|            elif raiseerror:\n2078|                raise\n2079|            else:\n2080|                logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2081|                self.env.note_reread()\n2082|                ret = False\n2083|\n2084|        return ret\n2085|\n2086|    def get_real_modname(self) -> str:\n2087|        return self.get_attr(self.parent or self.object, '__module__', None) \\\n2088|            or self.modname\n2089|\n2090|    def add_directive_header(self, sig: str) -> None:\n2091|        super().add_directive_header(sig)\n2092|        sourcename = self.get_sourcename()\n2093|        if not self.options.annotation:\n2094|            # obtain type annotation for this attribute\n2095|            try:\n2096|                annotations = get_type_hints(self.parent)\n2097|            except NameError:\n2098|                # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n2099|                annotations = safe_getattr(self.parent, '__annotations__', {})\n2100|            except TypeError:\n2101|                annotations = {}\n2102|            except KeyError:\n2103|                # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)\n2104|                annotations = {}\n2105|            except AttributeError:\n2106|                # AttributeError is raised on 3.5.2 (fixed by 3.5.3)\n2107|                annotations = {}\n2108|\n2109|            if self.objpath[-1] in annotations:\n2110|                objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n2111|                self.add_line('   :type: ' + objrepr, sourcename)\n2112|            else:\n2113|                key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n2114|                if self.analyzer and key in self.analyzer.annotations:\n2115|                    self.add_line('   :type: ' + self.analyzer.annotations[key],\n2116|                                  sourcename)\n2117|\n2118|            # data descriptors do not have useful values\n2119|            if not self._datadescriptor:\n2120|                try:\n2121|                    if self.object is INSTANCEATTR:\n2122|                        pass\n2123|                    else:\n2124|                        objrepr = object_description(self.object)\n2125|                        self.add_line('   :value: ' + objrepr, sourcename)\n2126|                except ValueError:\n2127|                    pass\n2128|        elif self.options.annotation is SUPPRESS:\n2129|            pass\n2130|        else:\n2131|            self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n2132|\n2133|    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n2134|        try:\n2135|            # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n2136|            # a docstring from the value which descriptor returns unexpectedly.\n2137|            # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n2138|            orig = self.config.autodoc_inherit_docstrings\n2139|            self.config.autodoc_inherit_docstrings = False  # type: ignore\n2140|            return super().get_doc(encoding, ignore)\n2141|        finally:\n2142|            self.config.autodoc_inherit_docstrings = orig  # type: ignore\n2143|\n2144|    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n2145|        if not self._datadescriptor:\n2146|            # if it's not a data descriptor, its docstring is very probably the\n2147|            # wrong thing to display\n2148|            no_docstring = True\n2149|        super().add_content(more_content, no_docstring)\n2150|\n2151|\n2152|class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2153|    \"\"\"\n2154|    Specialized Documenter subclass for properties.\n2155|    \"\"\"\n2156|    objtype = 'property'\n2157|    directivetype = 'method'\n2158|    member_order = 60\n2159|\n...\n2173|            or self.modname\n2174|\n2175|    def add_directive_header(self, sig: str) -> None:\n2176|        super().add_directive_header(sig)\n2177|        sourcename = self.get_sourcename()\n2178|        if inspect.isabstractmethod(self.object):\n2179|            self.add_line('   :abstractmethod:', sourcename)\n2180|        self.add_line('   :property:', sourcename)\n2181|\n2182|\n2183|class InstanceAttributeDocumenter(AttributeDocumenter):\n2184|    \"\"\"\n2185|    Specialized Documenter subclass for attributes that cannot be imported\n2186|    because they are instance attributes (e.g. assigned in __init__).\n2187|    \"\"\"\n2188|    objtype = 'instanceattribute'\n2189|    directivetype = 'attribute'\n2190|    member_order = 60\n2191|\n2192|    # must be higher than AttributeDocumenter\n2193|    priority = 11\n2194|\n2195|    @classmethod\n2196|    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2197|                            ) -> bool:\n2198|        \"\"\"This documents only INSTANCEATTR members.\"\"\"\n2199|        return (not isinstance(parent, ModuleDocumenter) and\n2200|                isattr and\n2201|                member is INSTANCEATTR)\n2202|\n2203|    def import_parent(self) -> Any:\n2204|        try:\n2205|            parent = importlib.import_module(self.modname)\n2206|            for name in self.objpath[:-1]:\n2207|                parent = self.get_attr(parent, name)\n2208|\n2209|            return parent\n2210|        except (ImportError, AttributeError):\n2211|            return None\n2212|\n2213|    def import_object(self, raiseerror: bool = False) -> bool:\n2214|        \"\"\"Never import anything.\"\"\"\n2215|        # disguise as an attribute\n2216|        self.objtype = 'attribute'\n2217|        self.object = INSTANCEATTR\n2218|        self.parent = self.import_parent()\n2219|        self._datadescriptor = False\n2220|        return True\n2221|\n2222|    def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n2223|        \"\"\"Never try to get a docstring from the object.\"\"\"\n2224|        super().add_content(more_content, no_docstring=True)\n2225|\n2226|\n2227|class SlotsAttributeDocumenter(AttributeDocumenter):\n2228|    \"\"\"\n2229|    Specialized Documenter subclass for attributes that cannot be imported\n2230|    because they are attributes in __slots__.\n2231|    \"\"\"\n2232|    objtype = 'slotsattribute'\n2233|    directivetype = 'attribute'\n2234|    member_order = 60\n2235|\n2236|    # must be higher than AttributeDocumenter\n2237|    priority = 11\n2238|\n2239|    @classmethod\n2240|    def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2241|                            ) -> bool:\n2242|        \"\"\"This documents only SLOTSATTR members.\"\"\"\n2243|        return member is SLOTSATTR\n2244|\n2245|    def import_object(self, raiseerror: bool = False) -> bool:\n2246|        \"\"\"Never import anything.\"\"\"\n2247|        # disguise as an attribute\n2248|        self.objtype = 'attribute'\n2249|        self._datadescriptor = True\n2250|\n2251|        with mock(self.config.autodoc_mock_imports):\n2252|            try:\n2253|                ret = import_object(self.modname, self.objpath[:-1], 'class',\n2254|                                    attrgetter=self.get_attr,\n2255|                                    warningiserror=self.config.autodoc_warningiserror)\n2256|                self.module, _, _, self.parent = ret\n2257|                return True\n2258|            except ImportError as exc:\n2259|                if raiseerror:\n2260|                    raise\n2261|                else:\n2262|                    logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2263|                    self.env.note_reread()\n2264|                    return False\n2265|\n2266|    def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n2267|        \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n2268|        if ignore is not None:\n2269|            warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n2270|                          % self.__class__.__name__,\n2271|                          RemovedInSphinx50Warning, stacklevel=2)\n2272|        name = self.objpath[-1]\n2273|        __slots__ = inspect.getslots(self.parent)\n2274|        if __slots__ and isinstance(__slots__.get(name, None), str):\n2275|            docstring = prepare_docstring(__slots__[name])\n2276|            return [docstring]\n2277|        else:\n2278|            return []\n2279|\n2280|\n2281|def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n2282|    \"\"\"Returns registered Documenter classes\"\"\"\n2283|    warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n2284|    return app.registry.documenters\n2285|\n2286|\n2287|def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n2288|    \"\"\"Alternative getattr() for types\"\"\"\n2289|    for typ, func in app.registry.autodoc_attrgettrs.items():\n2290|        if isinstance(obj, typ):\n2291|            return func(obj, name, *defargs)\n2292|\n2293|    return safe_getattr(obj, name, *defargs)\n2294|\n2295|\n2296|def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n2297|    if config.autodoc_member_order == 'alphabetic':\n2298|        # RemovedInSphinx50Warning\n2299|        logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n2300|                          'instead of \"alphabetic\". Please update your setting.'))\n2301|        config.autodoc_member_order = 'alphabetical'  # type: ignore\n2302|\n2303|\n2304|def setup(app: Sphinx) -> Dict[str, Any]:\n2305|    app.add_autodocumenter(ModuleDocumenter)\n2306|    app.add_autodocumenter(ClassDocumenter)\n2307|    app.add_autodocumenter(ExceptionDocumenter)\n2308|    app.add_autodocumenter(DataDocumenter)\n2309|    app.add_autodocumenter(DataDeclarationDocumenter)\n2310|    app.add_autodocumenter(GenericAliasDocumenter)\n2311|    app.add_autodocumenter(TypeVarDocumenter)\n2312|    app.add_autodocumenter(FunctionDocumenter)\n2313|    app.add_autodocumenter(DecoratorDocumenter)\n2314|    app.add_autodocumenter(MethodDocumenter)\n2315|    app.add_autodocumenter(AttributeDocumenter)\n2316|    app.add_autodocumenter(PropertyDocumenter)\n2317|    app.add_autodocumenter(InstanceAttributeDocumenter)\n2318|    app.add_autodocumenter(SlotsAttributeDocumenter)\n2319|\n2320|    app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n2321|    app.add_config_value('autodoc_member_order', 'alphabetical', True,\n2322|                         ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n2323|    app.add_config_value('autodoc_default_options', {}, True)\n2324|    app.add_config_value('autodoc_docstring_signature', True, True)\n2325|    app.add_config_value('autodoc_mock_imports', [], True)\n2326|    app.add_config_value('autodoc_typehints', \"signature\", True,\n2327|                         ENUM(\"signature\", \"description\", \"none\"))\n2328|    app.add_config_value('autodoc_type_aliases', {}, True)\n2329|    app.add_config_value('autodoc_warningiserror', True, True)\n2330|    app.add_config_value('autodoc_inherit_docstrings', True, True)\n2331|    app.add_event('autodoc-before-process-signature')\n2332|    app.add_event('autodoc-process-docstring')\n2333|    app.add_event('autodoc-process-signature')\n2334|    app.add_event('autodoc-skip-member')\n2335|\n2336|    app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n2337|\n2338|    app.setup_extension('sphinx.ext.autodoc.type_comment')\n2339|    app.setup_extension('sphinx.ext.autodoc.typehints')\n2340|\n2341|    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n\n\n\n\n###\n\nPlease provide the class name, function or method name, or the exact line numbers that need to be edited.\n### Examples:\n```\nfull_path1/file1.py\nline: 10\nclass: MyClass1\nline: 51\n\nfull_path2/file2.py\nfunction: MyClass2.my_method\nline: 12\n\nfull_path3/file3.py\nfunction: my_function\nline: 24\nline: 156\n```\n\nReturn just the location(s)\n", "response": ["```\nsphinx/ext/autodoc/typehints.py\nfunction: record_typehints\nline: 23\n\nsphinx/ext/autodoc/directive.py\nline: 78\n\nsphinx/ext/autodoc/directive.py\nfunction: AutodocDirective.run\nline: 121\n\nsphinx/ext/autodoc/__init__.py\nclass: DataDocumenter\nfunction: DataDocumenter.add_directive_header\nline: 1699\n\nsphinx/ext/autodoc/__init__.py\nclass: AttributeDocumenter\nfunction: AttributeDocumenter.add_directive_header\nline: 2090\n```", "```\nsphinx/ext/autodoc/typehints.py\nfunction: record_typehints\nline: 23\n\nsphinx/ext/autodoc/typehints.py\nfunction: merge_typehints\nline: 40\n\nsphinx/ext/autodoc/directive.py\nfunction: process_documenter_options\nline: 78\n\nsphinx/ext/autodoc/__init__.py\nclass: AttributeDocumenter\nline: 2016\n\nsphinx/ext/autodoc/__init__.py\nclass: DataDocumenter\nline: 1684\n```", "```\nsphinx/ext/autodoc/typehints.py\nfunction: modify_field_list\nline: 99\nline: 103\nline: 104\n\nsphinx/ext/autodoc/directive.py\nfunction: process_documenter_options\nline: 89\n\nsphinx/ext/autodoc/__init__.py\nclass: AttributeDocumenter\nfunction: add_directive_header\nline: 2091\nline: 2111\nline: 2115\n\nclass: DataDocumenter\nfunction: add_directive_header\nline: 1699\nline: 1718\nline: 1724\n```", "```\nsphinx/ext/autodoc/typehints.py\nfunction: merge_typehints\nline: 40\nline: 66\n\nsphinx/ext/autodoc/directive.py\nfunction: AutodocDirective.run\nline: 121\nline: 137\n```"], "usage": {"completion_tokens": 436, "prompt_tokens": 14716}}}
